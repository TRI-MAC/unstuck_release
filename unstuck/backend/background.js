/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./jspm.config.js":
/*!************************!*\
  !*** ./jspm.config.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

SystemJS.config({
  transpiler: false
});

SystemJS.config({
  packageConfigPaths: [
    "npm:@*/*.json",
    "npm:*.json",
    "github:*/*.json"
  ],
  map: {
    "ajv": "npm:ajv@5.2.3",
    "babel-preset-react": "npm:babel-preset-react@6.24.1",
    "babel-standalone": "npm:babel-standalone@6.26.0",
    "bcrypt-pbkdf": "npm:bcrypt-pbkdf@1.0.1",
    "brace": "npm:brace@0.10.0",
    "cheerio": "npm:cheerio@0.22.0",
    "child_process": "npm:jspm-nodelibs-child_process@0.2.0",
    "co": "npm:co@4.6.0",
    "constants": "npm:jspm-nodelibs-constants@0.2.0",
    "crypto": "npm:jspm-nodelibs-crypto@0.2.0",
    "css-element-queries": "npm:css-element-queries@0.4.0",
    "dgram": "npm:jspm-nodelibs-dgram@0.2.0",
    "dns": "npm:jspm-nodelibs-dns@0.2.0",
    "ecc-jsbn": "npm:ecc-jsbn@0.1.1",
    "eslint": "npm:eslint@4.8.0",
    "espree": "npm:espree@3.5.1",
    "esprima": "npm:esprima@3.1.3",
    "http": "npm:jspm-nodelibs-http@0.2.0",
    "https": "npm:jspm-nodelibs-https@0.2.1",
    "icojs": "npm:icojs-min@0.5.0",
    "jimp": "npm:jimp-min@0.2.32",
    "jodid25519": "npm:jodid25519@1.0.2",
    "js-yaml": "github:nodeca/js-yaml@master",
    "jsbn": "npm:jsbn@0.1.1",
    "jspm-nodelibs-process": "npm:jspm-nodelibs-process@0.2.0",
    "list_requires_multi": "npm:list_requires_multi@1.0.2",
    "livescript15": "npm:livescript15@1.5.6",
    "assert": "npm:jspm-nodelibs-assert@0.2.0",
    "buffer": "npm:jspm-nodelibs-buffer@0.2.3",
    "cfy": "npm:cfy@1.0.20",
    "dexie": "npm:dexie@1.5.1",
    "enable-webcomponents-in-content-scripts": "npm:enable-webcomponents-in-content-scripts@1.0.7",
    "events": "npm:jspm-nodelibs-events@0.2.0",
    "fs": "npm:jspm-nodelibs-fs@0.2.0",
    "jquery": "npm:jquery@3.1.1",
    "mathjs": "npm:mathjs@3.9.0",
    "module": "npm:jspm-nodelibs-module@0.2.1",
    "moment": "npm:moment@2.17.1",
    "net": "npm:jspm-nodelibs-net@0.2.0",
    "nodeca/js-yaml": "github:nodeca/js-yaml@master",
    "os": "npm:jspm-nodelibs-os@0.2.0",
    "path": "npm:jspm-nodelibs-path@0.2.1",
    "percipio": "npm:percipio@0.1.2",
    "prelude-ls": "npm:prelude-ls@1.1.2",
    "prettier-min": "npm:prettier-min@0.15.3",
    "prettyprintjs": "npm:prettyprintjs@0.1.12",
    "process": "npm:jspm-nodelibs-process@0.2.0",
    "promise-debounce": "npm:promise-debounce@1.0.1",
    "querystring": "npm:jspm-nodelibs-querystring@0.2.0",
    "readable-stream": "npm:readable-stream@2.3.3",
    "readline": "npm:jspm-nodelibs-readline@0.2.0",
    "repl": "npm:jspm-nodelibs-repl@0.2.0",
    "shuffled": "npm:shuffled@1.0.0",
    "sortablejs": "npm:sortablejs@1.5.0-rc1",
    "stream": "npm:jspm-nodelibs-stream@0.2.0",
    "string_decoder": "npm:jspm-nodelibs-string_decoder@0.2.2",
    "sweetalert2": "npm:sweetalert2@6.3.2",
    "sweetjs-min": "npm:sweetjs-min@2.2.14",
    "text": "github:systemjs/plugin-text@0.0.8",
    "timers": "npm:jspm-nodelibs-timers@0.2.0",
    "tls": "npm:jspm-nodelibs-tls@0.2.0",
    "tty": "npm:jspm-nodelibs-tty@0.2.0",
    "tweetnacl": "npm:tweetnacl@0.14.5",
    "underscore": "npm:underscore@1.8.3",
    "url": "npm:jspm-nodelibs-url@0.2.0",
    "util": "npm:jspm-nodelibs-util@0.2.1",
    "vm": "npm:jspm-nodelibs-vm@0.2.0",
    "zlib": "npm:jspm-nodelibs-zlib@0.2.2"
  },
  packages: {
    "npm:enable-webcomponents-in-content-scripts@1.0.7": {
      "map": {
        "webcomponentsjs-custom-element-v0": "npm:webcomponentsjs-custom-element-v0@1.0.1"
      }
    },
    "npm:percipio@0.1.2": {
      "map": {
        "fast-csv": "npm:fast-csv@0.5.7",
        "underscore": "npm:underscore@1.8.3"
      }
    },
    "npm:fast-csv@0.5.7": {
      "map": {
        "is-extended": "npm:is-extended@0.0.10",
        "extended": "npm:extended@0.0.6",
        "string-extended": "npm:string-extended@0.0.8",
        "object-extended": "npm:object-extended@0.0.7"
      }
    },
    "npm:is-extended@0.0.10": {
      "map": {
        "extended": "npm:extended@0.0.6"
      }
    },
    "npm:string-extended@0.0.8": {
      "map": {
        "extended": "npm:extended@0.0.6",
        "is-extended": "npm:is-extended@0.0.10",
        "date-extended": "npm:date-extended@0.0.6",
        "array-extended": "npm:array-extended@0.0.11"
      }
    },
    "npm:object-extended@0.0.7": {
      "map": {
        "extended": "npm:extended@0.0.6",
        "is-extended": "npm:is-extended@0.0.10",
        "array-extended": "npm:array-extended@0.0.11"
      }
    },
    "npm:extended@0.0.6": {
      "map": {
        "extender": "npm:extender@0.0.10"
      }
    },
    "npm:date-extended@0.0.6": {
      "map": {
        "extended": "npm:extended@0.0.6",
        "is-extended": "npm:is-extended@0.0.10",
        "array-extended": "npm:array-extended@0.0.11"
      }
    },
    "npm:array-extended@0.0.11": {
      "map": {
        "extended": "npm:extended@0.0.6",
        "is-extended": "npm:is-extended@0.0.10",
        "arguments-extended": "npm:arguments-extended@0.0.3"
      }
    },
    "npm:extender@0.0.10": {
      "map": {
        "declare.js": "npm:declare.js@0.0.8"
      }
    },
    "npm:arguments-extended@0.0.3": {
      "map": {
        "extended": "npm:extended@0.0.6",
        "is-extended": "npm:is-extended@0.0.10"
      }
    },
    "npm:stream-browserify@2.0.1": {
      "map": {
        "readable-stream": "npm:readable-stream@2.3.3",
        "inherits": "npm:inherits@2.0.3"
      }
    },
    "npm:shuffled@1.0.0": {
      "map": {
        "shuffle-array": "npm:shuffle-array@1.0.0"
      }
    },
    "npm:jspm-nodelibs-stream@0.2.0": {
      "map": {
        "stream-browserify": "npm:stream-browserify@2.0.1"
      }
    },
    "npm:jspm-nodelibs-os@0.2.0": {
      "map": {
        "os-browserify": "npm:os-browserify@0.2.1"
      }
    },
    "npm:jspm-nodelibs-crypto@0.2.0": {
      "map": {
        "crypto-browserify": "npm:crypto-browserify@3.11.1"
      }
    },
    "npm:diffie-hellman@5.0.2": {
      "map": {
        "randombytes": "npm:randombytes@2.0.5",
        "bn.js": "npm:bn.js@4.11.8",
        "miller-rabin": "npm:miller-rabin@4.0.1"
      }
    },
    "npm:public-encrypt@4.0.0": {
      "map": {
        "create-hash": "npm:create-hash@1.1.3",
        "randombytes": "npm:randombytes@2.0.5",
        "browserify-rsa": "npm:browserify-rsa@4.0.1",
        "parse-asn1": "npm:parse-asn1@5.1.0",
        "bn.js": "npm:bn.js@4.11.8"
      }
    },
    "npm:browserify-cipher@1.0.0": {
      "map": {
        "browserify-des": "npm:browserify-des@1.0.0",
        "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
        "browserify-aes": "npm:browserify-aes@1.1.1"
      }
    },
    "npm:browserify-des@1.0.0": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "cipher-base": "npm:cipher-base@1.0.4",
        "des.js": "npm:des.js@1.0.0"
      }
    },
    "npm:create-ecdh@4.0.0": {
      "map": {
        "elliptic": "npm:elliptic@6.4.0",
        "bn.js": "npm:bn.js@4.11.8"
      }
    },
    "npm:browserify-rsa@4.0.1": {
      "map": {
        "randombytes": "npm:randombytes@2.0.5",
        "bn.js": "npm:bn.js@4.11.8"
      }
    },
    "npm:des.js@1.0.0": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
      }
    },
    "npm:asn1.js@4.9.1": {
      "map": {
        "bn.js": "npm:bn.js@4.11.8",
        "inherits": "npm:inherits@2.0.3",
        "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
      }
    },
    "npm:mathjs@3.9.0": {
      "map": {
        "decimal.js": "npm:decimal.js@5.0.8",
        "typed-function": "npm:typed-function@0.10.5",
        "complex.js": "npm:complex.js@2.0.1",
        "tiny-emitter": "npm:tiny-emitter@1.0.2",
        "fraction.js": "npm:fraction.js@3.3.1"
      }
    },
    "npm:sweetalert2@6.3.2": {
      "map": {
        "es6-promise": "npm:es6-promise@4.0.5"
      }
    },
    "npm:unthenify@1.0.4": {
      "map": {
        "util-arity": "npm:util-arity@1.1.0",
        "any-promise": "npm:any-promise@1.3.0"
      }
    },
    "npm:cheerio@0.22.0": {
      "map": {
        "lodash.defaults": "npm:lodash.defaults@4.2.0",
        "dom-serializer": "npm:dom-serializer@0.1.0",
        "entities": "npm:entities@1.1.1",
        "lodash.assignin": "npm:lodash.assignin@4.2.0",
        "lodash.pick": "npm:lodash.pick@4.4.0",
        "htmlparser2": "npm:htmlparser2@3.9.2",
        "css-select": "npm:css-select@1.2.0",
        "lodash.bind": "npm:lodash.bind@4.2.1",
        "lodash.reduce": "npm:lodash.reduce@4.6.0",
        "lodash.flatten": "npm:lodash.flatten@4.4.0",
        "lodash.foreach": "npm:lodash.foreach@4.5.0",
        "lodash.merge": "npm:lodash.merge@4.6.0",
        "lodash.map": "npm:lodash.map@4.6.0",
        "lodash.some": "npm:lodash.some@4.6.0",
        "lodash.filter": "npm:lodash.filter@4.6.0",
        "lodash.reject": "npm:lodash.reject@4.6.0"
      }
    },
    "npm:dom-serializer@0.1.0": {
      "map": {
        "entities": "npm:entities@1.1.1",
        "domelementtype": "npm:domelementtype@1.1.3"
      }
    },
    "npm:htmlparser2@3.9.2": {
      "map": {
        "entities": "npm:entities@1.1.1",
        "domutils": "npm:domutils@1.5.1",
        "inherits": "npm:inherits@2.0.3",
        "domelementtype": "npm:domelementtype@1.3.0",
        "readable-stream": "npm:readable-stream@2.3.3",
        "node-readable-stream": "npm:readable-stream@2.3.3",
        "domhandler": "npm:domhandler@2.3.0"
      }
    },
    "npm:css-select@1.2.0": {
      "map": {
        "domutils": "npm:domutils@1.5.1",
        "boolbase": "npm:boolbase@1.0.0",
        "css-what": "npm:css-what@2.1.0",
        "nth-check": "npm:nth-check@1.0.1"
      }
    },
    "npm:domutils@1.5.1": {
      "map": {
        "dom-serializer": "npm:dom-serializer@0.1.0",
        "domelementtype": "npm:domelementtype@1.3.0"
      }
    },
    "npm:nth-check@1.0.1": {
      "map": {
        "boolbase": "npm:boolbase@1.0.0"
      }
    },
    "npm:domhandler@2.3.0": {
      "map": {
        "domelementtype": "npm:domelementtype@1.3.0"
      }
    },
    "npm:shift-reducer@3.0.3": {
      "map": {
        "shift-spec": "npm:shift-spec@2015.2.1"
      }
    },
    "npm:es6-map@0.1.4": {
      "map": {
        "event-emitter": "npm:event-emitter@0.3.4",
        "es6-set": "npm:es6-set@0.1.4",
        "es6-iterator": "npm:es6-iterator@2.0.0",
        "d": "npm:d@0.1.1",
        "es6-symbol": "npm:es6-symbol@3.1.0",
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:es6-set@0.1.4": {
      "map": {
        "es6-iterator": "npm:es6-iterator@2.0.0",
        "event-emitter": "npm:event-emitter@0.3.4",
        "d": "npm:d@0.1.1",
        "es6-symbol": "npm:es6-symbol@3.1.0",
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:event-emitter@0.3.4": {
      "map": {
        "d": "npm:d@0.1.1",
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:es6-iterator@2.0.0": {
      "map": {
        "d": "npm:d@0.1.1",
        "es6-symbol": "npm:es6-symbol@3.1.0",
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:es6-symbol@3.1.0": {
      "map": {
        "d": "npm:d@0.1.1",
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:d@0.1.1": {
      "map": {
        "es5-ext": "npm:es5-ext@0.10.12"
      }
    },
    "npm:es5-ext@0.10.12": {
      "map": {
        "es6-iterator": "npm:es6-iterator@2.0.0",
        "es6-symbol": "npm:es6-symbol@3.1.0"
      }
    },
    "npm:babel-code-frame@6.22.0": {
      "map": {
        "chalk": "npm:chalk@1.1.3",
        "js-tokens": "npm:js-tokens@3.0.2",
        "esutils": "npm:esutils@2.0.2"
      }
    },
    "npm:chalk@1.1.3": {
      "map": {
        "has-ansi": "npm:has-ansi@2.0.0",
        "ansi-styles": "npm:ansi-styles@2.2.1",
        "strip-ansi": "npm:strip-ansi@3.0.1",
        "supports-color": "npm:supports-color@2.0.0",
        "escape-string-regexp": "npm:escape-string-regexp@1.0.5"
      }
    },
    "npm:jest-validate@18.2.0": {
      "map": {
        "chalk": "npm:chalk@1.1.3",
        "leven": "npm:leven@2.0.0",
        "jest-matcher-utils": "npm:jest-matcher-utils@18.1.0",
        "pretty-format": "npm:pretty-format@18.1.0"
      }
    },
    "npm:has-ansi@2.0.0": {
      "map": {
        "ansi-regex": "npm:ansi-regex@2.1.1"
      }
    },
    "npm:strip-ansi@3.0.1": {
      "map": {
        "ansi-regex": "npm:ansi-regex@2.1.1"
      }
    },
    "npm:jest-matcher-utils@18.1.0": {
      "map": {
        "chalk": "npm:chalk@1.1.3",
        "pretty-format": "npm:pretty-format@18.1.0"
      }
    },
    "npm:pretty-format@18.1.0": {
      "map": {
        "ansi-styles": "npm:ansi-styles@2.2.1"
      }
    },
    "npm:prettier-min@0.15.3": {
      "map": {
        "babel-code-frame": "npm:babel-code-frame@6.22.0",
        "esutils": "npm:esutils@2.0.2",
        "jest-validate": "npm:jest-validate@18.2.0",
        "babylon": "npm:babylon@6.15.0",
        "ast-types": "npm:ast-types@0.9.4"
      }
    },
    "npm:cfy@1.0.20": {
      "map": {
        "co": "npm:co@4.6.0",
        "unthenify": "npm:unthenify@1.0.4"
      }
    },
    "npm:sweetjs-min@2.2.14": {
      "map": {
        "immutable": "npm:immutable@3.8.1",
        "shift-reducer": "npm:shift-reducer@3.0.3",
        "ramda": "npm:ramda@0.19.1",
        "ramda-fantasy": "npm:ramda-fantasy@0.4.1",
        "shift-codegen": "npm:shift-codegen@4.0.3",
        "shift-parser": "npm:shift-parser@4.1.3",
        "transit-js": "npm:transit-js@0.8.846",
        "sweet-spec": "npm:sweet-spec@1.1.0"
      }
    },
    "npm:ramda-fantasy@0.4.1": {
      "map": {
        "ramda": "npm:ramda@0.17.1"
      }
    },
    "npm:shift-codegen@4.0.3": {
      "map": {
        "shift-reducer": "npm:shift-reducer@3.0.3",
        "object-assign": "npm:object-assign@3.0.0",
        "esutils": "npm:esutils@2.0.2"
      }
    },
    "npm:shift-parser@4.1.3": {
      "map": {
        "shift-reducer": "npm:shift-reducer@3.0.3",
        "esutils": "npm:esutils@2.0.2",
        "es6-map": "npm:es6-map@0.1.4",
        "multimap": "npm:multimap@0.1.1"
      }
    },
    "npm:elliptic@6.4.0": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "bn.js": "npm:bn.js@4.11.8",
        "hmac-drbg": "npm:hmac-drbg@1.0.1",
        "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1",
        "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
        "hash.js": "npm:hash.js@1.1.3",
        "brorand": "npm:brorand@1.1.0"
      }
    },
    "npm:jimp-min@0.2.32": {
      "map": {
        "bignumber.js": "npm:bignumber.js@2.4.0",
        "file-type": "npm:file-type@3.9.0",
        "request": "npm:request@2.80.0",
        "tinycolor2": "npm:tinycolor2@1.4.1",
        "url-regex": "npm:url-regex@3.2.0",
        "mime": "npm:mime@1.3.4",
        "pngjs": "npm:pngjs@3.0.1",
        "stream-to-buffer": "npm:stream-to-buffer@0.1.0",
        "read-chunk": "npm:read-chunk@1.0.1",
        "load-bmfont": "npm:load-bmfont@1.3.0",
        "jpeg-js": "npm:jpeg-js@0.2.0",
        "pixelmatch": "npm:pixelmatch@4.0.2",
        "exif-parser": "npm:exif-parser@0.1.9",
        "bmp-js": "npm:bmp-js@0.0.2"
      }
    },
    "npm:url-regex@3.2.0": {
      "map": {
        "ip-regex": "npm:ip-regex@1.0.3"
      }
    },
    "npm:request@2.80.0": {
      "map": {
        "caseless": "npm:caseless@0.12.0",
        "aws-sign2": "npm:aws-sign2@0.6.0",
        "aws4": "npm:aws4@1.6.0",
        "form-data": "npm:form-data@2.1.2",
        "har-validator": "npm:har-validator@4.2.1",
        "is-typedarray": "npm:is-typedarray@1.0.0",
        "extend": "npm:extend@3.0.0",
        "combined-stream": "npm:combined-stream@1.0.5",
        "http-signature": "npm:http-signature@1.1.1",
        "forever-agent": "npm:forever-agent@0.6.1",
        "isstream": "npm:isstream@0.1.2",
        "json-stringify-safe": "npm:json-stringify-safe@5.0.1",
        "mime-types": "npm:mime-types@2.1.14",
        "stringstream": "npm:stringstream@0.0.5",
        "performance-now": "npm:performance-now@0.2.0",
        "oauth-sign": "npm:oauth-sign@0.8.2",
        "tough-cookie": "npm:tough-cookie@2.3.2",
        "tunnel-agent": "npm:tunnel-agent@0.4.3",
        "uuid": "npm:uuid@3.0.1",
        "qs": "npm:qs@6.3.1",
        "hawk": "npm:hawk@3.1.3"
      }
    },
    "npm:load-bmfont@1.3.0": {
      "map": {
        "mime": "npm:mime@1.3.4",
        "xtend": "npm:xtend@4.0.1",
        "buffer-equal": "npm:buffer-equal@0.0.1",
        "parse-bmfont-binary": "npm:parse-bmfont-binary@1.0.6",
        "xhr": "npm:xhr@2.4.0",
        "parse-bmfont-xml": "npm:parse-bmfont-xml@1.1.3",
        "parse-bmfont-ascii": "npm:parse-bmfont-ascii@1.0.6"
      }
    },
    "npm:pixelmatch@4.0.2": {
      "map": {
        "pngjs": "npm:pngjs@3.0.1"
      }
    },
    "npm:form-data@2.1.2": {
      "map": {
        "combined-stream": "npm:combined-stream@1.0.5",
        "mime-types": "npm:mime-types@2.1.14",
        "asynckit": "npm:asynckit@0.4.0"
      }
    },
    "npm:har-validator@4.2.1": {
      "map": {
        "har-schema": "npm:har-schema@1.0.5",
        "ajv": "npm:ajv@4.11.4"
      }
    },
    "npm:combined-stream@1.0.5": {
      "map": {
        "delayed-stream": "npm:delayed-stream@1.0.0"
      }
    },
    "npm:stream-to-buffer@0.1.0": {
      "map": {
        "stream-to": "npm:stream-to@0.2.2"
      }
    },
    "npm:http-signature@1.1.1": {
      "map": {
        "jsprim": "npm:jsprim@1.3.1",
        "assert-plus": "npm:assert-plus@0.2.0",
        "sshpk": "npm:sshpk@1.11.0"
      }
    },
    "npm:mime-types@2.1.14": {
      "map": {
        "mime-db": "npm:mime-db@1.26.0"
      }
    },
    "npm:tough-cookie@2.3.2": {
      "map": {
        "punycode": "npm:punycode@1.4.1"
      }
    },
    "npm:jspm-nodelibs-url@0.2.0": {
      "map": {
        "url-browserify": "npm:url@0.11.0"
      }
    },
    "npm:hawk@3.1.3": {
      "map": {
        "boom": "npm:boom@2.10.1",
        "cryptiles": "npm:cryptiles@2.0.5",
        "sntp": "npm:sntp@1.0.9",
        "hoek": "npm:hoek@2.16.3"
      }
    },
    "npm:jspm-nodelibs-http@0.2.0": {
      "map": {
        "http-browserify": "npm:stream-http@2.6.3"
      }
    },
    "npm:jspm-nodelibs-zlib@0.2.2": {
      "map": {
        "browserify-zlib": "npm:browserify-zlib@0.1.4"
      }
    },
    "npm:sshpk@1.11.0": {
      "map": {
        "assert-plus": "npm:assert-plus@1.0.0",
        "dashdash": "npm:dashdash@1.14.1",
        "asn1": "npm:asn1@0.2.3",
        "getpass": "npm:getpass@0.1.6"
      }
    },
    "npm:xhr@2.4.0": {
      "map": {
        "xtend": "npm:xtend@4.0.1",
        "global": "npm:global@4.3.1",
        "is-function": "npm:is-function@1.0.1",
        "parse-headers": "npm:parse-headers@2.0.1"
      }
    },
    "npm:url@0.11.0": {
      "map": {
        "punycode": "npm:punycode@1.3.2",
        "querystring": "npm:querystring@0.2.0"
      }
    },
    "npm:cryptiles@2.0.5": {
      "map": {
        "boom": "npm:boom@2.10.1"
      }
    },
    "npm:boom@2.10.1": {
      "map": {
        "hoek": "npm:hoek@2.16.3"
      }
    },
    "npm:ajv@4.11.4": {
      "map": {
        "json-stable-stringify": "npm:json-stable-stringify@1.0.1",
        "co": "npm:co@4.6.0"
      }
    },
    "npm:jsprim@1.3.1": {
      "map": {
        "extsprintf": "npm:extsprintf@1.0.2",
        "json-schema": "npm:json-schema@0.2.3",
        "verror": "npm:verror@1.3.6"
      }
    },
    "npm:sntp@1.0.9": {
      "map": {
        "hoek": "npm:hoek@2.16.3"
      }
    },
    "npm:parse-bmfont-xml@1.1.3": {
      "map": {
        "xml2js": "npm:xml2js@0.4.17",
        "xml-parse-from-string": "npm:xml-parse-from-string@1.0.0"
      }
    },
    "npm:stream-http@2.6.3": {
      "map": {
        "xtend": "npm:xtend@4.0.1",
        "to-arraybuffer": "npm:to-arraybuffer@1.0.1",
        "builtin-status-codes": "npm:builtin-status-codes@3.0.0",
        "inherits": "npm:inherits@2.0.3",
        "readable-stream": "npm:readable-stream@2.3.3"
      }
    },
    "npm:browserify-zlib@0.1.4": {
      "map": {
        "readable-stream": "npm:readable-stream@2.3.3",
        "pako": "npm:pako@0.2.9"
      }
    },
    "npm:dashdash@1.14.1": {
      "map": {
        "assert-plus": "npm:assert-plus@1.0.0"
      }
    },
    "npm:getpass@0.1.6": {
      "map": {
        "assert-plus": "npm:assert-plus@1.0.0"
      }
    },
    "npm:jodid25519@1.0.2": {
      "map": {
        "jsbn": "npm:jsbn@0.1.1"
      }
    },
    "npm:bcrypt-pbkdf@1.0.1": {
      "map": {
        "tweetnacl": "npm:tweetnacl@0.14.5"
      }
    },
    "npm:ecc-jsbn@0.1.1": {
      "map": {
        "jsbn": "npm:jsbn@0.1.1"
      }
    },
    "npm:verror@1.3.6": {
      "map": {
        "extsprintf": "npm:extsprintf@1.0.2"
      }
    },
    "npm:json-stable-stringify@1.0.1": {
      "map": {
        "jsonify": "npm:jsonify@0.0.0"
      }
    },
    "npm:xml2js@0.4.17": {
      "map": {
        "xmlbuilder": "npm:xmlbuilder@4.2.1",
        "sax": "npm:sax@1.2.2"
      }
    },
    "npm:global@4.3.1": {
      "map": {
        "process": "npm:process@0.5.2",
        "min-document": "npm:min-document@2.19.0",
        "node-min-document": "npm:min-document@2.19.0"
      }
    },
    "npm:parse-headers@2.0.1": {
      "map": {
        "trim": "npm:trim@0.0.1",
        "for-each": "npm:for-each@0.3.2"
      }
    },
    "npm:for-each@0.3.2": {
      "map": {
        "is-function": "npm:is-function@1.0.1"
      }
    },
    "npm:jspm-nodelibs-timers@0.2.0": {
      "map": {
        "timers-browserify": "npm:timers-browserify@1.4.2"
      }
    },
    "npm:xmlbuilder@4.2.1": {
      "map": {
        "lodash": "npm:lodash@4.17.10"
      }
    },
    "npm:min-document@2.19.0": {
      "map": {
        "dom-walk": "npm:dom-walk@0.1.1"
      }
    },
    "npm:timers-browserify@1.4.2": {
      "map": {
        "process": "npm:process@0.11.9"
      }
    },
    "npm:browserify-sign@4.0.4": {
      "map": {
        "create-hmac": "npm:create-hmac@1.1.6",
        "inherits": "npm:inherits@2.0.3",
        "create-hash": "npm:create-hash@1.1.3",
        "browserify-rsa": "npm:browserify-rsa@4.0.1",
        "bn.js": "npm:bn.js@4.11.8",
        "elliptic": "npm:elliptic@6.4.0",
        "parse-asn1": "npm:parse-asn1@5.1.0"
      }
    },
    "npm:parse-asn1@5.1.0": {
      "map": {
        "browserify-aes": "npm:browserify-aes@1.1.1",
        "create-hash": "npm:create-hash@1.1.3",
        "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
        "pbkdf2": "npm:pbkdf2@3.0.14",
        "asn1.js": "npm:asn1.js@4.9.1"
      }
    },
    "npm:hmac-drbg@1.0.1": {
      "map": {
        "hash.js": "npm:hash.js@1.1.3",
        "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
        "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1"
      }
    },
    "npm:livescript15@1.5.6": {
      "map": {
        "prelude-ls": "npm:prelude-ls@1.1.2"
      }
    },
    "npm:acorn-jsx@3.0.1": {
      "map": {
        "acorn": "npm:acorn@3.3.0"
      }
    },
    "npm:list_requires_multi@1.0.2": {
      "map": {
        "espree": "npm:espree@3.5.1",
        "esprima-walk": "npm:esprima-walk@0.1.0"
      }
    },
    "npm:eslint@4.8.0": {
      "map": {
        "eslint-scope": "npm:eslint-scope@3.7.1",
        "esquery": "npm:esquery@1.0.0",
        "is-resolvable": "npm:is-resolvable@1.0.0",
        "file-entry-cache": "npm:file-entry-cache@2.0.0",
        "levn": "npm:levn@0.3.0",
        "natural-compare": "npm:natural-compare@1.4.0",
        "imurmurhash": "npm:imurmurhash@0.1.4",
        "estraverse": "npm:estraverse@4.2.0",
        "doctrine": "npm:doctrine@2.0.0",
        "pluralize": "npm:pluralize@7.0.0",
        "cross-spawn": "npm:cross-spawn@5.1.0",
        "chalk": "npm:chalk@2.1.0",
        "ignore": "npm:ignore@3.3.5",
        "strip-ansi": "npm:strip-ansi@4.0.0",
        "strip-json-comments": "npm:strip-json-comments@2.0.1",
        "semver": "npm:semver@5.4.1",
        "esutils": "npm:esutils@2.0.2",
        "table": "npm:table@4.0.2",
        "glob": "npm:glob@7.1.2",
        "babel-code-frame": "npm:babel-code-frame@6.22.0",
        "inquirer": "npm:inquirer@3.3.0",
        "path-is-inside": "npm:path-is-inside@1.0.2",
        "progress": "npm:progress@2.0.0",
        "text-table": "npm:text-table@0.2.0",
        "json-stable-stringify": "npm:json-stable-stringify@1.0.1",
        "functional-red-black-tree": "npm:functional-red-black-tree@1.0.1",
        "require-uncached": "npm:require-uncached@1.0.3",
        "optionator": "npm:optionator@0.8.2",
        "concat-stream": "npm:concat-stream@1.6.0",
        "minimatch": "npm:minimatch@3.0.4",
        "globals": "npm:globals@9.18.0",
        "mkdirp": "npm:mkdirp@0.5.1",
        "debug": "npm:debug@3.1.0",
        "espree": "npm:espree@3.5.1",
        "js-yaml": "npm:js-yaml@3.10.0",
        "lodash": "npm:lodash@4.17.10",
        "ajv": "npm:ajv@5.2.3"
      }
    },
    "npm:eslint-scope@3.7.1": {
      "map": {
        "estraverse": "npm:estraverse@4.2.0",
        "esrecurse": "npm:esrecurse@4.2.0"
      }
    },
    "npm:esquery@1.0.0": {
      "map": {
        "estraverse": "npm:estraverse@4.2.0"
      }
    },
    "npm:doctrine@2.0.0": {
      "map": {
        "esutils": "npm:esutils@2.0.2",
        "isarray": "npm:isarray@1.0.0"
      }
    },
    "npm:file-entry-cache@2.0.0": {
      "map": {
        "flat-cache": "npm:flat-cache@1.3.0",
        "object-assign": "npm:object-assign@4.1.1"
      }
    },
    "npm:glob@7.1.2": {
      "map": {
        "minimatch": "npm:minimatch@3.0.4",
        "fs.realpath": "npm:fs.realpath@1.0.0",
        "inflight": "npm:inflight@1.0.6",
        "path-is-absolute": "npm:path-is-absolute@1.0.1",
        "once": "npm:once@1.4.0",
        "inherits": "npm:inherits@2.0.3"
      }
    },
    "npm:table@4.0.2": {
      "map": {
        "chalk": "npm:chalk@2.1.0",
        "lodash": "npm:lodash@4.17.10",
        "slice-ansi": "npm:slice-ansi@1.0.0",
        "string-width": "npm:string-width@2.1.1",
        "ajv-keywords": "npm:ajv-keywords@2.1.0",
        "ajv": "npm:ajv@5.2.3"
      }
    },
    "npm:inquirer@3.3.0": {
      "map": {
        "chalk": "npm:chalk@2.1.0",
        "strip-ansi": "npm:strip-ansi@4.0.0",
        "lodash": "npm:lodash@4.17.10",
        "string-width": "npm:string-width@2.1.1",
        "cli-cursor": "npm:cli-cursor@2.1.0",
        "mute-stream": "npm:mute-stream@0.0.7",
        "ansi-escapes": "npm:ansi-escapes@3.0.0",
        "cli-width": "npm:cli-width@2.2.0",
        "run-async": "npm:run-async@2.3.0",
        "external-editor": "npm:external-editor@2.0.5",
        "figures": "npm:figures@2.0.0",
        "through": "npm:through@2.3.8",
        "rx-lite-aggregates": "npm:rx-lite-aggregates@4.0.8",
        "rx-lite": "npm:rx-lite@4.0.8"
      }
    },
    "npm:cross-spawn@5.1.0": {
      "map": {
        "shebang-command": "npm:shebang-command@1.2.0",
        "which": "npm:which@1.3.0",
        "lru-cache": "npm:lru-cache@4.1.1"
      }
    },
    "npm:levn@0.3.0": {
      "map": {
        "type-check": "npm:type-check@0.3.2",
        "prelude-ls": "npm:prelude-ls@1.1.2"
      }
    },
    "npm:chalk@2.1.0": {
      "map": {
        "ansi-styles": "npm:ansi-styles@3.2.0",
        "supports-color": "npm:supports-color@4.4.0",
        "escape-string-regexp": "npm:escape-string-regexp@1.0.5"
      }
    },
    "npm:optionator@0.8.2": {
      "map": {
        "type-check": "npm:type-check@0.3.2",
        "levn": "npm:levn@0.3.0",
        "deep-is": "npm:deep-is@0.1.3",
        "prelude-ls": "npm:prelude-ls@1.1.2",
        "fast-levenshtein": "npm:fast-levenshtein@2.0.6",
        "wordwrap": "npm:wordwrap@1.0.0"
      }
    },
    "npm:esrecurse@4.2.0": {
      "map": {
        "estraverse": "npm:estraverse@4.2.0",
        "object-assign": "npm:object-assign@4.1.1"
      }
    },
    "npm:is-resolvable@1.0.0": {
      "map": {
        "tryit": "npm:tryit@1.0.3"
      }
    },
    "npm:concat-stream@1.6.0": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "typedarray": "npm:typedarray@0.0.6",
        "readable-stream": "npm:readable-stream@2.3.3"
      }
    },
    "npm:require-uncached@1.0.3": {
      "map": {
        "caller-path": "npm:caller-path@0.1.0",
        "resolve-from": "npm:resolve-from@1.0.1"
      }
    },
    "npm:type-check@0.3.2": {
      "map": {
        "prelude-ls": "npm:prelude-ls@1.1.2"
      }
    },
    "npm:string-width@2.1.1": {
      "map": {
        "strip-ansi": "npm:strip-ansi@4.0.0",
        "is-fullwidth-code-point": "npm:is-fullwidth-code-point@2.0.0"
      }
    },
    "npm:inflight@1.0.6": {
      "map": {
        "once": "npm:once@1.4.0",
        "wrappy": "npm:wrappy@1.0.2"
      }
    },
    "npm:flat-cache@1.3.0": {
      "map": {
        "circular-json": "npm:circular-json@0.3.3",
        "graceful-fs": "npm:graceful-fs@4.1.11",
        "write": "npm:write@0.2.1",
        "del": "npm:del@2.2.2"
      }
    },
    "npm:minimatch@3.0.4": {
      "map": {
        "brace-expansion": "npm:brace-expansion@1.1.8"
      }
    },
    "npm:figures@2.0.0": {
      "map": {
        "escape-string-regexp": "npm:escape-string-regexp@1.0.5"
      }
    },
    "npm:rx-lite-aggregates@4.0.8": {
      "map": {
        "rx-lite": "npm:rx-lite@4.0.8"
      }
    },
    "npm:which@1.3.0": {
      "map": {
        "isexe": "npm:isexe@2.0.0"
      }
    },
    "npm:lru-cache@4.1.1": {
      "map": {
        "pseudomap": "npm:pseudomap@1.0.2",
        "yallist": "npm:yallist@2.1.2"
      }
    },
    "npm:supports-color@4.4.0": {
      "map": {
        "has-flag": "npm:has-flag@2.0.0"
      }
    },
    "npm:shebang-command@1.2.0": {
      "map": {
        "shebang-regex": "npm:shebang-regex@1.0.0"
      }
    },
    "npm:debug@3.1.0": {
      "map": {
        "ms": "npm:ms@2.0.0"
      }
    },
    "npm:strip-ansi@4.0.0": {
      "map": {
        "ansi-regex": "npm:ansi-regex@3.0.0"
      }
    },
    "npm:espree@3.5.1": {
      "map": {
        "acorn-jsx": "npm:acorn-jsx@3.0.1",
        "acorn": "npm:acorn@5.1.2"
      }
    },
    "npm:mkdirp@0.5.1": {
      "map": {
        "minimist": "npm:minimist@0.0.8"
      }
    },
    "npm:ansi-styles@3.2.0": {
      "map": {
        "color-convert": "npm:color-convert@1.9.0"
      }
    },
    "npm:once@1.4.0": {
      "map": {
        "wrappy": "npm:wrappy@1.0.2"
      }
    },
    "npm:cli-cursor@2.1.0": {
      "map": {
        "restore-cursor": "npm:restore-cursor@2.0.0"
      }
    },
    "npm:caller-path@0.1.0": {
      "map": {
        "callsites": "npm:callsites@0.2.0"
      }
    },
    "npm:run-async@2.3.0": {
      "map": {
        "is-promise": "npm:is-promise@2.1.0"
      }
    },
    "npm:slice-ansi@1.0.0": {
      "map": {
        "is-fullwidth-code-point": "npm:is-fullwidth-code-point@2.0.0"
      }
    },
    "npm:ajv@5.2.3": {
      "map": {
        "json-stable-stringify": "npm:json-stable-stringify@1.0.1",
        "fast-deep-equal": "npm:fast-deep-equal@1.0.0",
        "co": "npm:co@4.6.0",
        "json-schema-traverse": "npm:json-schema-traverse@0.3.1"
      }
    },
    "npm:readable-stream@2.3.3": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "isarray": "npm:isarray@1.0.0",
        "core-util-is": "npm:core-util-is@1.0.2",
        "util-deprecate": "npm:util-deprecate@1.0.2",
        "process-nextick-args": "npm:process-nextick-args@1.0.7",
        "string_decoder": "npm:string_decoder@1.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:external-editor@2.0.5": {
      "map": {
        "jschardet": "npm:jschardet@1.5.1",
        "tmp": "npm:tmp@0.0.33",
        "iconv-lite": "npm:iconv-lite@0.4.19"
      }
    },
    "npm:js-yaml@3.10.0": {
      "map": {
        "argparse": "npm:argparse@1.0.9",
        "esprima": "npm:esprima@4.0.0"
      }
    },
    "npm:write@0.2.1": {
      "map": {
        "mkdirp": "npm:mkdirp@0.5.1"
      }
    },
    "npm:del@2.2.2": {
      "map": {
        "object-assign": "npm:object-assign@4.1.1",
        "is-path-in-cwd": "npm:is-path-in-cwd@1.0.0",
        "is-path-cwd": "npm:is-path-cwd@1.0.0",
        "pinkie-promise": "npm:pinkie-promise@2.0.1",
        "pify": "npm:pify@2.3.0",
        "globby": "npm:globby@5.0.0",
        "rimraf": "npm:rimraf@2.6.2"
      }
    },
    "npm:brace-expansion@1.1.8": {
      "map": {
        "concat-map": "npm:concat-map@0.0.1",
        "balanced-match": "npm:balanced-match@1.0.0"
      }
    },
    "npm:color-convert@1.9.0": {
      "map": {
        "color-name": "npm:color-name@1.1.3"
      }
    },
    "npm:restore-cursor@2.0.0": {
      "map": {
        "onetime": "npm:onetime@2.0.1",
        "signal-exit": "npm:signal-exit@3.0.2"
      }
    },
    "npm:argparse@1.0.9": {
      "map": {
        "sprintf-js": "npm:sprintf-js@1.0.3"
      }
    },
    "npm:string_decoder@1.0.3": {
      "map": {
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:globby@5.0.0": {
      "map": {
        "glob": "npm:glob@7.1.2",
        "object-assign": "npm:object-assign@4.1.1",
        "pify": "npm:pify@2.3.0",
        "pinkie-promise": "npm:pinkie-promise@2.0.1",
        "array-union": "npm:array-union@1.0.2",
        "arrify": "npm:arrify@1.0.1"
      }
    },
    "npm:rimraf@2.6.2": {
      "map": {
        "glob": "npm:glob@7.1.2"
      }
    },
    "npm:is-path-in-cwd@1.0.0": {
      "map": {
        "is-path-inside": "npm:is-path-inside@1.0.0"
      }
    },
    "npm:onetime@2.0.1": {
      "map": {
        "mimic-fn": "npm:mimic-fn@1.1.0"
      }
    },
    "npm:pinkie-promise@2.0.1": {
      "map": {
        "pinkie": "npm:pinkie@2.0.4"
      }
    },
    "npm:tmp@0.0.33": {
      "map": {
        "os-tmpdir": "npm:os-tmpdir@1.0.2"
      }
    },
    "npm:is-path-inside@1.0.0": {
      "map": {
        "path-is-inside": "npm:path-is-inside@1.0.2"
      }
    },
    "npm:array-union@1.0.2": {
      "map": {
        "array-uniq": "npm:array-uniq@1.0.3"
      }
    },
    "npm:crypto-browserify@3.11.1": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "browserify-sign": "npm:browserify-sign@4.0.4",
        "diffie-hellman": "npm:diffie-hellman@5.0.2",
        "create-hash": "npm:create-hash@1.1.3",
        "randombytes": "npm:randombytes@2.0.5",
        "public-encrypt": "npm:public-encrypt@4.0.0",
        "create-ecdh": "npm:create-ecdh@4.0.0",
        "create-hmac": "npm:create-hmac@1.1.6",
        "pbkdf2": "npm:pbkdf2@3.0.14",
        "browserify-cipher": "npm:browserify-cipher@1.0.0"
      }
    },
    "npm:create-hash@1.1.3": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "ripemd160": "npm:ripemd160@2.0.1",
        "sha.js": "npm:sha.js@2.4.9",
        "cipher-base": "npm:cipher-base@1.0.4"
      }
    },
    "npm:randombytes@2.0.5": {
      "map": {
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:create-hmac@1.1.6": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1",
        "create-hash": "npm:create-hash@1.1.3",
        "ripemd160": "npm:ripemd160@2.0.1",
        "sha.js": "npm:sha.js@2.4.9",
        "cipher-base": "npm:cipher-base@1.0.4"
      }
    },
    "npm:pbkdf2@3.0.14": {
      "map": {
        "safe-buffer": "npm:safe-buffer@5.1.1",
        "create-hmac": "npm:create-hmac@1.1.6",
        "create-hash": "npm:create-hash@1.1.3",
        "ripemd160": "npm:ripemd160@2.0.1",
        "sha.js": "npm:sha.js@2.4.9"
      }
    },
    "npm:miller-rabin@4.0.1": {
      "map": {
        "bn.js": "npm:bn.js@4.11.8",
        "brorand": "npm:brorand@1.1.0"
      }
    },
    "npm:ripemd160@2.0.1": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "hash-base": "npm:hash-base@2.0.2"
      }
    },
    "npm:sha.js@2.4.9": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:cipher-base@1.0.4": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:evp_bytestokey@1.0.3": {
      "map": {
        "safe-buffer": "npm:safe-buffer@5.1.1",
        "md5.js": "npm:md5.js@1.3.4"
      }
    },
    "npm:hash.js@1.1.3": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
      }
    },
    "npm:md5.js@1.3.4": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "hash-base": "npm:hash-base@3.0.4"
      }
    },
    "npm:hash-base@2.0.2": {
      "map": {
        "inherits": "npm:inherits@2.0.3"
      }
    },
    "npm:hash-base@3.0.4": {
      "map": {
        "inherits": "npm:inherits@2.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1"
      }
    },
    "npm:brace@0.10.0": {
      "map": {
        "w3c-blob": "npm:w3c-blob@0.0.1"
      }
    },
    "npm:jspm-nodelibs-buffer@0.2.3": {
      "map": {
        "buffer": "npm:buffer@5.0.8"
      }
    },
    "npm:buffer@5.0.8": {
      "map": {
        "ieee754": "npm:ieee754@1.1.8",
        "base64-js": "npm:base64-js@1.2.1"
      }
    },
    "npm:browserify-aes@1.1.1": {
      "map": {
        "create-hash": "npm:create-hash@1.1.3",
        "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
        "cipher-base": "npm:cipher-base@1.0.4",
        "inherits": "npm:inherits@2.0.3",
        "safe-buffer": "npm:safe-buffer@5.1.1",
        "buffer-xor": "npm:buffer-xor@1.0.3"
      }
    },
    "npm:jspm-nodelibs-string_decoder@0.2.2": {
      "map": {
        "string_decoder": "npm:string_decoder@0.10.31"
      }
    },
    "npm:babel-preset-react@6.24.1": {
      "map": {
        "babel-plugin-transform-react-jsx-self": "npm:babel-plugin-transform-react-jsx-self@6.22.0",
        "babel-plugin-syntax-jsx": "npm:babel-plugin-syntax-jsx@6.18.0",
        "babel-preset-flow": "npm:babel-preset-flow@6.23.0",
        "babel-plugin-transform-react-jsx": "npm:babel-plugin-transform-react-jsx@6.24.1",
        "babel-plugin-transform-react-display-name": "npm:babel-plugin-transform-react-display-name@6.25.0",
        "babel-plugin-transform-react-jsx-source": "npm:babel-plugin-transform-react-jsx-source@6.22.0"
      }
    },
    "npm:babel-plugin-transform-react-jsx-self@6.22.0": {
      "map": {
        "babel-plugin-syntax-jsx": "npm:babel-plugin-syntax-jsx@6.18.0",
        "babel-runtime": "npm:babel-runtime@6.26.0"
      }
    },
    "npm:babel-plugin-transform-react-jsx@6.24.1": {
      "map": {
        "babel-plugin-syntax-jsx": "npm:babel-plugin-syntax-jsx@6.18.0",
        "babel-helper-builder-react-jsx": "npm:babel-helper-builder-react-jsx@6.26.0",
        "babel-runtime": "npm:babel-runtime@6.26.0"
      }
    },
    "npm:babel-plugin-transform-react-jsx-source@6.22.0": {
      "map": {
        "babel-plugin-syntax-jsx": "npm:babel-plugin-syntax-jsx@6.18.0",
        "babel-runtime": "npm:babel-runtime@6.26.0"
      }
    },
    "npm:babel-preset-flow@6.23.0": {
      "map": {
        "babel-plugin-transform-flow-strip-types": "npm:babel-plugin-transform-flow-strip-types@6.22.0"
      }
    },
    "npm:babel-plugin-transform-react-display-name@6.25.0": {
      "map": {
        "babel-runtime": "npm:babel-runtime@6.26.0"
      }
    },
    "npm:babel-plugin-transform-flow-strip-types@6.22.0": {
      "map": {
        "babel-runtime": "npm:babel-runtime@6.26.0",
        "babel-plugin-syntax-flow": "npm:babel-plugin-syntax-flow@6.18.0"
      }
    },
    "npm:babel-helper-builder-react-jsx@6.26.0": {
      "map": {
        "babel-runtime": "npm:babel-runtime@6.26.0",
        "esutils": "npm:esutils@2.0.2",
        "babel-types": "npm:babel-types@6.26.0"
      }
    },
    "npm:babel-runtime@6.26.0": {
      "map": {
        "regenerator-runtime": "npm:regenerator-runtime@0.11.1",
        "core-js": "npm:core-js@2.5.7"
      }
    },
    "npm:babel-types@6.26.0": {
      "map": {
        "esutils": "npm:esutils@2.0.2",
        "babel-runtime": "npm:babel-runtime@6.26.0",
        "to-fast-properties": "npm:to-fast-properties@1.0.3",
        "lodash": "npm:lodash@4.17.10"
      }
    }
  }
});


/***/ }),

/***/ "./jspm_config_backend.js":
/*!********************************!*\
  !*** ./jspm_config_backend.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

SystemJS.config({
map: {
  "libs_common/content_script_utils": "libs_backend/content_script_utils",
  "libs_common/require_remote_utils": "libs_backend/require_remote_utils",
  "libs_backend/expose_backend_libs": "generated_libs/libs_backend/expose_backend_libs",
  "libs_common/ajax_utils": "libs_backend/ajax_utils",
  "libs_frontend/ajax_utils": "generated_libs/libs_frontend/ajax_utils",
  "libs_common/cacheget_utils": "libs_backend/cacheget_utils",
  "libs_frontend/cacheget_utils": "generated_libs/libs_frontend/cacheget_utils",
  "libs_common/db_utils": "libs_backend/db_utils",
  "libs_frontend/db_utils": "generated_libs/libs_frontend/db_utils",
  "libs_common/debug_console_utils": "libs_backend/debug_console_utils",
  "libs_frontend/debug_console_utils": "generated_libs/libs_frontend/debug_console_utils",
  "libs_common/disable_habitlab_utils": "libs_backend/disable_habitlab_utils",
  "libs_frontend/disable_habitlab_utils": "generated_libs/libs_frontend/disable_habitlab_utils",
  "libs_common/duolingo_utils": "libs_backend/duolingo_utils",
  "libs_frontend/duolingo_utils": "generated_libs/libs_frontend/duolingo_utils",
  "libs_common/favicon_utils": "libs_backend/favicon_utils",
  "libs_frontend/favicon_utils": "generated_libs/libs_frontend/favicon_utils",
  "libs_common/fetch_page_utils": "libs_backend/fetch_page_utils",
  "libs_frontend/fetch_page_utils": "generated_libs/libs_frontend/fetch_page_utils",
  "libs_common/gamification_utils": "libs_backend/gamification_utils",
  "libs_frontend/gamification_utils": "generated_libs/libs_frontend/gamification_utils",
  "libs_common/goal_progress": "libs_backend/goal_progress",
  "libs_frontend/goal_progress": "generated_libs/libs_frontend/goal_progress",
  "libs_common/goal_utils": "libs_backend/goal_utils",
  "libs_frontend/goal_utils": "generated_libs/libs_frontend/goal_utils",
  "libs_common/goal_vars_backend": "libs_backend/goal_vars_backend",
  "libs_frontend/goal_vars_backend": "generated_libs/libs_frontend/goal_vars_backend",
  "libs_common/history_utils": "libs_backend/history_utils",
  "libs_frontend/history_utils": "generated_libs/libs_frontend/history_utils",
  "libs_common/intervention_feedback_utils": "libs_backend/intervention_feedback_utils",
  "libs_frontend/intervention_feedback_utils": "generated_libs/libs_frontend/intervention_feedback_utils",
  "libs_common/intervention_first_impression_utils_backend": "libs_backend/intervention_first_impression_utils_backend",
  "libs_frontend/intervention_first_impression_utils_backend": "generated_libs/libs_frontend/intervention_first_impression_utils_backend",
  "libs_common/intervention_session_vars_backend": "libs_backend/intervention_session_vars_backend",
  "libs_frontend/intervention_session_vars_backend": "generated_libs/libs_frontend/intervention_session_vars_backend",
  "libs_common/intervention_utils": "libs_backend/intervention_utils",
  "libs_frontend/intervention_utils": "generated_libs/libs_frontend/intervention_utils",
  "libs_common/intervention_vars_backend": "libs_backend/intervention_vars_backend",
  "libs_frontend/intervention_vars_backend": "generated_libs/libs_frontend/intervention_vars_backend",
  "libs_common/localization_utils_backend": "libs_backend/localization_utils_backend",
  "libs_frontend/localization_utils_backend": "generated_libs/libs_frontend/localization_utils_backend",
  "libs_common/log_utils": "libs_backend/log_utils",
  "libs_frontend/log_utils": "generated_libs/libs_frontend/log_utils",
  "libs_common/notification_utils_backend": "libs_backend/notification_utils_backend",
  "libs_frontend/notification_utils_backend": "generated_libs/libs_frontend/notification_utils_backend",
  "libs_common/persistent_storage_utils": "libs_backend/persistent_storage_utils",
  "libs_frontend/persistent_storage_utils": "generated_libs/libs_frontend/persistent_storage_utils",
  "libs_common/screenshot_utils": "libs_backend/screenshot_utils",
  "libs_frontend/screenshot_utils": "generated_libs/libs_frontend/screenshot_utils",
  "libs_common/session_utils": "libs_backend/session_utils",
  "libs_frontend/session_utils": "generated_libs/libs_frontend/session_utils",
  "libs_common/streak_utils": "libs_backend/streak_utils",
  "libs_frontend/streak_utils": "generated_libs/libs_frontend/streak_utils",
  "libs_common/tab_utils": "libs_backend/tab_utils",
  "libs_frontend/tab_utils": "generated_libs/libs_frontend/tab_utils",
  "jquery-contextmenu": "modules_custom/jquery-contextmenu/dist/jquery.contextMenu.js",
  "jquery-inview": "modules_custom/jquery-inview/jquery.inview.js",
  "jquery.isinview": "modules_custom/jquery.isinview/dist/jquery.isinview.js",
  "jquery.pagepiling": "modules_custom/jquery.pagepiling/jquery.pagepiling.js",
  "jquery.terminal": "modules_custom/jquery.terminal/js/jquery.terminal-0.10.12.js"
}
});

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/dexie/dist/dexie.js":
/*!******************************************!*\
  !*** ./node_modules/dexie/dist/dexie.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {(function (global, factory) {
    true ? module.exports = factory() :
   undefined;
}(this, (function () { 'use strict';

/*
* Dexie.js - a minimalistic wrapper for IndexedDB
* ===============================================
*
* By David Fahlander, david.fahlander@gmail.com
*
* Version 1.5.1, Tue Nov 01 2016
* www.dexie.com
* Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
*/
var keys = Object.keys;
var isArray = Array.isArray;
var _global = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;

function extend(obj, extension) {
    if (typeof extension !== 'object') return obj;
    keys(extension).forEach(function (key) {
        obj[key] = extension[key];
    });
    return obj;
}

var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
    return _hasOwn.call(obj, prop);
}

function props(proto, extension) {
    if (typeof extension === 'function') extension = extension(getProto(proto));
    keys(extension).forEach(function (key) {
        setProp(proto, key, extension[key]);
    });
}

function setProp(obj, prop, functionOrGetSet, options) {
    Object.defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}

function derive(Child) {
    return {
        from: function (Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
                extend: props.bind(null, Child.prototype)
            };
        }
    };
}

var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

function getPropertyDescriptor(obj, prop) {
    var pd = getOwnPropertyDescriptor(obj, prop),
        proto;
    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}

var _slice = [].slice;
function slice(args, start, end) {
    return _slice.call(args, start, end);
}

function override(origFunc, overridedFactory) {
    return overridedFactory(origFunc);
}

function doFakeAutoComplete(fn) {
    var to = setTimeout(fn, 1000);
    clearTimeout(to);
}

function assert(b) {
    if (!b) throw new Error("Assertion Failed");
}

function asap(fn) {
    if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);
}



/** Generate an object (hash map) based on given array.
 * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to
 *        instert on the resulting object for each item in the array. If this function returns a falsy value, the
 *        current item wont affect the resulting object.
 */
function arrayToObject(array, extractor) {
    return array.reduce(function (result, item, i) {
        var nameAndValue = extractor(item, i);
        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
        return result;
    }, {});
}

function trycatcher(fn, reject) {
    return function () {
        try {
            fn.apply(this, arguments);
        } catch (e) {
            reject(e);
        }
    };
}

function tryCatch(fn, onerror, args) {
    try {
        fn.apply(null, args);
    } catch (ex) {
        onerror && onerror(ex);
    }
}

function getByKeyPath(obj, keyPath) {
    // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path
    if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.
    if (!keyPath) return obj;
    if (typeof keyPath !== 'string') {
        var rv = [];
        for (var i = 0, l = keyPath.length; i < l; ++i) {
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
        }
        return rv;
    }
    var period = keyPath.indexOf('.');
    if (period !== -1) {
        var innerObj = obj[keyPath.substr(0, period)];
        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
    }
    return undefined;
}

function setByKeyPath(obj, keyPath, value) {
    if (!obj || keyPath === undefined) return;
    if ('isFrozen' in Object && Object.isFrozen(obj)) return;
    if (typeof keyPath !== 'string' && 'length' in keyPath) {
        assert(typeof value !== 'string' && 'length' in value);
        for (var i = 0, l = keyPath.length; i < l; ++i) {
            setByKeyPath(obj, keyPath[i], value[i]);
        }
    } else {
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "") {
                if (value === undefined) delete obj[currentKeyPath];else obj[currentKeyPath] = value;
            } else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj) innerObj = obj[currentKeyPath] = {};
                setByKeyPath(innerObj, remainingKeyPath, value);
            }
        } else {
            if (value === undefined) delete obj[keyPath];else obj[keyPath] = value;
        }
    }
}

function delByKeyPath(obj, keyPath) {
    if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {
        setByKeyPath(obj, kp, undefined);
    });
}

function shallowClone(obj) {
    var rv = {};
    for (var m in obj) {
        if (hasOwn(obj, m)) rv[m] = obj[m];
    }
    return rv;
}

function deepClone(any) {
    if (!any || typeof any !== 'object') return any;
    var rv;
    if (isArray(any)) {
        rv = [];
        for (var i = 0, l = any.length; i < l; ++i) {
            rv.push(deepClone(any[i]));
        }
    } else if (any instanceof Date) {
        rv = new Date();
        rv.setTime(any.getTime());
    } else {
        rv = any.constructor ? Object.create(any.constructor.prototype) : {};
        for (var prop in any) {
            if (hasOwn(any, prop)) {
                rv[prop] = deepClone(any[prop]);
            }
        }
    }
    return rv;
}

function getObjectDiff(a, b, rv, prfx) {
    // Compares objects a and b and produces a diff object.
    rv = rv || {};
    prfx = prfx || '';
    keys(a).forEach(function (prop) {
        if (!hasOwn(b, prop)) rv[prfx + prop] = undefined; // Property removed
        else {
                var ap = a[prop],
                    bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp && ap.constructor === bp.constructor)
                    // Same type of object but its properties may have changed
                    getObjectDiff(ap, bp, rv, prfx + prop + ".");else if (ap !== bp) rv[prfx + prop] = b[prop]; // Primitive value changed
            }
    });
    keys(b).forEach(function (prop) {
        if (!hasOwn(a, prop)) {
            rv[prfx + prop] = b[prop]; // Property added
        }
    });
    return rv;
}

// If first argument is iterable or array-like, return it as an array
var iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;
var getIteratorOf = iteratorSymbol ? function (x) {
    var i;
    return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function () {
    return null;
};

var NO_CHAR_ARRAY = {};
// Takes one or several arguments and returns an array based on the following criteras:
// * If several arguments provided, return arguments converted to an array in a way that
//   still allows javascript engine to optimize the code.
// * If single argument is an array, return a clone of it.
// * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special
//   case to the two bullets below.
// * If single argument is an iterable, convert it to an array and return the resulting array.
// * If single argument is array-like (has length of type number), convert it to an array.
function getArrayOf(arrayLike) {
    var i, a, x, it;
    if (arguments.length === 1) {
        if (isArray(arrayLike)) return arrayLike.slice();
        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];
        if (it = getIteratorOf(arrayLike)) {
            a = [];
            while (x = it.next(), !x.done) {
                a.push(x.value);
            }return a;
        }
        if (arrayLike == null) return [arrayLike];
        i = arrayLike.length;
        if (typeof i === 'number') {
            a = new Array(i);
            while (i--) {
                a[i] = arrayLike[i];
            }return a;
        }
        return [arrayLike];
    }
    i = arguments.length;
    a = new Array(i);
    while (i--) {
        a[i] = arguments[i];
    }return a;
}

var concat = [].concat;
function flatten(a) {
    return concat.apply([], a);
}

function nop() {}
function mirror(val) {
    return val;
}
function pureFunctionChain(f1, f2) {
    // Enables chained events that takes ONE argument and returns it to the next function in chain.
    // This pattern is used in the hook("reading") event.
    if (f1 == null || f1 === mirror) return f2;
    return function (val) {
        return f2(f1(val));
    };
}

function callBoth(on1, on2) {
    return function () {
        on1.apply(this, arguments);
        on2.apply(this, arguments);
    };
}

function hookCreatingChain(f1, f2) {
    // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.
    // This pattern is used in the hook("creating") event.
    if (f1 === nop) return f2;
    return function () {
        var res = f1.apply(this, arguments);
        if (res !== undefined) arguments[0] = res;
        var onsuccess = this.onsuccess,
            // In case event listener has set this.onsuccess
        onerror = this.onerror; // In case event listener has set this.onerror
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res2 !== undefined ? res2 : res;
    };
}

function hookDeletingChain(f1, f2) {
    if (f1 === nop) return f2;
    return function () {
        f1.apply(this, arguments);
        var onsuccess = this.onsuccess,
            // In case event listener has set this.onsuccess
        onerror = this.onerror; // In case event listener has set this.onerror
        this.onsuccess = this.onerror = null;
        f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    };
}

function hookUpdatingChain(f1, f2) {
    if (f1 === nop) return f2;
    return function (modifications) {
        var res = f1.apply(this, arguments);
        extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.
        var onsuccess = this.onsuccess,
            // In case event listener has set this.onsuccess
        onerror = this.onerror; // In case event listener has set this.onerror
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
    };
}

function reverseStoppableEventChain(f1, f2) {
    if (f1 === nop) return f2;
    return function () {
        if (f2.apply(this, arguments) === false) return false;
        return f1.apply(this, arguments);
    };
}



function promisableChain(f1, f2) {
    if (f1 === nop) return f2;
    return function () {
        var res = f1.apply(this, arguments);
        if (res && typeof res.then === 'function') {
            var thiz = this,
                i = arguments.length,
                args = new Array(i);
            while (i--) {
                args[i] = arguments[i];
            }return res.then(function () {
                return f2.apply(thiz, args);
            });
        }
        return f2.apply(this, arguments);
    };
}

// By default, debug will be true only if platform is a web platform and its page is served from localhost.
// When debug = true, error's stacks will contain asyncronic long stacks.
var debug = typeof location !== 'undefined' &&
// By default, use debug mode if served from localhost.
/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

function setDebug(value, filter) {
    debug = value;
    libraryFilter = filter;
}

var libraryFilter = function () {
    return true;
};

var NEEDS_THROW_FOR_STACK = !new Error("").stack;

function getErrorWithStack() {
    "use strict";

    if (NEEDS_THROW_FOR_STACK) try {
        // Doing something naughty in strict mode here to trigger a specific error
        // that can be explicitely ignored in debugger's exception settings.
        // If we'd just throw new Error() here, IE's debugger's exception settings
        // will just consider it as "exception thrown by javascript code" which is
        // something you wouldn't want it to ignore.
        getErrorWithStack.arguments;
        throw new Error(); // Fallback if above line don't throw.
    } catch (e) {
        return e;
    }
    return new Error();
}

function prettyStack(exception, numIgnoredFrames) {
    var stack = exception.stack;
    if (!stack) return "";
    numIgnoredFrames = numIgnoredFrames || 0;
    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\n').length;
    return stack.split('\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {
        return "\n" + frame;
    }).join('');
}

function deprecated(what, fn) {
    return function () {
        console.warn(what + " is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. " + prettyStack(getErrorWithStack(), 1));
        return fn.apply(this, arguments);
    };
}

var dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'IncompatiblePromise'];

var idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];

var errorList = dexieErrorNames.concat(idbDomErrorNames);

var defaultTexts = {
    VersionChanged: "Database version changed by other database connection",
    DatabaseClosed: "Database has been closed",
    Abort: "Transaction aborted",
    TransactionInactive: "Transaction has already completed or failed"
};

//
// DexieError - base class of all out exceptions.
//
function DexieError(name, msg) {
    // Reason we don't use ES6 classes is because:
    // 1. It bloats transpiled code and increases size of minified code.
    // 2. It doesn't give us much in this case.
    // 3. It would require sub classes to call super(), which
    //    is not needed when deriving from Error.
    this._e = getErrorWithStack();
    this.name = name;
    this.message = msg;
}

derive(DexieError).from(Error).extend({
    stack: {
        get: function () {
            return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
        }
    },
    toString: function () {
        return this.name + ": " + this.message;
    }
});

function getMultiErrorMessage(msg, failures) {
    return msg + ". Errors: " + failures.map(function (f) {
        return f.toString();
    }).filter(function (v, i, s) {
        return s.indexOf(v) === i;
    }) // Only unique error strings
    .join('\n');
}

//
// ModifyError - thrown in WriteableCollection.modify()
// Specific constructor because it contains members failures and failedKeys.
//
function ModifyError(msg, failures, successCount, failedKeys) {
    this._e = getErrorWithStack();
    this.failures = failures;
    this.failedKeys = failedKeys;
    this.successCount = successCount;
}
derive(ModifyError).from(DexieError);

function BulkError(msg, failures) {
    this._e = getErrorWithStack();
    this.name = "BulkError";
    this.failures = failures;
    this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);

//
//
// Dynamically generate error names and exception classes based
// on the names in errorList.
//
//

// Map of {ErrorName -> ErrorName + "Error"}
var errnames = errorList.reduce(function (obj, name) {
    return obj[name] = name + "Error", obj;
}, {});

// Need an alias for DexieError because we're gonna create subclasses with the same name.
var BaseException = DexieError;
// Map of {ErrorName -> exception constructor}
var exceptions = errorList.reduce(function (obj, name) {
    // Let the name be "DexieError" because this name may
    // be shown in call stack and when debugging. DexieError is
    // the most true name because it derives from DexieError,
    // and we cannot change Function.name programatically without
    // dynamically create a Function object, which would be considered
    // 'eval-evil'.
    var fullName = name + "Error";
    function DexieError(msgOrInner, inner) {
        this._e = getErrorWithStack();
        this.name = fullName;
        if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
        } else if (typeof msgOrInner === 'string') {
            this.message = msgOrInner;
            this.inner = inner || null;
        } else if (typeof msgOrInner === 'object') {
            this.message = msgOrInner.name + ' ' + msgOrInner.message;
            this.inner = msgOrInner;
        }
    }
    derive(DexieError).from(BaseException);
    obj[name] = DexieError;
    return obj;
}, {});

// Use ECMASCRIPT standard exceptions where applicable:
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;

var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
    obj[name + "Error"] = exceptions[name];
    return obj;
}, {});

function mapError(domError, message) {
    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
    var rv = new exceptionMap[domError.name](message || domError.message, domError);
    if ("stack" in domError) {
        // Derive stack from inner exception if it has a stack
        setProp(rv, "stack", { get: function () {
                return this.inner.stack;
            } });
    }
    return rv;
}

var fullNameExceptions = errorList.reduce(function (obj, name) {
    if (["Syntax", "Type", "Range"].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
    return obj;
}, {});

fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;

function Events(ctx) {
    var evs = {};
    var rv = function (eventName, subscriber) {
        if (subscriber) {
            // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.
            var i = arguments.length,
                args = new Array(i - 1);
            while (--i) {
                args[i - 1] = arguments[i];
            }evs[eventName].subscribe.apply(null, args);
            return ctx;
        } else if (typeof eventName === 'string') {
            // Return interface allowing to fire or unsubscribe from event
            return evs[eventName];
        }
    };
    rv.addEventType = add;

    for (var i = 1, l = arguments.length; i < l; ++i) {
        add(arguments[i]);
    }

    return rv;

    function add(eventName, chainFunction, defaultFunction) {
        if (typeof eventName === 'object') return addConfiguredEvents(eventName);
        if (!chainFunction) chainFunction = reverseStoppableEventChain;
        if (!defaultFunction) defaultFunction = nop;

        var context = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: function (cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                    context.subscribers.push(cb);
                    context.fire = chainFunction(context.fire, cb);
                }
            },
            unsubscribe: function (cb) {
                context.subscribers = context.subscribers.filter(function (fn) {
                    return fn !== cb;
                });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
            }
        };
        evs[eventName] = rv[eventName] = context;
        return context;
    }

    function addConfiguredEvents(cfg) {
        // events(this, {reading: [functionChain, nop]});
        keys(cfg).forEach(function (eventName) {
            var args = cfg[eventName];
            if (isArray(args)) {
                add(eventName, cfg[eventName][0], cfg[eventName][1]);
            } else if (args === 'asap') {
                // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack
                // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.
                var context = add(eventName, mirror, function fire() {
                    // Optimazation-safe cloning of arguments into args.
                    var i = arguments.length,
                        args = new Array(i);
                    while (i--) {
                        args[i] = arguments[i];
                    } // All each subscriber:
                    context.subscribers.forEach(function (fn) {
                        asap(function fireEvent() {
                            fn.apply(null, args);
                        });
                    });
                });
            } else throw new exceptions.InvalidArgument("Invalid event config");
        });
    }
}

//
// Promise Class for Dexie library
//
// I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by
// https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.
//
// Modifications needed to be done to support indexedDB because it wont accept setTimeout()
// (See discussion: https://github.com/promises-aplus/promises-spec/issues/45) .
// This topic was also discussed in the following thread: https://github.com/promises-aplus/promises-spec/issues/45
//
// This implementation will not use setTimeout or setImmediate when it's not needed. The behavior is 100% Promise/A+ compliant since
// the caller of new Promise() can be certain that the promise wont be triggered the lines after constructing the promise.
//
// In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another
// tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use
// another strategy now that simplifies everything a lot: to always execute callbacks in a new tick, but have an own microTick
// engine that is used instead of setImmediate() or setTimeout().
// Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.
// Also with inspiration from bluebird, asyncronic stacks in debug mode.
//
// Specific non-standard features of this Promise class:
// * Async static context support (Promise.PSD)
// * Promise.follow() method built upon PSD, that allows user to track all promises created from current stack frame
//   and below + all promises that those promises creates or awaits.
// * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). 
//
// David Fahlander, https://github.com/dfahlander
//

// Just a pointer that only this module knows about.
// Used in Promise constructor to emulate a private constructor.
var INTERNAL = {};

// Async stacks (long stacks) must not grow infinitely.
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var stack_being_generated = false;

/* The default "nextTick" function used only for the very first promise in a promise chain.
   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks
   emulated in this module. For indexedDB compatibility, this means that every method needs to 
   execute at least one promise before doing an indexedDB operation. Dexie will always call 
   db.ready().then() for every operation to make sure the indexedDB event is started in an
   emulated micro tick.
*/
var schedulePhysicalTick = _global.setImmediate ?
// setImmediate supported. Those modern platforms also supports Function.bind().
setImmediate.bind(null, physicalTick) : _global.MutationObserver ?
// MutationObserver supported
function () {
    var hiddenDiv = document.createElement("div");
    new MutationObserver(function () {
        physicalTick();
        hiddenDiv = null;
    }).observe(hiddenDiv, { attributes: true });
    hiddenDiv.setAttribute('i', '1');
} :
// No support for setImmediate or MutationObserver. No worry, setTimeout is only called
// once time. Every tick that follows will be our emulated micro tick.
// Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug 
function () {
    setTimeout(physicalTick, 0);
};

// Confifurable through Promise.scheduler.
// Don't export because it would be unsafe to let unknown
// code call it unless they do try..catch within their callback.
// This function can be retrieved through getter of Promise.scheduler though,
// but users must not do Promise.scheduler (myFuncThatThrows exception)!
var asap$1 = function (callback, args) {
    microtickQueue.push([callback, args]);
    if (needsNewPhysicalTick) {
        schedulePhysicalTick();
        needsNewPhysicalTick = false;
    }
};

var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions

var globalPSD = {
    global: true,
    ref: 0,
    unhandleds: [],
    onunhandled: globalError,
    //env: null, // Will be set whenever leaving a scope using wrappers.snapshot()
    finalize: function () {
        this.unhandleds.forEach(function (uh) {
            try {
                globalError(uh[0], uh[1]);
            } catch (e) {}
        });
    }
};

var PSD = globalPSD;

var microtickQueue = []; // Callbacks to call in this or next physical tick.
var numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.
var tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.

// Wrappers are not being used yet. Their framework is functioning and can be used
// to replace environment during a PSD scope (a.k.a. 'zone').
/* **KEEP** export var wrappers = (() => {
    var wrappers = [];

    return {
        snapshot: () => {
            var i = wrappers.length,
                result = new Array(i);
            while (i--) result[i] = wrappers[i].snapshot();
            return result;
        },
        restore: values => {
            var i = wrappers.length;
            while (i--) wrappers[i].restore(values[i]);
        },
        wrap: () => wrappers.map(w => w.wrap()),
        add: wrapper => {
            wrappers.push(wrapper);
        }
    };
})();
*/

function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    this._listeners = [];
    this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.

    // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()
    // execute the microtask engine implicitely within the call to resolve() or reject().
    // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack
    // only contains library code when calling resolve() or reject().
    // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from
    // global scope (event handler, timer etc)!
    this._lib = false;
    // Current async scope
    var psd = this._PSD = PSD;

    if (debug) {
        this._stackHolder = getErrorWithStack();
        this._prev = null;
        this._numPrev = 0; // Number of previous promises (for long stacks)
        linkToPreviousPromise(this, currentFulfiller);
    }

    if (typeof fn !== 'function') {
        if (fn !== INTERNAL) throw new TypeError('Not a function');
        // Private constructor (INTERNAL, state, value).
        // Used internally by Promise.resolve() and Promise.reject().
        this._state = arguments[1];
        this._value = arguments[2];
        if (this._state === false) handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().
        return;
    }

    this._state = null; // null (=pending), false (=rejected) or true (=resolved)
    this._value = null; // error or result
    ++psd.ref; // Refcounting current scope
    executePromiseTask(this, fn);
}

props(Promise.prototype, {

    then: function (onFulfilled, onRejected) {
        var _this = this;

        var rv = new Promise(function (resolve, reject) {
            propagateToListener(_this, new Listener(onFulfilled, onRejected, resolve, reject));
        });
        debug && (!this._prev || this._state === null) && linkToPreviousPromise(rv, this);
        return rv;
    },

    _then: function (onFulfilled, onRejected) {
        // A little tinier version of then() that don't have to create a resulting promise.
        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected));
    },

    catch: function (onRejected) {
        if (arguments.length === 1) return this.then(null, onRejected);
        // First argument is the Error type to catch
        var type = arguments[0],
            handler = arguments[1];
        return typeof type === 'function' ? this.then(null, function (err) {
            return (
                // Catching errors by its constructor type (similar to java / c++ / c#)
                // Sample: promise.catch(TypeError, function (e) { ... });
                err instanceof type ? handler(err) : PromiseReject(err)
            );
        }) : this.then(null, function (err) {
            return (
                // Catching errors by the error.name property. Makes sense for indexedDB where error type
                // is always DOMError but where e.name tells the actual error type.
                // Sample: promise.catch('ConstraintError', function (e) { ... });
                err && err.name === type ? handler(err) : PromiseReject(err)
            );
        });
    },

    finally: function (onFinally) {
        return this.then(function (value) {
            onFinally();
            return value;
        }, function (err) {
            onFinally();
            return PromiseReject(err);
        });
    },

    // Deprecate in next major. Needed only for db.on.error.
    uncaught: function (uncaughtHandler) {
        var _this2 = this;

        // Be backward compatible and use "onuncatched" as the event name on this.
        // Handle multiple subscribers through reverseStoppableEventChain(). If a handler returns `false`, bubbling stops.
        this.onuncatched = reverseStoppableEventChain(this.onuncatched, uncaughtHandler);
        // In case caller does this on an already rejected promise, assume caller wants to point out the error to this promise and not
        // a previous promise. Reason: the prevous promise may lack onuncatched handler. 
        if (this._state === false && unhandledErrors.indexOf(this) === -1) {
            // Replace unhandled error's destinaion promise with this one!
            unhandledErrors.some(function (p, i, l) {
                return p._value === _this2._value && (l[i] = _this2);
            });
            // Actually we do this shit because we need to support db.on.error() correctly during db.open(). If we deprecate db.on.error, we could
            // take away this piece of code as well as the onuncatched and uncaught() method.
        }
        return this;
    },

    stack: {
        get: function () {
            if (this._stack) return this._stack;
            try {
                stack_being_generated = true;
                var stacks = getStack(this, [], MAX_LONG_STACKS);
                var stack = stacks.join("\nFrom previous: ");
                if (this._state !== null) this._stack = stack; // Stack may be updated on reject.
                return stack;
            } finally {
                stack_being_generated = false;
            }
        }
    }
});

function Listener(onFulfilled, onRejected, resolve, reject) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.resolve = resolve;
    this.reject = reject;
    this.psd = PSD;
}

// Promise Static Properties
props(Promise, {
    all: function () {
        var values = getArrayOf.apply(null, arguments); // Supports iterables, implicit arguments and array-like.
        return new Promise(function (resolve, reject) {
            if (values.length === 0) resolve([]);
            var remaining = values.length;
            values.forEach(function (a, i) {
                return Promise.resolve(a).then(function (x) {
                    values[i] = x;
                    if (! --remaining) resolve(values);
                }, reject);
            });
        });
    },

    resolve: function (value) {
        if (value instanceof Promise) return value;
        if (value && typeof value.then === 'function') return new Promise(function (resolve, reject) {
            value.then(resolve, reject);
        });
        return new Promise(INTERNAL, true, value);
    },

    reject: PromiseReject,

    race: function () {
        var values = getArrayOf.apply(null, arguments);
        return new Promise(function (resolve, reject) {
            values.map(function (value) {
                return Promise.resolve(value).then(resolve, reject);
            });
        });
    },

    PSD: {
        get: function () {
            return PSD;
        },
        set: function (value) {
            return PSD = value;
        }
    },

    newPSD: newScope,

    usePSD: usePSD,

    scheduler: {
        get: function () {
            return asap$1;
        },
        set: function (value) {
            asap$1 = value;
        }
    },

    rejectionMapper: {
        get: function () {
            return rejectionMapper;
        },
        set: function (value) {
            rejectionMapper = value;
        } // Map reject failures
    },

    follow: function (fn) {
        return new Promise(function (resolve, reject) {
            return newScope(function (resolve, reject) {
                var psd = PSD;
                psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()
                psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.
                psd.finalize = callBoth(function () {
                    var _this3 = this;

                    // Unhandled standard or 3rd part promises are put in PSD.unhandleds and
                    // examined upon scope completion while unhandled rejections in this Promise
                    // will trigger directly through psd.onunhandled
                    run_at_end_of_this_or_next_physical_tick(function () {
                        _this3.unhandleds.length === 0 ? resolve() : reject(_this3.unhandleds[0]);
                    });
                }, psd.finalize);
                fn();
            }, resolve, reject);
        });
    },

    on: Events(null, { "error": [reverseStoppableEventChain, defaultErrorHandler] // Default to defaultErrorHandler
    })

});

var PromiseOnError = Promise.on.error;
PromiseOnError.subscribe = deprecated("Promise.on('error')", PromiseOnError.subscribe);
PromiseOnError.unsubscribe = deprecated("Promise.on('error').unsubscribe", PromiseOnError.unsubscribe);

/**
* Take a potentially misbehaving resolver function and make sure
* onFulfilled and onRejected are only called once.
*
* Makes no guarantees about asynchrony.
*/
function executePromiseTask(promise, fn) {
    // Promise Resolution Procedure:
    // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    try {
        fn(function (value) {
            if (promise._state !== null) return;
            if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === 'function') {
                executePromiseTask(promise, function (resolve, reject) {
                    value instanceof Promise ? value._then(resolve, reject) : value.then(resolve, reject);
                });
            } else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
            }
            if (shouldExecuteTick) endMicroTickScope();
        }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below
    } catch (ex) {
        handleRejection(promise, ex);
    }
}

function handleRejection(promise, reason) {
    rejectingErrors.push(reason);
    if (promise._state !== null) return;
    var shouldExecuteTick = promise._lib && beginMicroTickScope();
    reason = rejectionMapper(reason);
    promise._state = false;
    promise._value = reason;
    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {
        var origProp = getPropertyDescriptor(reason, "stack");
        reason._promise = promise;
        setProp(reason, "stack", {
            get: function () {
                return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
            }
        });
    });
    // Add the failure to a list of possibly uncaught errors
    addPossiblyUnhandledError(promise);
    propagateAllListeners(promise);
    if (shouldExecuteTick) endMicroTickScope();
}

function propagateAllListeners(promise) {
    //debug && linkToPreviousPromise(promise);
    var listeners = promise._listeners;
    promise._listeners = [];
    for (var i = 0, len = listeners.length; i < len; ++i) {
        propagateToListener(promise, listeners[i]);
    }
    var psd = promise._PSD;
    --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();
    if (numScheduledCalls === 0) {
        // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,
        // and that no deferreds where listening to this rejection or success.
        // Since there is a risk that our stack can contain application code that may
        // do stuff after this code is finished that may generate new calls, we cannot
        // call finalizers here.
        ++numScheduledCalls;
        asap$1(function () {
            if (--numScheduledCalls === 0) finalizePhysicalTick(); // Will detect unhandled errors
        }, []);
    }
}

function propagateToListener(promise, listener) {
    if (promise._state === null) {
        promise._listeners.push(listener);
        return;
    }

    var cb = promise._state ? listener.onFulfilled : listener.onRejected;
    if (cb === null) {
        // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()
        return (promise._state ? listener.resolve : listener.reject)(promise._value);
    }
    var psd = listener.psd;
    ++psd.ref;
    ++numScheduledCalls;
    asap$1(callListener, [cb, promise, listener]);
}

function callListener(cb, promise, listener) {
    var outerScope = PSD;
    var psd = listener.psd;
    try {
        if (psd !== outerScope) {
            // **KEEP** outerScope.env = wrappers.snapshot(); // Snapshot outerScope's environment.
            PSD = psd;
            // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.
        }

        // Set static variable currentFulfiller to the promise that is being fullfilled,
        // so that we connect the chain of promises (for long stacks support)
        currentFulfiller = promise;

        // Call callback and resolve our listener with it's return value.
        var value = promise._value,
            ret;
        if (promise._state) {
            ret = cb(value);
        } else {
            if (rejectingErrors.length) rejectingErrors = [];
            ret = cb(value);
            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.
        }
        listener.resolve(ret);
    } catch (e) {
        // Exception thrown in callback. Reject our listener.
        listener.reject(e);
    } finally {
        // Restore PSD, env and currentFulfiller.
        if (psd !== outerScope) {
            PSD = outerScope;
            // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment
        }
        currentFulfiller = null;
        if (--numScheduledCalls === 0) finalizePhysicalTick();
        --psd.ref || psd.finalize();
    }
}

function getStack(promise, stacks, limit) {
    if (stacks.length === limit) return stacks;
    var stack = "";
    if (promise._state === false) {
        var failure = promise._value,
            errorName,
            message;

        if (failure != null) {
            errorName = failure.name || "Error";
            message = failure.message || failure;
            stack = prettyStack(failure, 0);
        } else {
            errorName = failure; // If error is undefined or null, show that.
            message = "";
        }
        stacks.push(errorName + (message ? ": " + message : "") + stack);
    }
    if (debug) {
        stack = prettyStack(promise._stackHolder, 2);
        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
        if (promise._prev) getStack(promise._prev, stacks, limit);
    }
    return stacks;
}

function linkToPreviousPromise(promise, prev) {
    // Support long stacks by linking to previous completed promise.
    var numPrev = prev ? prev._numPrev + 1 : 0;
    if (numPrev < LONG_STACKS_CLIP_LIMIT) {
        // Prohibit infinite Promise loops to get an infinite long memory consuming "tail".
        promise._prev = prev;
        promise._numPrev = numPrev;
    }
}

/* The callback to schedule with setImmediate() or setTimeout().
   It runs a virtual microtick and executes any callback registered in microtickQueue.
 */
function physicalTick() {
    beginMicroTickScope() && endMicroTickScope();
}

function beginMicroTickScope() {
    var wasRootExec = isOutsideMicroTick;
    isOutsideMicroTick = false;
    needsNewPhysicalTick = false;
    return wasRootExec;
}

/* Executes micro-ticks without doing try..catch.
   This can be possible because we only use this internally and
   the registered functions are exception-safe (they do try..catch
   internally before calling any external method). If registering
   functions in the microtickQueue that are not exception-safe, this
   would destroy the framework and make it instable. So we don't export
   our asap method.
*/
function endMicroTickScope() {
    var callbacks, i, l;
    do {
        while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i = 0; i < l; ++i) {
                var item = callbacks[i];
                item[0].apply(null, item[1]);
            }
        }
    } while (microtickQueue.length > 0);
    isOutsideMicroTick = true;
    needsNewPhysicalTick = true;
}

function finalizePhysicalTick() {
    var unhandledErrs = unhandledErrors;
    unhandledErrors = [];
    unhandledErrs.forEach(function (p) {
        p._PSD.onunhandled.call(null, p._value, p);
    });
    var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.
    var i = finalizers.length;
    while (i) {
        finalizers[--i]();
    }
}

function run_at_end_of_this_or_next_physical_tick(fn) {
    function finalizer() {
        fn();
        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
    }
    tickFinalizers.push(finalizer);
    ++numScheduledCalls;
    asap$1(function () {
        if (--numScheduledCalls === 0) finalizePhysicalTick();
    }, []);
}

function addPossiblyUnhandledError(promise) {
    // Only add to unhandledErrors if not already there. The first one to add to this list
    // will be upon the first rejection so that the root cause (first promise in the
    // rejection chain) is the one listed.
    if (!unhandledErrors.some(function (p) {
        return p._value === promise._value;
    })) unhandledErrors.push(promise);
}

function markErrorAsHandled(promise) {
    // Called when a reject handled is actually being called.
    // Search in unhandledErrors for any promise whos _value is this promise_value (list
    // contains only rejected promises, and only one item per error)
    var i = unhandledErrors.length;
    while (i) {
        if (unhandledErrors[--i]._value === promise._value) {
            // Found a promise that failed with this same error object pointer,
            // Remove that since there is a listener that actually takes care of it.
            unhandledErrors.splice(i, 1);
            return;
        }
    }
}

// By default, log uncaught errors to the console
function defaultErrorHandler(e) {
    console.warn('Unhandled rejection: ' + (e.stack || e));
}

function PromiseReject(reason) {
    return new Promise(INTERNAL, false, reason);
}

function wrap(fn, errorCatcher) {
    var psd = PSD;
    return function () {
        var wasRootExec = beginMicroTickScope(),
            outerScope = PSD;

        try {
            if (outerScope !== psd) {
                // **KEEP** outerScope.env = wrappers.snapshot(); // Snapshot outerScope's environment
                PSD = psd;
                // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.
            }
            return fn.apply(this, arguments);
        } catch (e) {
            errorCatcher && errorCatcher(e);
        } finally {
            if (outerScope !== psd) {
                PSD = outerScope;
                // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment
            }
            if (wasRootExec) endMicroTickScope();
        }
    };
}

function newScope(fn, a1, a2, a3) {
    var parent = PSD,
        psd = Object.create(parent);
    psd.parent = parent;
    psd.ref = 0;
    psd.global = false;
    // **KEEP** psd.env = wrappers.wrap(psd);

    // unhandleds and onunhandled should not be specifically set here.
    // Leave them on parent prototype.
    // unhandleds.push(err) will push to parent's prototype
    // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)
    ++parent.ref;
    psd.finalize = function () {
        --this.parent.ref || this.parent.finalize();
    };
    var rv = usePSD(psd, fn, a1, a2, a3);
    if (psd.ref === 0) psd.finalize();
    return rv;
}

function usePSD(psd, fn, a1, a2, a3) {
    var outerScope = PSD;
    try {
        if (psd !== outerScope) {
            // **KEEP** outerScope.env = wrappers.snapshot(); // snapshot outerScope's environment.
            PSD = psd;
            // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.
        }
        return fn(a1, a2, a3);
    } finally {
        if (psd !== outerScope) {
            PSD = outerScope;
            // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment.
        }
    }
}

var UNHANDLEDREJECTION = "unhandledrejection";

function globalError(err, promise) {
    var rv;
    try {
        rv = promise.onuncatched(err);
    } catch (e) {}
    if (rv !== false) try {
        var event,
            eventData = { promise: promise, reason: err };
        if (_global.document && document.createEvent) {
            event = document.createEvent('Event');
            event.initEvent(UNHANDLEDREJECTION, true, true);
            extend(event, eventData);
        } else if (_global.CustomEvent) {
            event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
            extend(event, eventData);
        }
        if (event && _global.dispatchEvent) {
            dispatchEvent(event);
            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.
                try {
                    _global.onunhandledrejection(event);
                } catch (_) {}
        }
        if (!event.defaultPrevented) {
            // Backward compatibility: fire to events registered at Promise.on.error
            Promise.on.error.fire(err, promise);
        }
    } catch (e) {}
}

/* **KEEP** 

export function wrapPromise(PromiseClass) {
    var proto = PromiseClass.prototype;
    var origThen = proto.then;
    
    wrappers.add({
        snapshot: () => proto.then,
        restore: value => {proto.then = value;},
        wrap: () => patchedThen
    });

    function patchedThen (onFulfilled, onRejected) {
        var promise = this;
        var onFulfilledProxy = wrap(function(value){
            var rv = value;
            if (onFulfilled) {
                rv = onFulfilled(rv);
                if (rv && typeof rv.then === 'function') rv.then(); // Intercept that promise as well.
            }
            --PSD.ref || PSD.finalize();
            return rv;
        });
        var onRejectedProxy = wrap(function(err){
            promise._$err = err;
            var unhandleds = PSD.unhandleds;
            var idx = unhandleds.length,
                rv;
            while (idx--) if (unhandleds[idx]._$err === err) break;
            if (onRejected) {
                if (idx !== -1) unhandleds.splice(idx, 1); // Mark as handled.
                rv = onRejected(err);
                if (rv && typeof rv.then === 'function') rv.then(); // Intercept that promise as well.
            } else {
                if (idx === -1) unhandleds.push(promise);
                rv = PromiseClass.reject(err);
                rv._$nointercept = true; // Prohibit eternal loop.
            }
            --PSD.ref || PSD.finalize();
            return rv;
        });
        
        if (this._$nointercept) return origThen.apply(this, arguments);
        ++PSD.ref;
        return origThen.call(this, onFulfilledProxy, onRejectedProxy);
    }
}

// Global Promise wrapper
if (_global.Promise) wrapPromise(_global.Promise);

*/

doFakeAutoComplete(function () {
    // Simplify the job for VS Intellisense. This piece of code is one of the keys to the new marvellous intellisense support in Dexie.
    asap$1 = function (fn, args) {
        setTimeout(function () {
            fn.apply(null, args);
        }, 0);
    };
});

function rejection(err, uncaughtHandler) {
    // Get the call stack and return a rejected promise.
    var rv = Promise.reject(err);
    return uncaughtHandler ? rv.uncaught(uncaughtHandler) : rv;
}

/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 1.5.1, Tue Nov 01 2016
 *
 * http://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */

var DEXIE_VERSION = '1.5.1';
var maxString = String.fromCharCode(65535);
var maxKey = function () {
    try {
        IDBKeyRange.only([[]]);return [[]];
    } catch (e) {
        return maxString;
    }
}();
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = function (frame) {
    return !/(dexie\.js|dexie\.min\.js)/.test(frame);
};

setDebug(debug, dexieStackFrameFilter);

function Dexie(dbName, options) {
    /// <param name="options" type="Object" optional="true">Specify only if you wich to control which addons that should run on this instance</param>
    var deps = Dexie.dependencies;
    var opts = extend({
        // Default Options
        addons: Dexie.addons, // Pick statically registered addons by default
        autoOpen: true, // Don't require db.open() explicitely.
        indexedDB: deps.indexedDB, // Backend IndexedDB api. Default to IDBShim or browser env.
        IDBKeyRange: deps.IDBKeyRange // Backend IDBKeyRange api. Default to IDBShim or browser env.
    }, options);
    var addons = opts.addons,
        autoOpen = opts.autoOpen,
        indexedDB = opts.indexedDB,
        IDBKeyRange = opts.IDBKeyRange;

    var globalSchema = this._dbSchema = {};
    var versions = [];
    var dbStoreNames = [];
    var allTables = {};
    ///<var type="IDBDatabase" />
    var idbdb = null; // Instance of IDBDatabase
    var dbOpenError = null;
    var isBeingOpened = false;
    var openComplete = false;
    var READONLY = "readonly",
        READWRITE = "readwrite";
    var db = this;
    var dbReadyResolve,
        dbReadyPromise = new Promise(function (resolve) {
        dbReadyResolve = resolve;
    }),
        cancelOpen,
        openCanceller = new Promise(function (_, reject) {
        cancelOpen = reject;
    });
    var autoSchema = true;
    var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB),
        hasGetAll;

    function init() {
        // Default subscribers to "versionchange" and "blocked".
        // Can be overridden by custom handlers. If custom handlers return false, these default
        // behaviours will be prevented.
        db.on("versionchange", function (ev) {
            // Default behavior for versionchange event is to close database connection.
            // Caller can override this behavior by doing db.on("versionchange", function(){ return false; });
            // Let's not block the other window from making it's delete() or open() call.
            // NOTE! This event is never fired in IE,Edge or Safari.
            if (ev.newVersion > 0) console.warn('Another connection wants to upgrade database \'' + db.name + '\'. Closing db now to resume the upgrade.');else console.warn('Another connection wants to delete database \'' + db.name + '\'. Closing db now to resume the delete request.');
            db.close();
            // In many web applications, it would be recommended to force window.reload()
            // when this event occurs. To do that, subscribe to the versionchange event
            // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)
            // The reason for this is that your current web app obviously has old schema code that needs
            // to be updated. Another window got a newer version of the app and needs to upgrade DB but
            // your window is blocking it unless we close it here.
        });
        db.on("blocked", function (ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn('Dexie.delete(\'' + db.name + '\') was blocked');else console.warn('Upgrade \'' + db.name + '\' blocked by other connection holding version ' + ev.oldVersion / 10);
        });
    }

    //
    //
    //
    // ------------------------- Versioning Framework---------------------------
    //
    //
    //

    this.version = function (versionNumber) {
        /// <param name="versionNumber" type="Number"></param>
        /// <returns type="Version"></returns>
        if (idbdb || isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, versionNumber);
        var versionInstance = versions.filter(function (v) {
            return v._cfg.version === versionNumber;
        })[0];
        if (versionInstance) return versionInstance;
        versionInstance = new Version(versionNumber);
        versions.push(versionInstance);
        versions.sort(lowerVersionFirst);
        return versionInstance;
    };

    function Version(versionNumber) {
        this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
        };
        this.stores({}); // Derive earlier schemas by default.
    }

    extend(Version.prototype, {
        stores: function (stores) {
            /// <summary>
            ///   Defines the schema for a particular version
            /// </summary>
            /// <param name="stores" type="Object">
            /// Example: <br/>
            ///   {users: "id++,first,last,&amp;username,*email", <br/>
            ///   passwords: "id++,&amp;username"}<br/>
            /// <br/>
            /// Syntax: {Table: "[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,..."}<br/><br/>
            /// Special characters:<br/>
            ///  "&amp;"  means unique key, <br/>
            ///  "*"  means value is multiEntry, <br/>
            ///  "++" means auto-increment and only applicable for primary key <br/>
            /// </param>
            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;

            // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.
            var storesSpec = {};
            versions.forEach(function (version) {
                // 'versions' is always sorted by lowest version first.
                extend(storesSpec, version._cfg.storesSource);
            });

            var dbschema = this._cfg.dbschema = {};
            this._parseStoresSpec(storesSpec, dbschema);
            // Update the latest schema to this version
            // Update API
            globalSchema = db._dbSchema = dbschema;
            removeTablesApi([allTables, db, Transaction.prototype]);
            setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), READWRITE, dbschema);
            dbStoreNames = keys(dbschema);
            return this;
        },
        upgrade: function (upgradeFunction) {
            /// <param name="upgradeFunction" optional="true">Function that performs upgrading actions.</param>
            var self = this;
            fakeAutoComplete(function () {
                upgradeFunction(db._createTransaction(READWRITE, keys(self._cfg.dbschema), self._cfg.dbschema)); // BUGBUG: No code completion for prev version's tables wont appear.
            });
            this._cfg.contentUpgrade = upgradeFunction;
            return this;
        },
        _parseStoresSpec: function (stores, outSchema) {
            keys(stores).forEach(function (tableName) {
                if (stores[tableName] !== null) {
                    var instanceTemplate = {};
                    var indexes = parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
                    if (primKey.keyPath) setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);
                    indexes.forEach(function (idx) {
                        if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                        setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () {
                            return "";
                        }) : "");
                    });
                    outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);
                }
            });
        }
    });

    function runUpgraders(oldVersion, idbtrans, reject) {
        var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);
        trans.create(idbtrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        newScope(function () {
            PSD.trans = trans;
            if (oldVersion === 0) {
                // Create tables:
                keys(globalSchema).forEach(function (tableName) {
                    createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                Promise.follow(function () {
                    return db.on.populate.fire(trans);
                }).catch(rejectTransaction);
            } else updateTablesAndIndexes(oldVersion, trans, idbtrans).catch(rejectTransaction);
        });
    }

    function updateTablesAndIndexes(oldVersion, trans, idbtrans) {
        // Upgrade version to version, step-by-step from oldest to newest version.
        // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)
        var queue = [];
        var oldVersionStruct = versions.filter(function (version) {
            return version._cfg.version === oldVersion;
        })[0];
        if (!oldVersionStruct) throw new exceptions.Upgrade("Dexie specification of currently installed DB version is missing");
        globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;
        var anyContentUpgraderHasRun = false;

        var versToRun = versions.filter(function (v) {
            return v._cfg.version > oldVersion;
        });
        versToRun.forEach(function (version) {
            /// <param name="version" type="Version"></param>
            queue.push(function () {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(oldSchema, idbtrans);
                adjustToExistingIndexNames(newSchema, idbtrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                // Add tables           
                diff.add.forEach(function (tuple) {
                    createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                // Change tables
                diff.change.forEach(function (change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    } else {
                        var store = idbtrans.objectStore(change.name);
                        // Add indexes
                        change.add.forEach(function (idx) {
                            addIndex(store, idx);
                        });
                        // Update indexes
                        change.change.forEach(function (idx) {
                            store.deleteIndex(idx.name);
                            addIndex(store, idx);
                        });
                        // Delete indexes
                        change.del.forEach(function (idxName) {
                            store.deleteIndex(idxName);
                        });
                    }
                });
                if (version._cfg.contentUpgrade) {
                    anyContentUpgraderHasRun = true;
                    return Promise.follow(function () {
                        version._cfg.contentUpgrade(trans);
                    });
                }
            });
            queue.push(function (idbtrans) {
                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                    // Dont delete old tables if ieBug is present and a content upgrader has run. Let tables be left in DB so far. This needs to be taken care of.
                    var newSchema = version._cfg.dbschema;
                    // Delete old tables
                    deleteRemovedTables(newSchema, idbtrans);
                }
            });
        });

        // Now, create a queue execution engine
        function runQueue() {
            return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : Promise.resolve();
        }

        return runQueue().then(function () {
            createMissingTables(globalSchema, idbtrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)
        });
    }

    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [], // Array of table names
            add: [], // Array of [tableName, newDefinition]
            change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}
        };
        for (var table in oldSchema) {
            if (!newSchema[table]) diff.del.push(table);
        }
        for (table in newSchema) {
            var oldDef = oldSchema[table],
                newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            } else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if (oldDef.primKey.src !== newDef.primKey.src) {
                    // Primary key has changed. Remove and re-add table.
                    change.recreate = true;
                    diff.change.push(change);
                } else {
                    // Same primary key. Just find out what differs:
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    for (var idxName in oldIndexes) {
                        if (!newIndexes[idxName]) change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        var oldIdx = oldIndexes[idxName],
                            newIdx = newIndexes[idxName];
                        if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }

    function createTable(idbtrans, tableName, primKey, indexes) {
        /// <param name="idbtrans" type="IDBTransaction"></param>
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
        indexes.forEach(function (idx) {
            addIndex(store, idx);
        });
        return store;
    }

    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function (tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }

    function deleteRemovedTables(newSchema, idbtrans) {
        for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {
            var storeName = idbtrans.db.objectStoreNames[i];
            if (newSchema[storeName] == null) {
                idbtrans.db.deleteObjectStore(storeName);
            }
        }
    }

    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }

    function dbUncaught(err) {
        return db.on.error.fire(err);
    }

    //
    //
    //      Dexie Protected API
    //
    //

    this._allTables = allTables;

    this._tableFactory = function createTable(mode, tableSchema) {
        /// <param name="tableSchema" type="TableSchema"></param>
        if (mode === READONLY) return new Table(tableSchema.name, tableSchema, Collection);else return new WriteableTable(tableSchema.name, tableSchema);
    };

    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {
        return new Transaction(mode, storeNames, dbschema, parentTransaction);
    };

    /* Generate a temporary transaction when db operations are done outside a transactino scope.
    */
    function tempTransaction(mode, storeNames, fn) {
        // Last argument is "writeLocked". But this doesnt apply to oneshot direct db operations, so we ignore it.
        if (!openComplete && !PSD.letThrough) {
            if (!isBeingOpened) {
                if (!autoOpen) return rejection(new exceptions.DatabaseClosed(), dbUncaught);
                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.
            }
            return dbReadyPromise.then(function () {
                return tempTransaction(mode, storeNames, fn);
            });
        } else {
            var trans = db._createTransaction(mode, storeNames, globalSchema);
            return trans._promise(mode, function (resolve, reject) {
                newScope(function () {
                    // OPTIMIZATION POSSIBLE? newScope() not needed because it's already done in _promise.
                    PSD.trans = trans;
                    fn(resolve, reject, trans);
                });
            }).then(function (result) {
                // Instead of resolving value directly, wait with resolving it until transaction has completed.
                // Otherwise the data would not be in the DB if requesting it in the then() operation.
                // Specifically, to ensure that the following expression will work:
                //
                //   db.friends.put({name: "Arne"}).then(function () {
                //       db.friends.where("name").equals("Arne").count(function(count) {
                //           assert (count === 1);
                //       });
                //   });
                //
                return trans._completion.then(function () {
                    return result;
                });
            }); /*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.
                 trans._reject(err);
                 return rejection(err);
                });*/
        }
    }

    this._whenReady = function (fn) {
        return new Promise(fake || openComplete || PSD.letThrough ? fn : function (resolve, reject) {
            if (!isBeingOpened) {
                if (!autoOpen) {
                    reject(new exceptions.DatabaseClosed());
                    return;
                }
                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.
            }
            dbReadyPromise.then(function () {
                fn(resolve, reject);
            });
        }).uncaught(dbUncaught);
    };

    //
    //
    //
    //
    //      Dexie API
    //
    //
    //

    this.verno = 0;

    this.open = function () {
        if (isBeingOpened || idbdb) return dbReadyPromise.then(function () {
            return dbOpenError ? rejection(dbOpenError, dbUncaught) : db;
        });
        debug && (openCanceller._stackHolder = getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.
        isBeingOpened = true;
        dbOpenError = null;
        openComplete = false;

        // Function pointers to call when the core opening process completes.
        var resolveDbReady = dbReadyResolve,

        // upgradeTransaction to abort on failure.
        upgradeTransaction = null;

        return Promise.race([openCanceller, new Promise(function (resolve, reject) {
            doFakeAutoComplete(function () {
                return resolve();
            });

            // Make sure caller has specified at least one version
            if (versions.length > 0) autoSchema = false;

            // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:
            // IE fails when deleting objectStore after reading from it.
            // A future version of Dexie.js will stopover an intermediate version to workaround this.
            // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.

            // If no API, throw!
            if (!indexedDB) throw new exceptions.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL " + "(not locally). If using old Safari versions, make sure to include indexedDB polyfill.");

            var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));
            if (!req) throw new exceptions.MissingAPI("IndexedDB API not available"); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134
            req.onerror = wrap(eventRejectHandler(reject));
            req.onblocked = wrap(fireOnBlocked);
            req.onupgradeneeded = wrap(function (e) {
                upgradeTransaction = req.transaction;
                if (autoSchema && !db._allowEmptyDB) {
                    // Unless an addon has specified db._allowEmptyDB, lets make the call fail.
                    // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.
                    // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we
                    // do not create a new database by accident here.
                    req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!
                    upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)
                    // Close database and delete it.
                    req.result.close();
                    var delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!
                    delreq.onsuccess = delreq.onerror = wrap(function () {
                        reject(new exceptions.NoSuchDatabase('Database ' + dbName + ' doesnt exist'));
                    });
                } else {
                    upgradeTransaction.onerror = wrap(eventRejectHandler(reject));
                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.
                    runUpgraders(oldVer / 10, upgradeTransaction, reject, req);
                }
            }, reject);

            req.onsuccess = wrap(function () {
                // Core opening procedure complete. Now let's just record some stuff.
                upgradeTransaction = null;
                idbdb = req.result;
                connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.

                if (autoSchema) readGlobalSchema();else if (idbdb.objectStoreNames.length > 0) {
                    try {
                        adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));
                    } catch (e) {
                        // Safari may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.
                    }
                }

                idbdb.onversionchange = wrap(function (ev) {
                    db._vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)
                    db.on("versionchange").fire(ev);
                });

                if (!hasNativeGetDatabaseNames) {
                    // Update localStorage with list of database names
                    globalDatabaseList(function (databaseNames) {
                        if (databaseNames.indexOf(dbName) === -1) return databaseNames.push(dbName);
                    });
                }

                resolve();
            }, reject);
        })]).then(function () {
            // Before finally resolving the dbReadyPromise and this promise,
            // call and await all on('ready') subscribers:
            // Dexie.vip() makes subscribers able to use the database while being opened.
            // This is a must since these subscribers take part of the opening procedure.
            return Dexie.vip(db.on.ready.fire);
        }).then(function () {
            // Resolve the db.open() with the db instance.
            isBeingOpened = false;
            return db;
        }).catch(function (err) {
            try {
                // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.
                upgradeTransaction && upgradeTransaction.abort();
            } catch (e) {}
            isBeingOpened = false; // Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).
            db.close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.
            // A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.
            dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.
            return rejection(dbOpenError, dbUncaught); // dbUncaught will make sure any error that happened in any operation before will now bubble to db.on.error() thanks to the special handling in Promise.uncaught().
        }).finally(function () {
            openComplete = true;
            resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.
        });
    };

    this.close = function () {
        var idx = connections.indexOf(db);
        if (idx >= 0) connections.splice(idx, 1);
        if (idbdb) {
            try {
                idbdb.close();
            } catch (e) {}
            idbdb = null;
        }
        autoOpen = false;
        dbOpenError = new exceptions.DatabaseClosed();
        if (isBeingOpened) cancelOpen(dbOpenError);
        // Reset dbReadyPromise promise:
        dbReadyPromise = new Promise(function (resolve) {
            dbReadyResolve = resolve;
        });
        openCanceller = new Promise(function (_, reject) {
            cancelOpen = reject;
        });
    };

    this.delete = function () {
        var hasArguments = arguments.length > 0;
        return new Promise(function (resolve, reject) {
            if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
            if (isBeingOpened) {
                dbReadyPromise.then(doDelete);
            } else {
                doDelete();
            }
            function doDelete() {
                db.close();
                var req = indexedDB.deleteDatabase(dbName);
                req.onsuccess = wrap(function () {
                    if (!hasNativeGetDatabaseNames) {
                        globalDatabaseList(function (databaseNames) {
                            var pos = databaseNames.indexOf(dbName);
                            if (pos >= 0) return databaseNames.splice(pos, 1);
                        });
                    }
                    resolve();
                });
                req.onerror = wrap(eventRejectHandler(reject));
                req.onblocked = fireOnBlocked;
            }
        }).uncaught(dbUncaught);
    };

    this.backendDB = function () {
        return idbdb;
    };

    this.isOpen = function () {
        return idbdb !== null;
    };
    this.hasFailed = function () {
        return dbOpenError !== null;
    };
    this.dynamicallyOpened = function () {
        return autoSchema;
    };

    //
    // Properties
    //
    this.name = dbName;

    // db.tables - an array of all Table instances.
    setProp(this, "tables", {
        get: function () {
            /// <returns type="Array" elementType="WriteableTable" />
            return keys(allTables).map(function (name) {
                return allTables[name];
            });
        }
    });

    //
    // Events
    //
    this.on = Events(this, "error", "populate", "blocked", "versionchange", { ready: [promisableChain, nop] });
    this.on.error.subscribe = deprecated("Dexie.on.error", this.on.error.subscribe);
    this.on.error.unsubscribe = deprecated("Dexie.on.error.unsubscribe", this.on.error.unsubscribe);

    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
        return function (subscriber, bSticky) {
            Dexie.vip(function () {
                if (openComplete) {
                    // Database already open. Call subscriber asap.
                    if (!dbOpenError) Promise.resolve().then(subscriber);
                    // bSticky: Also subscribe to future open sucesses (after close / reopen) 
                    if (bSticky) subscribe(subscriber);
                } else {
                    // Database not yet open. Subscribe to it.
                    subscribe(subscriber);
                    // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.
                    if (!bSticky) subscribe(function unsubscribe() {
                        db.on.ready.unsubscribe(subscriber);
                        db.on.ready.unsubscribe(unsubscribe);
                    });
                }
            });
        };
    });

    fakeAutoComplete(function () {
        db.on("populate").fire(db._createTransaction(READWRITE, dbStoreNames, globalSchema));
        db.on("error").fire(new Error());
    });

    this.transaction = function (mode, tableInstances, scopeFunc) {
        /// <summary>
        ///
        /// </summary>
        /// <param name="mode" type="String">"r" for readonly, or "rw" for readwrite</param>
        /// <param name="tableInstances">Table instance, Array of Table instances, String or String Array of object stores to include in the transaction</param>
        /// <param name="scopeFunc" type="Function">Function to execute with transaction</param>

        // Let table arguments be all arguments between mode and last argument.
        var i = arguments.length;
        if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
        // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)
        // and clone arguments except the first one into local var 'args'.
        var args = new Array(i - 1);
        while (--i) {
            args[i - 1] = arguments[i];
        } // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.
        scopeFunc = args.pop();
        var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.
        var parentTransaction = PSD.trans;
        // Check if parent transactions is bound to this db instance, and if caller wants to reuse it
        if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1) parentTransaction = null;
        var onlyIfCompatible = mode.indexOf('?') !== -1;
        mode = mode.replace('!', '').replace('?', ''); // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.

        try {
            //
            // Get storeNames from arguments. Either through given table instances, or through given table names.
            //
            var storeNames = tables.map(function (table) {
                var storeName = table instanceof Table ? table.name : table;
                if (typeof storeName !== 'string') throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
            });

            //
            // Resolve mode. Allow shortcuts "r" and "rw".
            //
            if (mode == "r" || mode == READONLY) mode = READONLY;else if (mode == "rw" || mode == READWRITE) mode = READWRITE;else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);

            if (parentTransaction) {
                // Basic checks
                if (parentTransaction.mode === READONLY && mode === READWRITE) {
                    if (onlyIfCompatible) {
                        // Spawn new transaction instead.
                        parentTransaction = null;
                    } else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) {
                    storeNames.forEach(function (storeName) {
                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                            if (onlyIfCompatible) {
                                // Spawn new transaction instead.
                                parentTransaction = null;
                            } else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                        }
                    });
                }
            }
        } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function (_, reject) {
                reject(e);
            }) : rejection(e, dbUncaught);
        }
        // If this is a sub-transaction, lock the parent and then launch the sub-transaction.
        return parentTransaction ? parentTransaction._promise(mode, enterTransactionScope, "lock") : db._whenReady(enterTransactionScope);

        function enterTransactionScope(resolve) {
            var parentPSD = PSD;
            resolve(Promise.resolve().then(function () {
                return newScope(function () {
                    // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().
                    PSD.transless = PSD.transless || parentPSD;
                    // Our transaction.
                    //return new Promise((resolve, reject) => {
                    var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction);
                    // Let the transaction instance be part of a Promise-specific data (PSD) value.
                    PSD.trans = trans;

                    if (parentTransaction) {
                        // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)
                        trans.idbtrans = parentTransaction.idbtrans;
                    } else {
                        trans.create(); // Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.
                    }

                    // Provide arguments to the scope function (for backward compatibility)
                    var tableArgs = storeNames.map(function (name) {
                        return allTables[name];
                    });
                    tableArgs.push(trans);

                    var returnValue;
                    return Promise.follow(function () {
                        // Finally, call the scope function with our table and transaction arguments.
                        returnValue = scopeFunc.apply(trans, tableArgs); // NOTE: returnValue is used in trans.on.complete() not as a returnValue to this func.
                        if (returnValue) {
                            if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                                // scopeFunc returned an iterator with throw-support. Handle yield as await.
                                returnValue = awaitIterator(returnValue);
                            } else if (typeof returnValue.then === 'function' && !hasOwn(returnValue, '_PSD')) {
                                throw new exceptions.IncompatiblePromise("Incompatible Promise returned from transaction scope (read more at http://tinyurl.com/znyqjqc). Transaction scope: " + scopeFunc.toString());
                            }
                        }
                    }).uncaught(dbUncaught).then(function () {
                        if (parentTransaction) trans._resolve(); // sub transactions don't react to idbtrans.oncomplete. We must trigger a acompletion.
                        return trans._completion; // Even if WE believe everything is fine. Await IDBTransaction's oncomplete or onerror as well.
                    }).then(function () {
                        return returnValue;
                    }).catch(function (e) {
                        //reject(e);
                        trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!
                        return rejection(e);
                    });
                    //});
                });
            }));
        }
    };

    this.table = function (tableName) {
        /// <returns type="WriteableTable"></returns>
        if (fake && autoSchema) return new WriteableTable(tableName);
        if (!hasOwn(allTables, tableName)) {
            throw new exceptions.InvalidTable('Table ' + tableName + ' does not exist');
        }
        return allTables[tableName];
    };

    //
    //
    //
    // Table Class
    //
    //
    //
    function Table(name, tableSchema, collClass) {
        /// <param name="name" type="String"></param>
        this.name = name;
        this.schema = tableSchema;
        this.hook = allTables[name] ? allTables[name].hook : Events(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
        });
        this._collClass = collClass || Collection;
    }

    props(Table.prototype, {

        //
        // Table Protected Methods
        //

        _trans: function getTransaction(mode, fn, writeLocked) {
            var trans = PSD.trans;
            return trans && trans.db === db ? trans._promise(mode, fn, writeLocked) : tempTransaction(mode, [this.name], fn);
        },
        _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {
            if (fake) return new Promise(fn); // Simplify the work for Intellisense/Code completion.
            var trans = PSD.trans,
                tableName = this.name;
            function supplyIdbStore(resolve, reject, trans) {
                fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);
            }
            return trans && trans.db === db ? trans._promise(mode, supplyIdbStore, writeLocked) : tempTransaction(mode, [this.name], supplyIdbStore);
        },

        //
        // Table Public Methods
        //
        get: function (key, cb) {
            var self = this;
            return this._idbstore(READONLY, function (resolve, reject, idbstore) {
                fake && resolve(self.schema.instanceTemplate);
                var req = idbstore.get(key);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap(function () {
                    resolve(self.hook.reading.fire(req.result));
                }, reject);
            }).then(cb);
        },
        where: function (indexName) {
            return new WhereClause(this, indexName);
        },
        count: function (cb) {
            return this.toCollection().count(cb);
        },
        offset: function (offset) {
            return this.toCollection().offset(offset);
        },
        limit: function (numRows) {
            return this.toCollection().limit(numRows);
        },
        reverse: function () {
            return this.toCollection().reverse();
        },
        filter: function (filterFunction) {
            return this.toCollection().and(filterFunction);
        },
        each: function (fn) {
            return this.toCollection().each(fn);
        },
        toArray: function (cb) {
            return this.toCollection().toArray(cb);
        },
        orderBy: function (index) {
            return new this._collClass(new WhereClause(this, index));
        },

        toCollection: function () {
            return new this._collClass(new WhereClause(this));
        },

        mapToClass: function (constructor, structure) {
            /// <summary>
            ///     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making
            ///     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.
            /// </summary>
            /// <param name="constructor">Constructor function representing the class.</param>
            /// <param name="structure" optional="true">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
            /// know what type each member has. Example: {name: String, emailAddresses: [String], password}</param>
            this.schema.mappedClass = constructor;
            var instanceTemplate = Object.create(constructor.prototype);
            if (structure) {
                // structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.
                applyStructure(instanceTemplate, structure);
            }
            this.schema.instanceTemplate = instanceTemplate;

            // Now, subscribe to the when("reading") event to make all objects that come out from this table inherit from given class
            // no matter which method to use for reading (Table.get() or Table.where(...)... )
            var readHook = function (obj) {
                if (!obj) return obj; // No valid object. (Value is null). Return as is.
                // Create a new object that derives from constructor:
                var res = Object.create(constructor.prototype);
                // Clone members:
                for (var m in obj) {
                    if (hasOwn(obj, m)) try {
                        res[m] = obj[m];
                    } catch (_) {}
                }return res;
            };

            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        },
        defineClass: function (structure) {
            /// <summary>
            ///     Define all members of the class that represents the table. This will help code completion of when objects are read from the database
            ///     as well as making it possible to extend the prototype of the returned constructor function.
            /// </summary>
            /// <param name="structure">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
            /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>
            return this.mapToClass(Dexie.defineClass(structure), structure);
        }
    });

    //
    //
    //
    // WriteableTable Class (extends Table)
    //
    //
    //
    function WriteableTable(name, tableSchema, collClass) {
        Table.call(this, name, tableSchema, collClass || WriteableCollection);
    }

    function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {
        return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {
            errorList.push(e);
            done && done();
        });
    }

    function bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {
        // If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],
        // else keysOrTuples must be just an array of keys: [key1, key2, ...].
        return new Promise(function (resolve, reject) {
            var len = keysOrTuples.length,
                lastItem = len - 1;
            if (len === 0) return resolve();
            if (!hasDeleteHook) {
                for (var i = 0; i < len; ++i) {
                    var req = idbstore.delete(keysOrTuples[i]);
                    req.onerror = wrap(eventRejectHandler(reject));
                    if (i === lastItem) req.onsuccess = wrap(function () {
                        return resolve();
                    });
                }
            } else {
                var hookCtx,
                    errorHandler = hookedEventRejectHandler(reject),
                    successHandler = hookedEventSuccessHandler(null);
                tryCatch(function () {
                    for (var i = 0; i < len; ++i) {
                        hookCtx = { onsuccess: null, onerror: null };
                        var tuple = keysOrTuples[i];
                        deletingHook.call(hookCtx, tuple[0], tuple[1], trans);
                        var req = idbstore.delete(tuple[0]);
                        req._hookCtx = hookCtx;
                        req.onerror = errorHandler;
                        if (i === lastItem) req.onsuccess = hookedEventSuccessHandler(resolve);else req.onsuccess = successHandler;
                    }
                }, function (err) {
                    hookCtx.onerror && hookCtx.onerror(err);
                    throw err;
                });
            }
        }).uncaught(dbUncaught);
    }

    derive(WriteableTable).from(Table).extend({
        bulkDelete: function (keys$$1) {
            if (this.hook.deleting.fire === nop) {
                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                    resolve(bulkDelete(idbstore, trans, keys$$1, false, nop));
                });
            } else {
                return this.where(':id').anyOf(keys$$1).delete().then(function () {}); // Resolve with undefined.
            }
        },
        bulkPut: function (objects, keys$$1) {
            var _this = this;

            return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkPut() with non-inbound keys requires keys array in second argument");
                if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                if (objects.length === 0) return resolve(); // Caller provided empty list.
                var done = function (result) {
                    if (errorList.length === 0) resolve(result);else reject(new BulkError(_this.name + '.bulkPut(): ' + errorList.length + ' of ' + numObjs + ' operations failed', errorList));
                };
                var req,
                    errorList = [],
                    errorHandler,
                    numObjs = objects.length,
                    table = _this;
                if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {
                    //
                    // Standard Bulk (no 'creating' or 'updating' hooks to care about)
                    //
                    errorHandler = BulkErrorHandlerCatchAll(errorList);
                    for (var i = 0, l = objects.length; i < l; ++i) {
                        req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);
                        req.onerror = errorHandler;
                    }
                    // Only need to catch success or error on the last operation
                    // according to the IDB spec.
                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);
                    req.onsuccess = eventSuccessHandler(done);
                } else {
                    var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) {
                        return getByKeyPath(o, idbstore.keyPath);
                    });
                    // Generate map of {[key]: object}
                    var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) {
                        return key != null && [key, objects[i]];
                    });
                    var promise = !effectiveKeys ?

                    // Auto-incremented key-less objects only without any keys argument.
                    table.bulkAdd(objects) :

                    // Keys provided. Either as inbound in provided objects, or as a keys argument.
                    // Begin with updating those that exists in DB:
                    table.where(':id').anyOf(effectiveKeys.filter(function (key) {
                        return key != null;
                    })).modify(function () {
                        this.value = objectLookup[this.primKey];
                        objectLookup[this.primKey] = null; // Mark as "don't add this"
                    }).catch(ModifyError, function (e) {
                        errorList = e.failures; // No need to concat here. These are the first errors added.
                    }).then(function () {
                        // Now, let's examine which items didnt exist so we can add them:
                        var objsToAdd = [],
                            keysToAdd = keys$$1 && [];
                        // Iterate backwards. Why? Because if same key was used twice, just add the last one.
                        for (var i = effectiveKeys.length - 1; i >= 0; --i) {
                            var key = effectiveKeys[i];
                            if (key == null || objectLookup[key]) {
                                objsToAdd.push(objects[i]);
                                keys$$1 && keysToAdd.push(key);
                                if (key != null) objectLookup[key] = null; // Mark as "dont add again"
                            }
                        }
                        // The items are in reverse order so reverse them before adding.
                        // Could be important in order to get auto-incremented keys the way the caller
                        // would expect. Could have used unshift instead of push()/reverse(),
                        // but: http://jsperf.com/unshift-vs-reverse
                        objsToAdd.reverse();
                        keys$$1 && keysToAdd.reverse();
                        return table.bulkAdd(objsToAdd, keysToAdd);
                    }).then(function (lastAddedKey) {
                        // Resolve with key of the last object in given arguments to bulkPut():
                        var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; // Key was provided.
                        return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;
                    });

                    promise.then(done).catch(BulkError, function (e) {
                        // Concat failure from ModifyError and reject using our 'done' method.
                        errorList = errorList.concat(e.failures);
                        done();
                    }).catch(reject);
                }
            }, "locked"); // If called from transaction scope, lock transaction til all steps are done.
        },
        bulkAdd: function (objects, keys$$1) {
            var self = this,
                creatingHook = this.hook.creating.fire;
            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument("bulkAdd() with non-inbound keys requires keys array in second argument");
                if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                if (objects.length === 0) return resolve(); // Caller provided empty list.
                function done(result) {
                    if (errorList.length === 0) resolve(result);else reject(new BulkError(self.name + '.bulkAdd(): ' + errorList.length + ' of ' + numObjs + ' operations failed', errorList));
                }
                var req,
                    errorList = [],
                    errorHandler,
                    successHandler,
                    numObjs = objects.length;
                if (creatingHook !== nop) {
                    //
                    // There are subscribers to hook('creating')
                    // Must behave as documented.
                    //
                    var keyPath = idbstore.keyPath,
                        hookCtx;
                    errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);
                    successHandler = hookedEventSuccessHandler(null);

                    tryCatch(function () {
                        for (var i = 0, l = objects.length; i < l; ++i) {
                            hookCtx = { onerror: null, onsuccess: null };
                            var key = keys$$1 && keys$$1[i];
                            var obj = objects[i],
                                effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined,
                                keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);
                            if (effectiveKey == null && keyToUse != null) {
                                if (keyPath) {
                                    obj = deepClone(obj);
                                    setByKeyPath(obj, keyPath, keyToUse);
                                } else {
                                    key = keyToUse;
                                }
                            }
                            req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
                            req._hookCtx = hookCtx;
                            if (i < l - 1) {
                                req.onerror = errorHandler;
                                if (hookCtx.onsuccess) req.onsuccess = successHandler;
                            }
                        }
                    }, function (err) {
                        hookCtx.onerror && hookCtx.onerror(err);
                        throw err;
                    });

                    req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);
                    req.onsuccess = hookedEventSuccessHandler(done);
                } else {
                    //
                    // Standard Bulk (no 'creating' hook to care about)
                    //
                    errorHandler = BulkErrorHandlerCatchAll(errorList);
                    for (var i = 0, l = objects.length; i < l; ++i) {
                        req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);
                        req.onerror = errorHandler;
                    }
                    // Only need to catch success or error on the last operation
                    // according to the IDB spec.
                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);
                    req.onsuccess = eventSuccessHandler(done);
                }
            });
        },
        add: function (obj, key) {
            /// <summary>
            ///   Add an object to the database. In case an object with same primary key already exists, the object will not be added.
            /// </summary>
            /// <param name="obj" type="Object">A javascript object to insert</param>
            /// <param name="key" optional="true">Primary key</param>
            var creatingHook = this.hook.creating.fire;
            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {
                var hookCtx = { onsuccess: null, onerror: null };
                if (creatingHook !== nop) {
                    var effectiveKey = key != null ? key : idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined;
                    var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); // Allow subscribers to when("creating") to generate the key.
                    if (effectiveKey == null && keyToUse != null) {
                        // Using "==" and "!=" to check for either null or undefined!
                        if (idbstore.keyPath) setByKeyPath(obj, idbstore.keyPath, keyToUse);else key = keyToUse;
                    }
                }
                try {
                    var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);
                    req._hookCtx = hookCtx;
                    req.onerror = hookedEventRejectHandler(reject);
                    req.onsuccess = hookedEventSuccessHandler(function (result) {
                        // TODO: Remove these two lines in next major release (2.0?)
                        // It's no good practice to have side effects on provided parameters
                        var keyPath = idbstore.keyPath;
                        if (keyPath) setByKeyPath(obj, keyPath, result);
                        resolve(result);
                    });
                } catch (e) {
                    if (hookCtx.onerror) hookCtx.onerror(e);
                    throw e;
                }
            });
        },

        put: function (obj, key) {
            /// <summary>
            ///   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.
            /// </summary>
            /// <param name="obj" type="Object">A javascript object to insert or update</param>
            /// <param name="key" optional="true">Primary key</param>
            var self = this,
                creatingHook = this.hook.creating.fire,
                updatingHook = this.hook.updating.fire;
            if (creatingHook !== nop || updatingHook !== nop) {
                //
                // People listens to when("creating") or when("updating") events!
                // We must know whether the put operation results in an CREATE or UPDATE.
                //
                return this._trans(READWRITE, function (resolve, reject, trans) {
                    // Since key is optional, make sure we get it from obj if not provided
                    var effectiveKey = key !== undefined ? key : self.schema.primKey.keyPath && getByKeyPath(obj, self.schema.primKey.keyPath);
                    if (effectiveKey == null) {
                        // "== null" means checking for either null or undefined.
                        // No primary key. Must use add().
                        self.add(obj).then(resolve, reject);
                    } else {
                        // Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().
                        trans._lock(); // Needed because operation is splitted into modify() and add().
                        // clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.
                        obj = deepClone(obj);
                        self.where(":id").equals(effectiveKey).modify(function () {
                            // Replace extisting value with our object
                            // CRUD event firing handled in WriteableCollection.modify()
                            this.value = obj;
                        }).then(function (count) {
                            if (count === 0) {
                                // Object's key was not found. Add the object instead.
                                // CRUD event firing will be done in add()
                                return self.add(obj, key); // Resolving with another Promise. Returned Promise will then resolve with the new key.
                            } else {
                                return effectiveKey; // Resolve with the provided key.
                            }
                        }).finally(function () {
                            trans._unlock();
                        }).then(resolve, reject);
                    }
                });
            } else {
                // Use the standard IDB put() method.
                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                    var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = function (ev) {
                        var keyPath = idbstore.keyPath;
                        if (keyPath) setByKeyPath(obj, keyPath, ev.target.result);
                        resolve(req.result);
                    };
                });
            }
        },

        'delete': function (key) {
            /// <param name="key">Primary key of the object to delete</param>
            if (this.hook.deleting.subscribers.length) {
                // People listens to when("deleting") event. Must implement delete using WriteableCollection.delete() that will
                // call the CRUD event. Only WriteableCollection.delete() will know whether an object was actually deleted.
                return this.where(":id").equals(key).delete();
            } else {
                // No one listens. Use standard IDB delete() method.
                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                    var req = idbstore.delete(key);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = function () {
                        resolve(req.result);
                    };
                });
            }
        },

        clear: function () {
            if (this.hook.deleting.subscribers.length) {
                // People listens to when("deleting") event. Must implement delete using WriteableCollection.delete() that will
                // call the CRUD event. Only WriteableCollection.delete() will knows which objects that are actually deleted.
                return this.toCollection().delete();
            } else {
                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {
                    var req = idbstore.clear();
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = function () {
                        resolve(req.result);
                    };
                });
            }
        },

        update: function (keyOrObject, modifications) {
            if (typeof modifications !== 'object' || isArray(modifications)) throw new exceptions.InvalidArgument("Modifications must be an object.");
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                // object to modify. Also modify given object with the modifications:
                keys(modifications).forEach(function (keyPath) {
                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                });
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"), dbUncaught);
                return this.where(":id").equals(key).modify(modifications);
            } else {
                // key to modify
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        }
    });

    //
    //
    //
    // Transaction Class
    //
    //
    //
    function Transaction(mode, storeNames, dbschema, parent) {
        var _this2 = this;

        /// <summary>
        ///    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.
        /// </summary>
        /// <param name="mode" type="String">Any of "readwrite" or "readonly"</param>
        /// <param name="storeNames" type="Array">Array of table names to operate on</param>
        this.db = db;
        this.mode = mode;
        this.storeNames = storeNames;
        this.idbtrans = null;
        this.on = Events(this, "complete", "error", "abort");
        this.parent = parent || null;
        this.active = true;
        this._tables = null;
        this._reculock = 0;
        this._blockedFuncs = [];
        this._psd = null;
        this._dbschema = dbschema;
        this._resolve = null;
        this._reject = null;
        this._completion = new Promise(function (resolve, reject) {
            _this2._resolve = resolve;
            _this2._reject = reject;
        }).uncaught(dbUncaught);

        this._completion.then(function () {
            _this2.on.complete.fire();
        }, function (e) {
            _this2.on.error.fire(e);
            _this2.parent ? _this2.parent._reject(e) : _this2.active && _this2.idbtrans && _this2.idbtrans.abort();
            _this2.active = false;
            return rejection(e); // Indicate we actually DO NOT catch this error.
        });
    }

    props(Transaction.prototype, {
        //
        // Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)
        //
        _lock: function () {
            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.
            // Temporary set all requests into a pending queue if they are called before database is ready.
            ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)
            if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
            return this;
        },
        _unlock: function () {
            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.
            if (--this._reculock === 0) {
                if (!PSD.global) PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    } catch (e) {}
                }
            }
            return this;
        },
        _locked: function () {
            // Checks if any write-lock is applied on this transaction.
            // To simplify the Dexie API for extension implementations, we support recursive locks.
            // This is accomplished by using "Promise Specific Data" (PSD).
            // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).
            // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():
            //         * callback given to the Promise() constructor  (function (resolve, reject){...})
            //         * callbacks given to then()/catch()/finally() methods (function (value){...})
            // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.
            // Derivation is done so that the inner PSD __proto__ points to the outer PSD.
            // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.
            return this._reculock && PSD.lockOwnerFor !== this;
        },
        create: function (idbtrans) {
            var _this3 = this;

            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active) throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);

            idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);
            idbtrans.onerror = wrap(function (ev) {
                preventDefault(ev); // Prohibit default bubbling to window.error
                _this3._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function (ev) {
                preventDefault(ev);
                _this3.active && _this3._reject(new exceptions.Abort());
                _this3.active = false;
                _this3.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function () {
                _this3.active = false;
                _this3._resolve();
            });
            return this;
        },
        _promise: function (mode, fn, bWriteLock) {
            var self = this;
            var p = self._locked() ?
            // Read lock always. Transaction is write-locked. Wait for mutex.
            new Promise(function (resolve, reject) {
                self._blockedFuncs.push([function () {
                    self._promise(mode, fn, bWriteLock).then(resolve, reject);
                }, PSD]);
            }) : newScope(function () {
                var p_ = self.active ? new Promise(function (resolve, reject) {
                    if (mode === READWRITE && self.mode !== READWRITE) throw new exceptions.ReadOnly("Transaction is readonly");
                    if (!self.idbtrans && mode) self.create();
                    if (bWriteLock) self._lock(); // Write lock if write operation is requested
                    fn(resolve, reject, self);
                }) : rejection(new exceptions.TransactionInactive());
                if (self.active && bWriteLock) p_.finally(function () {
                    self._unlock();
                });
                return p_;
            });

            p._lib = true;
            return p.uncaught(dbUncaught);
        },

        //
        // Transaction Public Properties and Methods
        //
        abort: function () {
            this.active && this._reject(new exceptions.Abort());
            this.active = false;
        },

        tables: {
            get: deprecated("Transaction.tables", function () {
                return arrayToObject(this.storeNames, function (name) {
                    return [name, allTables[name]];
                });
            }, "Use db.tables()")
        },

        complete: deprecated("Transaction.complete()", function (cb) {
            return this.on("complete", cb);
        }),

        error: deprecated("Transaction.error()", function (cb) {
            return this.on("error", cb);
        }),

        table: deprecated("Transaction.table()", function (name) {
            if (this.storeNames.indexOf(name) === -1) throw new exceptions.InvalidTable("Table " + name + " not in transaction");
            return allTables[name];
        })

    });

    //
    //
    //
    // WhereClause
    //
    //
    //
    function WhereClause(table, index, orCollection) {
        /// <param name="table" type="Table"></param>
        /// <param name="index" type="String" optional="true"></param>
        /// <param name="orCollection" type="Collection" optional="true"></param>
        this._ctx = {
            table: table,
            index: index === ":id" ? null : index,
            collClass: table._collClass,
            or: orCollection
        };
    }

    props(WhereClause.prototype, function () {

        // WhereClause private methods

        function fail(collectionOrWhereClause, err, T) {
            var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause._ctx.collClass(collectionOrWhereClause) : collectionOrWhereClause;

            collection._ctx.error = T ? new T(err) : new TypeError(err);
            return collection;
        }

        function emptyCollection(whereClause) {
            return new whereClause._ctx.collClass(whereClause, function () {
                return IDBKeyRange.only("");
            }).limit(0);
        }

        function upperFactory(dir) {
            return dir === "next" ? function (s) {
                return s.toUpperCase();
            } : function (s) {
                return s.toLowerCase();
            };
        }
        function lowerFactory(dir) {
            return dir === "next" ? function (s) {
                return s.toLowerCase();
            } : function (s) {
                return s.toUpperCase();
            };
        }
        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
            var length = Math.min(key.length, lowerNeedle.length);
            var llp = -1;
            for (var i = 0; i < length; ++i) {
                var lwrKeyChar = lowerKey[i];
                if (lwrKeyChar !== lowerNeedle[i]) {
                    if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                    if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                    if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                    return null;
                }
                if (cmp(key[i], lwrKeyChar) < 0) llp = i;
            }
            if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
            if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
            return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
        }

        function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
            /// <param name="needles" type="Array" elementType="String"></param>
            var upper,
                lower,
                compare,
                upperNeedles,
                lowerNeedles,
                direction,
                nextKeySuffix,
                needlesLen = needles.length;
            if (!needles.every(function (s) {
                return typeof s === 'string';
            })) {
                return fail(whereClause, STRING_EXPECTED);
            }
            function initDirection(dir) {
                upper = upperFactory(dir);
                lower = lowerFactory(dir);
                compare = dir === "next" ? simpleCompare : simpleCompareReverse;
                var needleBounds = needles.map(function (needle) {
                    return { lower: lower(needle), upper: upper(needle) };
                }).sort(function (a, b) {
                    return compare(a.lower, b.lower);
                });
                upperNeedles = needleBounds.map(function (nb) {
                    return nb.upper;
                });
                lowerNeedles = needleBounds.map(function (nb) {
                    return nb.lower;
                });
                direction = dir;
                nextKeySuffix = dir === "next" ? "" : suffix;
            }
            initDirection("next");

            var c = new whereClause._ctx.collClass(whereClause, function () {
                return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
            });

            c._ondirectionchange = function (direction) {
                // This event onlys occur before filter is called the first time.
                initDirection(direction);
            };

            var firstPossibleNeedle = 0;

            c._addAlgorithm(function (cursor, advance, resolve) {
                /// <param name="cursor" type="IDBCursor"></param>
                /// <param name="advance" type="Function"></param>
                /// <param name="resolve" type="Function"></param>
                var key = cursor.key;
                if (typeof key !== 'string') return false;
                var lowerKey = lower(key);
                if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                    return true;
                } else {
                    var lowestPossibleCasing = null;
                    for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                            lowestPossibleCasing = casing;
                        }
                    }
                    if (lowestPossibleCasing !== null) {
                        advance(function () {
                            cursor.continue(lowestPossibleCasing + nextKeySuffix);
                        });
                    } else {
                        advance(resolve);
                    }
                    return false;
                }
            });
            return c;
        }

        //
        // WhereClause public methods
        //
        return {
            between: function (lower, upper, includeLower, includeUpper) {
                /// <summary>
                ///     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.
                /// </summary>
                /// <param name="lower"></param>
                /// <param name="upper"></param>
                /// <param name="includeLower" optional="true">Whether items that equals lower should be included. Default true.</param>
                /// <param name="includeUpper" optional="true">Whether items that equals upper should be included. Default false.</param>
                /// <returns type="Collection"></returns>
                includeLower = includeLower !== false; // Default to true
                includeUpper = includeUpper === true; // Default to false
                try {
                    if (cmp(lower, upper) > 0 || cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.
                    return new this._ctx.collClass(this, function () {
                        return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper);
                    });
                } catch (e) {
                    return fail(this, INVALID_KEY_ARGUMENT);
                }
            },
            equals: function (value) {
                return new this._ctx.collClass(this, function () {
                    return IDBKeyRange.only(value);
                });
            },
            above: function (value) {
                return new this._ctx.collClass(this, function () {
                    return IDBKeyRange.lowerBound(value, true);
                });
            },
            aboveOrEqual: function (value) {
                return new this._ctx.collClass(this, function () {
                    return IDBKeyRange.lowerBound(value);
                });
            },
            below: function (value) {
                return new this._ctx.collClass(this, function () {
                    return IDBKeyRange.upperBound(value, true);
                });
            },
            belowOrEqual: function (value) {
                return new this._ctx.collClass(this, function () {
                    return IDBKeyRange.upperBound(value);
                });
            },
            startsWith: function (str) {
                /// <param name="str" type="String"></param>
                if (typeof str !== 'string') return fail(this, STRING_EXPECTED);
                return this.between(str, str + maxString, true, true);
            },
            startsWithIgnoreCase: function (str) {
                /// <param name="str" type="String"></param>
                if (str === "") return this.startsWith(str);
                return addIgnoreCaseAlgorithm(this, function (x, a) {
                    return x.indexOf(a[0]) === 0;
                }, [str], maxString);
            },
            equalsIgnoreCase: function (str) {
                /// <param name="str" type="String"></param>
                return addIgnoreCaseAlgorithm(this, function (x, a) {
                    return x === a[0];
                }, [str], "");
            },
            anyOfIgnoreCase: function () {
                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                if (set.length === 0) return emptyCollection(this);
                return addIgnoreCaseAlgorithm(this, function (x, a) {
                    return a.indexOf(x) !== -1;
                }, set, "");
            },
            startsWithAnyOfIgnoreCase: function () {
                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                if (set.length === 0) return emptyCollection(this);
                return addIgnoreCaseAlgorithm(this, function (x, a) {
                    return a.some(function (n) {
                        return x.indexOf(n) === 0;
                    });
                }, set, maxString);
            },
            anyOf: function () {
                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                var compare = ascending;
                try {
                    set.sort(compare);
                } catch (e) {
                    return fail(this, INVALID_KEY_ARGUMENT);
                }
                if (set.length === 0) return emptyCollection(this);
                var c = new this._ctx.collClass(this, function () {
                    return IDBKeyRange.bound(set[0], set[set.length - 1]);
                });

                c._ondirectionchange = function (direction) {
                    compare = direction === "next" ? ascending : descending;
                    set.sort(compare);
                };
                var i = 0;
                c._addAlgorithm(function (cursor, advance, resolve) {
                    var key = cursor.key;
                    while (compare(key, set[i]) > 0) {
                        // The cursor has passed beyond this key. Check next.
                        ++i;
                        if (i === set.length) {
                            // There is no next. Stop searching.
                            advance(resolve);
                            return false;
                        }
                    }
                    if (compare(key, set[i]) === 0) {
                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
                        return true;
                    } else {
                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
                        advance(function () {
                            cursor.continue(set[i]);
                        });
                        return false;
                    }
                });
                return c;
            },

            notEqual: function (value) {
                return this.inAnyRange([[-Infinity, value], [value, maxKey]], { includeLowers: false, includeUppers: false });
            },

            noneOf: function () {
                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                if (set.length === 0) return new this._ctx.collClass(this); // Return entire collection.
                try {
                    set.sort(ascending);
                } catch (e) {
                    return fail(this, INVALID_KEY_ARGUMENT);
                }
                // Transform ["a","b","c"] to a set of ranges for between/above/below: [[-Infinity,"a"], ["a","b"], ["b","c"], ["c",maxKey]]
                var ranges = set.reduce(function (res, val) {
                    return res ? res.concat([[res[res.length - 1][1], val]]) : [[-Infinity, val]];
                }, null);
                ranges.push([set[set.length - 1], maxKey]);
                return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
            },

            /** Filter out values withing given set of ranges.
            * Example, give children and elders a rebate of 50%:
            *
            *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1/2});
            *
            * @param {(string|number|Date|Array)[][]} ranges
            * @param {{includeLowers: boolean, includeUppers: boolean}} options
            */
            inAnyRange: function (ranges, options) {
                var ctx = this._ctx;
                if (ranges.length === 0) return emptyCollection(this);
                if (!ranges.every(function (range) {
                    return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
                })) {
                    return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
                }
                var includeLowers = !options || options.includeLowers !== false; // Default to true
                var includeUppers = options && options.includeUppers === true; // Default to false

                function addRange(ranges, newRange) {
                    for (var i = 0, l = ranges.length; i < l; ++i) {
                        var range = ranges[i];
                        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                            range[0] = min(range[0], newRange[0]);
                            range[1] = max(range[1], newRange[1]);
                            break;
                        }
                    }
                    if (i === l) ranges.push(newRange);
                    return ranges;
                }

                var sortDirection = ascending;
                function rangeSorter(a, b) {
                    return sortDirection(a[0], b[0]);
                }

                // Join overlapping ranges
                var set;
                try {
                    set = ranges.reduce(addRange, []);
                    set.sort(rangeSorter);
                } catch (ex) {
                    return fail(this, INVALID_KEY_ARGUMENT);
                }

                var i = 0;
                var keyIsBeyondCurrentEntry = includeUppers ? function (key) {
                    return ascending(key, set[i][1]) > 0;
                } : function (key) {
                    return ascending(key, set[i][1]) >= 0;
                };

                var keyIsBeforeCurrentEntry = includeLowers ? function (key) {
                    return descending(key, set[i][0]) > 0;
                } : function (key) {
                    return descending(key, set[i][0]) >= 0;
                };

                function keyWithinCurrentRange(key) {
                    return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
                }

                var checkKey = keyIsBeyondCurrentEntry;

                var c = new ctx.collClass(this, function () {
                    return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
                });

                c._ondirectionchange = function (direction) {
                    if (direction === "next") {
                        checkKey = keyIsBeyondCurrentEntry;
                        sortDirection = ascending;
                    } else {
                        checkKey = keyIsBeforeCurrentEntry;
                        sortDirection = descending;
                    }
                    set.sort(rangeSorter);
                };

                c._addAlgorithm(function (cursor, advance, resolve) {
                    var key = cursor.key;
                    while (checkKey(key)) {
                        // The cursor has passed beyond this key. Check next.
                        ++i;
                        if (i === set.length) {
                            // There is no next. Stop searching.
                            advance(resolve);
                            return false;
                        }
                    }
                    if (keyWithinCurrentRange(key)) {
                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.
                        return true;
                    } else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {
                        // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.
                        // Continue to next key but don't include this one.
                        return false;
                    } else {
                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.
                        advance(function () {
                            if (sortDirection === ascending) cursor.continue(set[i][0]);else cursor.continue(set[i][1]);
                        });
                        return false;
                    }
                });
                return c;
            },
            startsWithAnyOf: function () {
                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);

                if (!set.every(function (s) {
                    return typeof s === 'string';
                })) {
                    return fail(this, "startsWithAnyOf() only works with strings");
                }
                if (set.length === 0) return emptyCollection(this);

                return this.inAnyRange(set.map(function (str) {
                    return [str, str + maxString];
                }));
            }
        };
    });

    //
    //
    //
    // Collection Class
    //
    //
    //
    function Collection(whereClause, keyRangeGenerator) {
        /// <summary>
        ///
        /// </summary>
        /// <param name="whereClause" type="WhereClause">Where clause instance</param>
        /// <param name="keyRangeGenerator" value="function(){ return IDBKeyRange.bound(0,1);}" optional="true"></param>
        var keyRange = null,
            error = null;
        if (keyRangeGenerator) try {
            keyRange = keyRangeGenerator();
        } catch (ex) {
            error = ex;
        }

        var whereCtx = whereClause._ctx,
            table = whereCtx.table;
        this._ctx = {
            table: table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true, // True if a replayFilter is just a filter that performs a "limit" operation (or none at all)
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error: error, // If set, any promise must be rejected with this error
            or: whereCtx.or,
            valueMapper: table.hook.reading.fire
        };
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }

    props(Collection.prototype, function () {

        //
        // Collection Private Functions
        //

        function addFilter(ctx, fn) {
            ctx.filter = combine(ctx.filter, fn);
        }

        function addReplayFilter(ctx, factory, isLimitFilter) {
            var curr = ctx.replayFilter;
            ctx.replayFilter = curr ? function () {
                return combine(curr(), factory());
            } : factory;
            ctx.justLimit = isLimitFilter && !curr;
        }

        function addMatchFilter(ctx, fn) {
            ctx.isMatch = combine(ctx.isMatch, fn);
        }

        /** @param ctx {
         *      isPrimKey: boolean,
         *      table: Table,
         *      index: string
         * }
         * @param store IDBObjectStore
         **/
        function getIndexOrStore(ctx, store) {
            if (ctx.isPrimKey) return store;
            var indexSpec = ctx.table.schema.idxByName[ctx.index];
            if (!indexSpec) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + store.name + " is not indexed");
            return store.index(indexSpec.name);
        }

        /** @param ctx {
         *      isPrimKey: boolean,
         *      table: Table,
         *      index: string,
         *      keysOnly: boolean,
         *      range?: IDBKeyRange,
         *      dir: "next" | "prev"
         * }
         */
        function openCursor(ctx, store) {
            var idxOrStore = getIndexOrStore(ctx, store);
            return ctx.keysOnly && 'openKeyCursor' in idxOrStore ? idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) : idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);
        }

        function iter(ctx, fn, resolve, reject, idbstore) {
            var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
            if (!ctx.or) {
                iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);
            } else (function () {
                var set = {};
                var resolved = 0;

                function resolveboth() {
                    if (++resolved === 2) resolve(); // Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.
                }

                function union(item, cursor, advance) {
                    if (!filter || filter(cursor, advance, resolveboth, reject)) {
                        var key = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string
                        if (!hasOwn(set, key)) {
                            set[key] = true;
                            fn(item, cursor, advance);
                        }
                    }
                }

                ctx.or._iterate(union, resolveboth, reject, idbstore);
                iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);
            })();
        }
        function getInstanceTemplate(ctx) {
            return ctx.table.schema.instanceTemplate;
        }

        return {

            //
            // Collection Protected Functions
            //

            _read: function (fn, cb) {
                var ctx = this._ctx;
                if (ctx.error) return ctx.table._trans(null, function rejector(resolve, reject) {
                    reject(ctx.error);
                });else return ctx.table._idbstore(READONLY, fn).then(cb);
            },
            _write: function (fn) {
                var ctx = this._ctx;
                if (ctx.error) return ctx.table._trans(null, function rejector(resolve, reject) {
                    reject(ctx.error);
                });else return ctx.table._idbstore(READWRITE, fn, "locked"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.
            },
            _addAlgorithm: function (fn) {
                var ctx = this._ctx;
                ctx.algorithm = combine(ctx.algorithm, fn);
            },

            _iterate: function (fn, resolve, reject, idbstore) {
                return iter(this._ctx, fn, resolve, reject, idbstore);
            },

            clone: function (props$$1) {
                var rv = Object.create(this.constructor.prototype),
                    ctx = Object.create(this._ctx);
                if (props$$1) extend(ctx, props$$1);
                rv._ctx = ctx;
                return rv;
            },

            raw: function () {
                this._ctx.valueMapper = null;
                return this;
            },

            //
            // Collection Public methods
            //

            each: function (fn) {
                var ctx = this._ctx;

                if (fake) {
                    var item = getInstanceTemplate(ctx),
                        primKeyPath = ctx.table.schema.primKey.keyPath,
                        key = getByKeyPath(item, ctx.index ? ctx.table.schema.idxByName[ctx.index].keyPath : primKeyPath),
                        primaryKey = getByKeyPath(item, primKeyPath);
                    fn(item, { key: key, primaryKey: primaryKey });
                }

                return this._read(function (resolve, reject, idbstore) {
                    iter(ctx, fn, resolve, reject, idbstore);
                });
            },

            count: function (cb) {
                if (fake) return Promise.resolve(0).then(cb);
                var ctx = this._ctx;

                if (isPlainKeyRange(ctx, true)) {
                    // This is a plain key range. We can use the count() method if the index.
                    return this._read(function (resolve, reject, idbstore) {
                        var idx = getIndexOrStore(ctx, idbstore);
                        var req = ctx.range ? idx.count(ctx.range) : idx.count();
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = function (e) {
                            resolve(Math.min(e.target.result, ctx.limit));
                        };
                    }, cb);
                } else {
                    // Algorithms, filters or expressions are applied. Need to count manually.
                    var count = 0;
                    return this._read(function (resolve, reject, idbstore) {
                        iter(ctx, function () {
                            ++count;return false;
                        }, function () {
                            resolve(count);
                        }, reject, idbstore);
                    }, cb);
                }
            },

            sortBy: function (keyPath, cb) {
                /// <param name="keyPath" type="String"></param>
                var parts = keyPath.split('.').reverse(),
                    lastPart = parts[0],
                    lastIndex = parts.length - 1;
                function getval(obj, i) {
                    if (i) return getval(obj[parts[i]], i - 1);
                    return obj[lastPart];
                }
                var order = this._ctx.dir === "next" ? 1 : -1;

                function sorter(a, b) {
                    var aVal = getval(a, lastIndex),
                        bVal = getval(b, lastIndex);
                    return aVal < bVal ? -order : aVal > bVal ? order : 0;
                }
                return this.toArray(function (a) {
                    return a.sort(sorter);
                }).then(cb);
            },

            toArray: function (cb) {
                var ctx = this._ctx;
                return this._read(function (resolve, reject, idbstore) {
                    fake && resolve([getInstanceTemplate(ctx)]);
                    if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                        // Special optimation if we could use IDBObjectStore.getAll() or
                        // IDBKeyRange.getAll():
                        var readingHook = ctx.table.hook.reading.fire;
                        var idxOrStore = getIndexOrStore(ctx, idbstore);
                        var req = ctx.limit < Infinity ? idxOrStore.getAll(ctx.range, ctx.limit) : idxOrStore.getAll(ctx.range);
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = readingHook === mirror ? eventSuccessHandler(resolve) : wrap(eventSuccessHandler(function (res) {
                            try {
                                resolve(res.map(readingHook));
                            } catch (e) {
                                reject(e);
                            }
                        }));
                    } else {
                        // Getting array through a cursor.
                        var a = [];
                        iter(ctx, function (item) {
                            a.push(item);
                        }, function arrayComplete() {
                            resolve(a);
                        }, reject, idbstore);
                    }
                }, cb);
            },

            offset: function (offset) {
                var ctx = this._ctx;
                if (offset <= 0) return this;
                ctx.offset += offset; // For count()
                if (isPlainKeyRange(ctx)) {
                    addReplayFilter(ctx, function () {
                        var offsetLeft = offset;
                        return function (cursor, advance) {
                            if (offsetLeft === 0) return true;
                            if (offsetLeft === 1) {
                                --offsetLeft;return false;
                            }
                            advance(function () {
                                cursor.advance(offsetLeft);
                                offsetLeft = 0;
                            });
                            return false;
                        };
                    });
                } else {
                    addReplayFilter(ctx, function () {
                        var offsetLeft = offset;
                        return function () {
                            return --offsetLeft < 0;
                        };
                    });
                }
                return this;
            },

            limit: function (numRows) {
                this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()
                addReplayFilter(this._ctx, function () {
                    var rowsLeft = numRows;
                    return function (cursor, advance, resolve) {
                        if (--rowsLeft <= 0) advance(resolve); // Stop after this item has been included
                        return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.
                    };
                }, true);
                return this;
            },

            until: function (filterFunction, bIncludeStopEntry) {
                var ctx = this._ctx;
                fake && filterFunction(getInstanceTemplate(ctx));
                addFilter(this._ctx, function (cursor, advance, resolve) {
                    if (filterFunction(cursor.value)) {
                        advance(resolve);
                        return bIncludeStopEntry;
                    } else {
                        return true;
                    }
                });
                return this;
            },

            first: function (cb) {
                return this.limit(1).toArray(function (a) {
                    return a[0];
                }).then(cb);
            },

            last: function (cb) {
                return this.reverse().first(cb);
            },

            filter: function (filterFunction) {
                /// <param name="jsFunctionFilter" type="Function">function(val){return true/false}</param>
                fake && filterFunction(getInstanceTemplate(this._ctx));
                addFilter(this._ctx, function (cursor) {
                    return filterFunction(cursor.value);
                });
                // match filters not used in Dexie.js but can be used by 3rd part libraries to test a
                // collection for a match without querying DB. Used by Dexie.Observable.
                addMatchFilter(this._ctx, filterFunction);
                return this;
            },

            and: function (filterFunction) {
                return this.filter(filterFunction);
            },

            or: function (indexName) {
                return new WhereClause(this._ctx.table, indexName, this);
            },

            reverse: function () {
                this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
                if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
                return this;
            },

            desc: function () {
                return this.reverse();
            },

            eachKey: function (cb) {
                var ctx = this._ctx;
                ctx.keysOnly = !ctx.isMatch;
                return this.each(function (val, cursor) {
                    cb(cursor.key, cursor);
                });
            },

            eachUniqueKey: function (cb) {
                this._ctx.unique = "unique";
                return this.eachKey(cb);
            },

            eachPrimaryKey: function (cb) {
                var ctx = this._ctx;
                ctx.keysOnly = !ctx.isMatch;
                return this.each(function (val, cursor) {
                    cb(cursor.primaryKey, cursor);
                });
            },

            keys: function (cb) {
                var ctx = this._ctx;
                ctx.keysOnly = !ctx.isMatch;
                var a = [];
                return this.each(function (item, cursor) {
                    a.push(cursor.key);
                }).then(function () {
                    return a;
                }).then(cb);
            },

            primaryKeys: function (cb) {
                var ctx = this._ctx;
                if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    // Special optimation if we could use IDBObjectStore.getAllKeys() or
                    // IDBKeyRange.getAllKeys():
                    return this._read(function (resolve, reject, idbstore) {
                        var idxOrStore = getIndexOrStore(ctx, idbstore);
                        var req = ctx.limit < Infinity ? idxOrStore.getAllKeys(ctx.range, ctx.limit) : idxOrStore.getAllKeys(ctx.range);
                        req.onerror = eventRejectHandler(reject);
                        req.onsuccess = eventSuccessHandler(resolve);
                    }).then(cb);
                }
                ctx.keysOnly = !ctx.isMatch;
                var a = [];
                return this.each(function (item, cursor) {
                    a.push(cursor.primaryKey);
                }).then(function () {
                    return a;
                }).then(cb);
            },

            uniqueKeys: function (cb) {
                this._ctx.unique = "unique";
                return this.keys(cb);
            },

            firstKey: function (cb) {
                return this.limit(1).keys(function (a) {
                    return a[0];
                }).then(cb);
            },

            lastKey: function (cb) {
                return this.reverse().firstKey(cb);
            },

            distinct: function () {
                var ctx = this._ctx,
                    idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
                if (!idx || !idx.multi) return this; // distinct() only makes differencies on multiEntry indexes.
                var set = {};
                addFilter(this._ctx, function (cursor) {
                    var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string
                    var found = hasOwn(set, strKey);
                    set[strKey] = true;
                    return !found;
                });
                return this;
            }
        };
    });

    //
    //
    // WriteableCollection Class
    //
    //
    function WriteableCollection() {
        Collection.apply(this, arguments);
    }

    derive(WriteableCollection).from(Collection).extend({

        //
        // WriteableCollection Public Methods
        //

        modify: function (changes) {
            var self = this,
                ctx = this._ctx,
                hook = ctx.table.hook,
                updatingHook = hook.updating.fire,
                deletingHook = hook.deleting.fire;

            fake && typeof changes === 'function' && changes.call({ value: ctx.table.schema.instanceTemplate }, ctx.table.schema.instanceTemplate);

            return this._write(function (resolve, reject, idbstore, trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)
                    if (updatingHook === nop && deletingHook === nop) {
                        // Noone cares about what is being changed. Just let the modifier function be the given argument as is.
                        modifyer = changes;
                    } else {
                        // People want to know exactly what is being modified or deleted.
                        // Let modifyer be a proxy function that finds out what changes the caller is actually doing
                        // and call the hooks accordingly!
                        modifyer = function (item) {
                            var origItem = deepClone(item); // Clone the item first so we can compare laters.
                            if (changes.call(this, item, this) === false) return false; // Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)
                            if (!hasOwn(this, "value")) {
                                // The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.
                                deletingHook.call(this, this.primKey, item, trans);
                            } else {
                                // No deletion. Check what was changed
                                var objectDiff = getObjectDiff(origItem, this.value);
                                var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);
                                if (additionalChanges) {
                                    // Hook want to apply additional modifications. Make sure to fullfill the will of the hook.
                                    item = this.value;
                                    keys(additionalChanges).forEach(function (keyPath) {
                                        setByKeyPath(item, keyPath, additionalChanges[keyPath]); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath
                                    });
                                }
                            }
                        };
                    }
                } else if (updatingHook === nop) {
                    // changes is a set of {keyPath: value} and no one is listening to the updating hook.
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i],
                                val = changes[keyPath];
                            if (getByKeyPath(item, keyPath) !== val) {
                                setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                } else {
                    // changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and
                    // allow it to add additional modifications to make.
                    var origChanges = changes;
                    changes = shallowClone(origChanges); // Let's work with a clone of the changes keyPath/value set so that we can restore it in case a hook extends it.
                    modifyer = function (item) {
                        var anythingModified = false;
                        var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);
                        if (additionalChanges) extend(changes, additionalChanges);
                        keys(changes).forEach(function (keyPath) {
                            var val = changes[keyPath];
                            if (getByKeyPath(item, keyPath) !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        });
                        if (additionalChanges) changes = shallowClone(origChanges); // Restore original changes for next iteration
                        return anythingModified;
                    };
                }

                var count = 0;
                var successCount = 0;
                var iterationComplete = false;
                var failures = [];
                var failKeys = [];
                var currentKey = null;

                function modifyItem(item, cursor) {
                    currentKey = cursor.primaryKey;
                    var thisContext = {
                        primKey: cursor.primaryKey,
                        value: item,
                        onsuccess: null,
                        onerror: null
                    };

                    function onerror(e) {
                        failures.push(e);
                        failKeys.push(thisContext.primKey);
                        checkFinished();
                        return true; // Catch these errors and let a final rejection decide whether or not to abort entire transaction
                    }

                    if (modifyer.call(thisContext, item, thisContext) !== false) {
                        // If a callback explicitely returns false, do not perform the update!
                        var bDelete = !hasOwn(thisContext, "value");
                        ++count;
                        tryCatch(function () {
                            var req = bDelete ? cursor.delete() : cursor.update(thisContext.value);
                            req._hookCtx = thisContext;
                            req.onerror = hookedEventRejectHandler(onerror);
                            req.onsuccess = hookedEventSuccessHandler(function () {
                                ++successCount;
                                checkFinished();
                            });
                        }, onerror);
                    } else if (thisContext.onsuccess) {
                        // Hook will expect either onerror or onsuccess to always be called!
                        thisContext.onsuccess(thisContext.value);
                    }
                }

                function doReject(e) {
                    if (e) {
                        failures.push(e);
                        failKeys.push(currentKey);
                    }
                    return reject(new ModifyError("Error modifying one or more objects", failures, successCount, failKeys));
                }

                function checkFinished() {
                    if (iterationComplete && successCount + failures.length === count) {
                        if (failures.length > 0) doReject();else resolve(successCount);
                    }
                }
                self.clone().raw()._iterate(modifyItem, function () {
                    iterationComplete = true;
                    checkFinished();
                }, doReject, idbstore);
            });
        },

        'delete': function () {
            var _this4 = this;

            var ctx = this._ctx,
                range = ctx.range,
                deletingHook = ctx.table.hook.deleting.fire,
                hasDeleteHook = deletingHook !== nop;
            if (!hasDeleteHook && isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || !range)) // if no range, we'll use clear().
                {
                    // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)
                    // For chromium, this is the way most optimized version.
                    // For IE/Edge, this could hang the indexedDB engine and make operating system instable
                    // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)
                    return this._write(function (resolve, reject, idbstore) {
                        // Our API contract is to return a count of deleted items, so we have to count() before delete().
                        var onerror = eventRejectHandler(reject),
                            countReq = range ? idbstore.count(range) : idbstore.count();
                        countReq.onerror = onerror;
                        countReq.onsuccess = function () {
                            var count = countReq.result;
                            tryCatch(function () {
                                var delReq = range ? idbstore.delete(range) : idbstore.clear();
                                delReq.onerror = onerror;
                                delReq.onsuccess = function () {
                                    return resolve(count);
                                };
                            }, function (err) {
                                return reject(err);
                            });
                        };
                    });
                }

            // Default version to use when collection is not a vanilla IDBKeyRange on the primary key.
            // Divide into chunks to not starve RAM.
            // If has delete hook, we will have to collect not just keys but also objects, so it will use
            // more memory and need lower chunk size.
            var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;

            return this._write(function (resolve, reject, idbstore, trans) {
                var totalCount = 0;
                // Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.
                var collection = _this4.clone({
                    keysOnly: !ctx.isMatch && !hasDeleteHook }) // load just keys (unless filter() or and() or deleteHook has subscribers)
                .distinct() // In case multiEntry is used, never delete same key twice because resulting count
                // would become larger than actual delete count.
                .limit(CHUNKSIZE).raw(); // Don't filter through reading-hooks (like mapped classes etc)

                var keysOrTuples = [];

                // We're gonna do things on as many chunks that are needed.
                // Use recursion of nextChunk function:
                var nextChunk = function () {
                    return collection.each(hasDeleteHook ? function (val, cursor) {
                        // Somebody subscribes to hook('deleting'). Collect all primary keys and their values,
                        // so that the hook can be called with its values in bulkDelete().
                        keysOrTuples.push([cursor.primaryKey, cursor.value]);
                    } : function (val, cursor) {
                        // No one subscribes to hook('deleting'). Collect only primary keys:
                        keysOrTuples.push(cursor.primaryKey);
                    }).then(function () {
                        // Chromium deletes faster when doing it in sort order.
                        hasDeleteHook ? keysOrTuples.sort(function (a, b) {
                            return ascending(a[0], b[0]);
                        }) : keysOrTuples.sort(ascending);
                        return bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);
                    }).then(function () {
                        var count = keysOrTuples.length;
                        totalCount += count;
                        keysOrTuples = [];
                        return count < CHUNKSIZE ? totalCount : nextChunk();
                    });
                };

                resolve(nextChunk());
            });
        }
    });

    //
    //
    //
    // ------------------------- Help functions ---------------------------
    //
    //
    //

    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }

    function setApiOnPlace(objs, tableNames, mode, dbschema) {
        tableNames.forEach(function (tableName) {
            var tableInstance = db._tableFactory(mode, dbschema[tableName]);
            objs.forEach(function (obj) {
                tableName in obj || (obj[tableName] = tableInstance);
            });
        });
    }

    function removeTablesApi(objs) {
        objs.forEach(function (obj) {
            for (var key in obj) {
                if (obj[key] instanceof Table) delete obj[key];
            }
        });
    }

    function iterate(req, filter, fn, resolve, reject, valueMapper) {

        // Apply valueMapper (hook('reading') or mappped class)
        var mappedFn = valueMapper ? function (x, c, a) {
            return fn(valueMapper(x), c, a);
        } : fn;
        // Wrap fn with PSD and microtick stuff from Promise.
        var wrappedFn = wrap(mappedFn, reject);

        if (!req.onerror) req.onerror = eventRejectHandler(reject);
        if (filter) {
            req.onsuccess = trycatcher(function filter_record() {
                var cursor = req.result;
                if (cursor) {
                    var c = function () {
                        cursor.continue();
                    };
                    if (filter(cursor, function (advancer) {
                        c = advancer;
                    }, resolve, reject)) wrappedFn(cursor.value, cursor, function (advancer) {
                        c = advancer;
                    });
                    c();
                } else {
                    resolve();
                }
            }, reject);
        } else {
            req.onsuccess = trycatcher(function filter_record() {
                var cursor = req.result;
                if (cursor) {
                    var c = function () {
                        cursor.continue();
                    };
                    wrappedFn(cursor.value, cursor, function (advancer) {
                        c = advancer;
                    });
                    c();
                } else {
                    resolve();
                }
            }, reject);
        }
    }

    function parseIndexSyntax(indexes) {
        /// <param name="indexes" type="String"></param>
        /// <returns type="Array" elementType="IndexSpec"></returns>
        var rv = [];
        indexes.split(',').forEach(function (index) {
            index = index.trim();
            var name = index.replace(/([&*]|\+\+)/g, ""); // Remove "&", "++" and "*"
            // Let keyPath of "[a+b]" be ["a","b"]:
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;

            rv.push(new IndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), /\./.test(index)));
        });
        return rv;
    }

    function cmp(key1, key2) {
        return indexedDB.cmp(key1, key2);
    }

    function min(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }

    function max(a, b) {
        return cmp(a, b) > 0 ? a : b;
    }

    function ascending(a, b) {
        return indexedDB.cmp(a, b);
    }

    function descending(a, b) {
        return indexedDB.cmp(b, a);
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }

    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function combine(filter1, filter2) {
        return filter1 ? filter2 ? function () {
            return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
    }

    function readGlobalSchema() {
        db.verno = idbdb.version / 10;
        db._dbSchema = globalSchema = {};
        dbStoreNames = slice(idbdb.objectStoreNames, 0);
        if (dbStoreNames.length === 0) return; // Database contains no stores.
        var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');
        dbStoreNames.forEach(function (storeName) {
            var store = trans.objectStore(storeName),
                keyPath = store.keyPath,
                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
            var primKey = new IndexSpec(keyPath, keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;
                var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);
                indexes.push(index);
            }
            globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});
        });
        setApiOnPlace([allTables, Transaction.prototype], keys(globalSchema), READWRITE, globalSchema);
    }

    function adjustToExistingIndexNames(schema, idbtrans) {
        /// <summary>
        /// Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db
        /// </summary>
        /// <param name="schema" type="Object">Map between name and TableSchema</param>
        /// <param name="idbtrans" type="IDBTransaction"></param>
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            hasGetAll = 'getAll' in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) indexSpec.name = indexName;
                }
            }
        }
    }

    function fireOnBlocked(ev) {
        db.on("blocked").fire(ev);
        // Workaround (not fully*) for missing "versionchange" event in IE,Edge and Safari:
        connections.filter(function (c) {
            return c.name === db.name && c !== db && !c._vcFired;
        }).map(function (c) {
            return c.on("versionchange").fire(ev);
        });
    }

    extend(this, {
        Collection: Collection,
        Table: Table,
        Transaction: Transaction,
        Version: Version,
        WhereClause: WhereClause,
        WriteableCollection: WriteableCollection,
        WriteableTable: WriteableTable
    });

    init();

    addons.forEach(function (fn) {
        fn(db);
    });
}

var fakeAutoComplete = function () {}; // Will never be changed. We just fake for the IDE that we change it (see doFakeAutoComplete())
var fake = false; // Will never be changed. We just fake for the IDE that we change it (see doFakeAutoComplete())

function parseType(type) {
    if (typeof type === 'function') {
        return new type();
    } else if (isArray(type)) {
        return [parseType(type[0])];
    } else if (type && typeof type === 'object') {
        var rv = {};
        applyStructure(rv, type);
        return rv;
    } else {
        return type;
    }
}

function applyStructure(obj, structure) {
    keys(structure).forEach(function (member) {
        var value = parseType(structure[member]);
        obj[member] = value;
    });
    return obj;
}

function eventSuccessHandler(done) {
    return function (ev) {
        done(ev.target.result);
    };
}

function hookedEventSuccessHandler(resolve) {
    // wrap() is needed when calling hooks because the rare scenario of:
    //  * hook does a db operation that fails immediately (IDB throws exception)
    //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.
    //    wrap() will also execute in a virtual tick.
    //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.
    //  * If this was the last event in the bulk, the promise will resolve after a physical tick
    //    and the transaction will have committed already.
    // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,
    // because it is always marked with _lib = true when created using Transaction._promise().
    return wrap(function (event) {
        var req = event.target,
            result = req.result,
            ctx = req._hookCtx,
            // Contains the hook error handler. Put here instead of closure to boost performance.
        hookSuccessHandler = ctx && ctx.onsuccess;
        hookSuccessHandler && hookSuccessHandler(result);
        resolve && resolve(result);
    }, resolve);
}

function eventRejectHandler(reject) {
    return function (event) {
        preventDefault(event);
        reject(event.target.error);
        return false;
    };
}

function hookedEventRejectHandler(reject) {
    return wrap(function (event) {
        // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.

        var req = event.target,
            err = req.error,
            ctx = req._hookCtx,
            // Contains the hook error handler. Put here instead of closure to boost performance.
        hookErrorHandler = ctx && ctx.onerror;
        hookErrorHandler && hookErrorHandler(err);
        preventDefault(event);
        reject(err);
        return false;
    });
}

function preventDefault(event) {
    if (event.stopPropagation) // IndexedDBShim doesnt support this on Safari 8 and below.
        event.stopPropagation();
    if (event.preventDefault) // IndexedDBShim doesnt support this on Safari 8 and below.
        event.preventDefault();
}

function globalDatabaseList(cb) {
    var val,
        localStorage = Dexie.dependencies.localStorage;
    if (!localStorage) return cb([]); // Envs without localStorage support
    try {
        val = JSON.parse(localStorage.getItem('Dexie.DatabaseNames') || "[]");
    } catch (e) {
        val = [];
    }
    if (cb(val)) {
        localStorage.setItem('Dexie.DatabaseNames', JSON.stringify(val));
    }
}

function awaitIterator(iterator) {
    var callNext = function (result) {
        return iterator.next(result);
    },
        doThrow = function (error) {
        return iterator.throw(error);
    },
        onSuccess = step(callNext),
        onError = step(doThrow);

    function step(getNext) {
        return function (val) {
            var next = getNext(val),
                value = next.value;

            return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
        };
    }

    return step(callNext)();
}

//
// IndexSpec struct
//
function IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {
    /// <param name="name" type="String"></param>
    /// <param name="keyPath" type="String"></param>
    /// <param name="unique" type="Boolean"></param>
    /// <param name="multi" type="Boolean"></param>
    /// <param name="auto" type="Boolean"></param>
    /// <param name="compound" type="Boolean"></param>
    /// <param name="dotted" type="Boolean"></param>
    this.name = name;
    this.keyPath = keyPath;
    this.unique = unique;
    this.multi = multi;
    this.auto = auto;
    this.compound = compound;
    this.dotted = dotted;
    var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && '[' + [].join.call(keyPath, '+') + ']';
    this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + keyPathSrc;
}

//
// TableSchema struct
//
function TableSchema(name, primKey, indexes, instanceTemplate) {
    /// <param name="name" type="String"></param>
    /// <param name="primKey" type="IndexSpec"></param>
    /// <param name="indexes" type="Array" elementType="IndexSpec"></param>
    /// <param name="instanceTemplate" type="Object"></param>
    this.name = name;
    this.primKey = primKey || new IndexSpec();
    this.indexes = indexes || [new IndexSpec()];
    this.instanceTemplate = instanceTemplate;
    this.mappedClass = null;
    this.idxByName = arrayToObject(indexes, function (index) {
        return [index.name, index];
    });
}

// Used in when defining dependencies later...
// (If IndexedDBShim is loaded, prefer it before standard indexedDB)
var idbshim = _global.idbModules && _global.idbModules.shimIndexedDB ? _global.idbModules : {};

function safariMultiStoreFix(storeNames) {
    return storeNames.length === 1 ? storeNames[0] : storeNames;
}

function getNativeGetDatabaseNamesFn(indexedDB) {
    var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);
    return fn && fn.bind(indexedDB);
}

// Export Error classes
props(Dexie, fullNameExceptions); // Dexie.XXXError = class XXXError {...};

//
// Static methods and properties
// 
props(Dexie, {

    //
    // Static delete() method.
    //
    delete: function (databaseName) {
        var db = new Dexie(databaseName),
            promise = db.delete();
        promise.onblocked = function (fn) {
            db.on("blocked", fn);
            return this;
        };
        return promise;
    },

    //
    // Static exists() method.
    //
    exists: function (name) {
        return new Dexie(name).open().then(function (db) {
            db.close();
            return true;
        }).catch(Dexie.NoSuchDatabaseError, function () {
            return false;
        });
    },

    //
    // Static method for retrieving a list of all existing databases at current host.
    //
    getDatabaseNames: function (cb) {
        return new Promise(function (resolve, reject) {
            var getDatabaseNames = getNativeGetDatabaseNamesFn(indexedDB);
            if (getDatabaseNames) {
                // In case getDatabaseNames() becomes standard, let's prepare to support it:
                var req = getDatabaseNames();
                req.onsuccess = function (event) {
                    resolve(slice(event.target.result, 0)); // Converst DOMStringList to Array<String>
                };
                req.onerror = eventRejectHandler(reject);
            } else {
                globalDatabaseList(function (val) {
                    resolve(val);
                    return false;
                });
            }
        }).then(cb);
    },

    defineClass: function (structure) {
        /// <summary>
        ///     Create a javascript constructor based on given template for which properties to expect in the class.
        ///     Any property that is a constructor function will act as a type. So {name: String} will be equal to {name: new String()}.
        /// </summary>
        /// <param name="structure">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also
        /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>

        // Default constructor able to copy given properties into this object.
        function Class(properties) {
            /// <param name="properties" type="Object" optional="true">Properties to initialize object with.
            /// </param>
            properties ? extend(this, properties) : fake && applyStructure(this, structure);
        }
        return Class;
    },

    applyStructure: applyStructure,

    ignoreTransaction: function (scopeFunc) {
        // In case caller is within a transaction but needs to create a separate transaction.
        // Example of usage:
        //
        // Let's say we have a logger function in our app. Other application-logic should be unaware of the
        // logger function and not need to include the 'logentries' table in all transaction it performs.
        // The logging should always be done in a separate transaction and not be dependant on the current
        // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.
        //
        //     Dexie.ignoreTransaction(function() {
        //         db.logentries.add(newLogEntry);
        //     });
        //
        // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction
        // in current Promise-scope.
        //
        // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an
        // API for this because
        //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().
        //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().
        //  3) setImmediate() is not supported in the ES standard.
        //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.
        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.
        scopeFunc(); // No need to change scope because there is no ongoing transaction.
    },

    vip: function (fn) {
        // To be used by subscribers to the on('ready') event.
        // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.
        // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD
        // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since
        // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.
        // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()
        // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by
        // the caller will not resolve until database is opened.
        return newScope(function () {
            PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.
            return fn();
        });
    },

    async: function (generatorFn) {
        return function () {
            try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
                return rv;
            } catch (e) {
                return rejection(e);
            }
        };
    },

    spawn: function (generatorFn, args, thiz) {
        try {
            var rv = awaitIterator(generatorFn.apply(thiz, args || []));
            if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);
            return rv;
        } catch (e) {
            return rejection(e);
        }
    },

    // Dexie.currentTransaction property
    currentTransaction: {
        get: function () {
            return PSD.trans || null;
        }
    },

    // Export our Promise implementation since it can be handy as a standalone Promise implementation
    Promise: Promise,

    // Dexie.debug proptery:
    // Dexie.debug = false
    // Dexie.debug = true
    // Dexie.debug = "dexie" - don't hide dexie's stack frames.
    debug: {
        get: function () {
            return debug;
        },
        set: function (value) {
            setDebug(value, value === 'dexie' ? function () {
                return true;
            } : dexieStackFrameFilter);
        }
    },

    // Export our derive/extend/override methodology
    derive: derive,
    extend: extend,
    props: props,
    override: override,
    // Export our Events() function - can be handy as a toolkit
    Events: Events,
    events: { get: deprecated(function () {
            return Events;
        }) }, // Backward compatible lowercase version.
    // Utilities
    getByKeyPath: getByKeyPath,
    setByKeyPath: setByKeyPath,
    delByKeyPath: delByKeyPath,
    shallowClone: shallowClone,
    deepClone: deepClone,
    getObjectDiff: getObjectDiff,
    asap: asap,
    maxKey: maxKey,
    // Addon registry
    addons: [],
    // Global DB connection list
    connections: connections,

    MultiModifyError: exceptions.Modify, // Backward compatibility 0.9.8. Deprecate.
    errnames: errnames,

    // Export other static classes
    IndexSpec: IndexSpec,
    TableSchema: TableSchema,

    //
    // Dependencies
    //
    // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.
    //
    // In node.js, however, these properties must be set "manually" before instansiating a new Dexie().
    // For node.js, you need to require indexeddb-js or similar and then set these deps.
    //
    dependencies: {
        // Required:
        indexedDB: idbshim.shimIndexedDB || _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
        IDBKeyRange: idbshim.IDBKeyRange || _global.IDBKeyRange || _global.webkitIDBKeyRange
    },

    // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.
    semVer: DEXIE_VERSION,
    version: DEXIE_VERSION.split('.').map(function (n) {
        return parseInt(n);
    }).reduce(function (p, c, i) {
        return p + c / Math.pow(10, i * 2);
    }),
    fakeAutoComplete: fakeAutoComplete,

    // https://github.com/dfahlander/Dexie.js/issues/186
    // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return
    // x.default. Workaround: Set Dexie.default = Dexie.
    default: Dexie
});

tryCatch(function () {
    // Optional dependencies
    // localStorage
    Dexie.dependencies.localStorage = (typeof chrome !== "undefined" && chrome !== null ? chrome.storage : void 0) != null ? null : _global.localStorage;
});

// Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.
Promise.rejectionMapper = mapError;

// Fool IDE to improve autocomplete. Tested with Visual Studio 2013 and 2015.
doFakeAutoComplete(function () {
    Dexie.fakeAutoComplete = fakeAutoComplete = doFakeAutoComplete;
    Dexie.fake = fake = true;
});

return Dexie;

})));
//# sourceMappingURL=dexie.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/event-lite/event-lite.js":
/*!***********************************************!*\
  !*** ./node_modules/event-lite/event-lite.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */

function EventLite() {
  if (!(this instanceof EventLite)) return new EventLite();
}

(function(EventLite) {
  // export the class for node.js
  if (true) module.exports = EventLite;

  // property name to hold listeners
  var LISTENERS = "listeners";

  // methods to export
  var methods = {
    on: on,
    once: once,
    off: off,
    emit: emit
  };

  // mixin to self
  mixin(EventLite.prototype);

  // export mixin function
  EventLite.mixin = mixin;

  /**
   * Import on(), once(), off() and emit() methods into target object.
   *
   * @function EventLite.mixin
   * @param target {Prototype}
   */

  function mixin(target) {
    for (var key in methods) {
      target[key] = methods[key];
    }
    return target;
  }

  /**
   * Add an event listener.
   *
   * @function EventLite.prototype.on
   * @param type {string}
   * @param func {Function}
   * @returns {EventLite} Self for method chaining
   */

  function on(type, func) {
    getListeners(this, type).push(func);
    return this;
  }

  /**
   * Add one-time event listener.
   *
   * @function EventLite.prototype.once
   * @param type {string}
   * @param func {Function}
   * @returns {EventLite} Self for method chaining
   */

  function once(type, func) {
    var that = this;
    wrap.originalListener = func;
    getListeners(that, type).push(wrap);
    return that;

    function wrap() {
      off.call(that, type, wrap);
      func.apply(this, arguments);
    }
  }

  /**
   * Remove an event listener.
   *
   * @function EventLite.prototype.off
   * @param [type] {string}
   * @param [func] {Function}
   * @returns {EventLite} Self for method chaining
   */

  function off(type, func) {
    var that = this;
    var listners;
    if (!arguments.length) {
      delete that[LISTENERS];
    } else if (!func) {
      listners = that[LISTENERS];
      if (listners) {
        delete listners[type];
        if (!Object.keys(listners).length) return off.call(that);
      }
    } else {
      listners = getListeners(that, type, true);
      if (listners) {
        listners = listners.filter(ne);
        if (!listners.length) return off.call(that, type);
        that[LISTENERS][type] = listners;
      }
    }
    return that;

    function ne(test) {
      return test !== func && test.originalListener !== func;
    }
  }

  /**
   * Dispatch (trigger) an event.
   *
   * @function EventLite.prototype.emit
   * @param type {string}
   * @param [value] {*}
   * @returns {boolean} True when a listener received the event
   */

  function emit(type, value) {
    var that = this;
    var listeners = getListeners(that, type, true);
    if (!listeners) return false;
    var arglen = arguments.length;
    if (arglen === 1) {
      listeners.forEach(zeroarg);
    } else if (arglen === 2) {
      listeners.forEach(onearg);
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      listeners.forEach(moreargs);
    }
    return !!listeners.length;

    function zeroarg(func) {
      func.call(that);
    }

    function onearg(func) {
      func.call(that, value);
    }

    function moreargs(func) {
      func.apply(that, args);
    }
  }

  /**
   * @ignore
   */

  function getListeners(that, type, readonly) {
    if (readonly && !that[LISTENERS]) return;
    var listeners = that[LISTENERS] || (that[LISTENERS] = {});
    return listeners[type] || (listeners[type] = []);
  }

})(EventLite);


/***/ }),

/***/ "./node_modules/gaussian/lib/box-muller.js":
/*!*************************************************!*\
  !*** ./node_modules/gaussian/lib/box-muller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** 
 * Box-Muller implementation
 * https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
 */

(function(exports){
  const PRECISION = 1e9;
  const _2PI = Math.PI * 2;

  /**
   *
   * @param {number} mean
   * @param {number} std
   * @param randFn - an optional function that returns a float between 0 (inclusive) and 1
   * (exclusive).  Use this if you want to pass in a random number generator other than
   * Math.random().
   * @returns {number}
   */
  function generateGaussian(mean,std, randFn = null){
    var u1;
    var u2;
    if (randFn) {
      u1 = randFn();
      u2 = randFn();
    }
    else {
      u1 = Math.random();
      u2 = Math.random();
    }
    
    var z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(_2PI * u2);
    var z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(_2PI * u2);

    return z0 * std + mean;
  }

  exports(generateGaussian)
})
( true
    ? function(e) { module.exports = e; }
    // istanbul ignore next
    : undefined);
  


/***/ }),

/***/ "./node_modules/gaussian/lib/gaussian.js":
/*!***********************************************!*\
  !*** ./node_modules/gaussian/lib/gaussian.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(exports) {

  const generateGaussian = __webpack_require__(/*! ./box-muller */ "./node_modules/gaussian/lib/box-muller.js");

  // Complementary error function
  // From Numerical Recipes in C 2e p221
  var erfc = function(x) {
    var z = Math.abs(x);
    var t = 1 / (1 + z / 2);
    var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +
            t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +
            t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +
            t * (-0.82215223 + t * 0.17087277)))))))))
    return x >= 0 ? r : 2 - r;
  };

  // Inverse complementary error function
  // From Numerical Recipes 3e p265
  var ierfc = function(x) {
    if (x >= 2) { return -100; }
    if (x <= 0) { return 100; }

    var xx = (x < 1) ? x : 2 - x;
    var t = Math.sqrt(-2 * Math.log(xx / 2));

    var r = -0.70711 * ((2.30753 + t * 0.27061) /
            (1 + t * (0.99229 + t * 0.04481)) - t);

    for (var j = 0; j < 2; j++) {
      var err = erfc(r) - xx;
      r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);
    }

    return (x < 1) ? r : -r;
  };

  // Models the normal distribution
  var Gaussian = function(mean, variance) {
    if (variance <= 0) {
      throw new Error('Variance must be > 0 (but was ' + variance + ')');
    }
    this.mean = mean;
    this.variance = variance;
    this.standardDeviation = Math.sqrt(variance);
  }

  // Probability density function
  Gaussian.prototype.pdf = function(x) {
    var m = this.standardDeviation * Math.sqrt(2 * Math.PI);
    var e = Math.exp(-Math.pow(x - this.mean, 2) / (2 * this.variance));
    return e / m;
  };

  // Cumulative density function
  Gaussian.prototype.cdf = function(x) {
    return 0.5 * erfc(-(x - this.mean) / (this.standardDeviation * Math.sqrt(2)));
  };

  // Percent point function
  Gaussian.prototype.ppf = function(x) {
    return this.mean - this.standardDeviation * Math.sqrt(2) * ierfc(2 * x);
  };

  // Product distribution of this and d (scale for constant)
  Gaussian.prototype.mul = function(d) {
    if (typeof(d) === "number") {
      return this.scale(d);
    }
    var precision = 1 / this.variance;
    var dprecision = 1 / d.variance;
    return fromPrecisionMean(
        precision + dprecision, 
        precision * this.mean + dprecision * d.mean);
  };

  // Quotient distribution of this and d (scale for constant)
  Gaussian.prototype.div = function(d) {
    if (typeof(d) === "number") {
      return this.scale(1 / d);
    }
    var precision = 1 / this.variance;
    var dprecision = 1 / d.variance;
    return fromPrecisionMean(
        precision - dprecision, 
        precision * this.mean - dprecision * d.mean);
  };

  // Addition of this and d
  Gaussian.prototype.add = function(d) {
    return gaussian(this.mean + d.mean, this.variance + d.variance);
  };

  // Subtraction of this and d
  Gaussian.prototype.sub = function(d) {
    return gaussian(this.mean - d.mean, this.variance + d.variance);
  };

  // Scale this by constant c
  Gaussian.prototype.scale = function(c) {
    return gaussian(this.mean * c, this.variance * c * c);
  };


  /**
   * Generate [num] random samples
   * @param {number} num
   * @param randFn - an optional function that returns a float between 0 (inclusive) and 1
   * (exclusive).  Use this if you want to pass in a random number generator other than
   * Math.random().
   * @returns {number[]}
   */
  Gaussian.prototype.random = function(num, randFn = null){
    let mean = this.mean;
    let std = this.standardDeviation;
    return Array(num).fill(0).map(() => {
      return generateGaussian(mean,std, randFn)
    })
  };

  var gaussian = function(mean, variance) {
    return new Gaussian(mean, variance);
  };

  var fromPrecisionMean = function(precision, precisionmean) {
    return gaussian(precisionmean / precision, 1 / precision);
  };

  exports(gaussian);
})
( true
    ? function(e) { module.exports = e; }
    // istanbul ignore next
    : undefined);



/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/int64-buffer/int64-buffer.js":
/*!***************************************************!*\
  !*** ./node_modules/int64-buffer/int64-buffer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// int64-buffer.js

/*jshint -W018 */ // Confusing use of '!'.
/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.
/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?

var Uint64BE, Int64BE, Uint64LE, Int64LE;

!function(exports) {
  // constants

  var UNDEFINED = "undefined";
  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;
  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;
  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;
  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
  var isArray = Array.isArray || _isArray;
  var BIT32 = 4294967296;
  var BIT24 = 16777216;

  // storage class

  var storage; // Array;

  // generate classes

  Uint64BE = factory("Uint64BE", true, true);
  Int64BE = factory("Int64BE", true, false);
  Uint64LE = factory("Uint64LE", false, true);
  Int64LE = factory("Int64LE", false, false);

  // class factory

  function factory(name, bigendian, unsigned) {
    var posH = bigendian ? 0 : 4;
    var posL = bigendian ? 4 : 0;
    var pos0 = bigendian ? 0 : 3;
    var pos1 = bigendian ? 1 : 2;
    var pos2 = bigendian ? 2 : 1;
    var pos3 = bigendian ? 3 : 0;
    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
    var proto = Int64.prototype;
    var isName = "is" + name;
    var _isInt64 = "_" + isName;

    // properties
    proto.buffer = void 0;
    proto.offset = 0;
    proto[_isInt64] = true;

    // methods
    proto.toNumber = toNumber;
    proto.toString = toString;
    proto.toJSON = toNumber;
    proto.toArray = toArray;

    // add .toBuffer() method only when Buffer available
    if (BUFFER) proto.toBuffer = toBuffer;

    // add .toArrayBuffer() method only when Uint8Array available
    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;

    // isUint64BE, isInt64BE
    Int64[isName] = isInt64;

    // CommonJS
    exports[name] = Int64;

    return Int64;

    // constructor
    function Int64(buffer, offset, value, raddix) {
      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);
      return init(this, buffer, offset, value, raddix);
    }

    // isUint64BE, isInt64BE
    function isInt64(b) {
      return !!(b && b[_isInt64]);
    }

    // initializer
    function init(that, buffer, offset, value, raddix) {
      if (UINT8ARRAY && ARRAYBUFFER) {
        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);
        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
      }

      // Int64BE() style
      if (!buffer && !offset && !value && !storage) {
        // shortcut to initialize with zero
        that.buffer = newArray(ZERO, 0);
        return;
      }

      // Int64BE(value, raddix) style
      if (!isValidBuffer(buffer, offset)) {
        var _storage = storage || Array;
        raddix = offset;
        value = buffer;
        offset = 0;
        buffer = new _storage(8);
      }

      that.buffer = buffer;
      that.offset = offset |= 0;

      // Int64BE(buffer, offset) style
      if (UNDEFINED === typeof value) return;

      // Int64BE(buffer, offset, value, raddix) style
      if ("string" === typeof value) {
        fromString(buffer, offset, value, raddix || 10);
      } else if (isValidBuffer(value, raddix)) {
        fromArray(buffer, offset, value, raddix);
      } else if ("number" === typeof raddix) {
        writeInt32(buffer, offset + posH, value); // high
        writeInt32(buffer, offset + posL, raddix); // low
      } else if (value > 0) {
        fromPositive(buffer, offset, value); // positive
      } else if (value < 0) {
        fromNegative(buffer, offset, value); // negative
      } else {
        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others
      }
    }

    function fromString(buffer, offset, str, raddix) {
      var pos = 0;
      var len = str.length;
      var high = 0;
      var low = 0;
      if (str[0] === "-") pos++;
      var sign = pos;
      while (pos < len) {
        var chr = parseInt(str[pos++], raddix);
        if (!(chr >= 0)) break; // NaN
        low = low * raddix + chr;
        high = high * raddix + Math.floor(low / BIT32);
        low %= BIT32;
      }
      if (sign) {
        high = ~high;
        if (low) {
          low = BIT32 - low;
        } else {
          high++;
        }
      }
      writeInt32(buffer, offset + posH, high);
      writeInt32(buffer, offset + posL, low);
    }

    function toNumber() {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      if (!unsigned) high |= 0; // a trick to get signed
      return high ? (high * BIT32 + low) : low;
    }

    function toString(radix) {
      var buffer = this.buffer;
      var offset = this.offset;
      var high = readInt32(buffer, offset + posH);
      var low = readInt32(buffer, offset + posL);
      var str = "";
      var sign = !unsigned && (high & 0x80000000);
      if (sign) {
        high = ~high;
        low = BIT32 - low;
      }
      radix = radix || 10;
      while (1) {
        var mod = (high % radix) * BIT32 + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod / radix);
        str = (mod % radix).toString(radix) + str;
        if (!high && !low) break;
      }
      if (sign) {
        str = "-" + str;
      }
      return str;
    }

    function writeInt32(buffer, offset, value) {
      buffer[offset + pos3] = value & 255;
      value = value >> 8;
      buffer[offset + pos2] = value & 255;
      value = value >> 8;
      buffer[offset + pos1] = value & 255;
      value = value >> 8;
      buffer[offset + pos0] = value & 255;
    }

    function readInt32(buffer, offset) {
      return (buffer[offset + pos0] * BIT24) +
        (buffer[offset + pos1] << 16) +
        (buffer[offset + pos2] << 8) +
        buffer[offset + pos3];
    }
  }

  function toArray(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = null; // Array
    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;
    return newArray(buffer, offset);
  }

  function toBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    storage = BUFFER;
    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;
    var dest = new BUFFER(8);
    fromArray(dest, 0, buffer, offset);
    return dest;
  }

  function toArrayBuffer(raw) {
    var buffer = this.buffer;
    var offset = this.offset;
    var arrbuf = buffer.buffer;
    storage = UINT8ARRAY;
    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;
    var dest = new UINT8ARRAY(8);
    fromArray(dest, 0, buffer, offset);
    return dest.buffer;
  }

  function isValidBuffer(buffer, offset) {
    var len = buffer && buffer.length;
    offset |= 0;
    return len && (offset + 8 <= len) && ("string" !== typeof buffer[offset]);
  }

  function fromArray(destbuf, destoff, srcbuf, srcoff) {
    destoff |= 0;
    srcoff |= 0;
    for (var i = 0; i < 8; i++) {
      destbuf[destoff++] = srcbuf[srcoff++] & 255;
    }
  }

  function newArray(buffer, offset) {
    return Array.prototype.slice.call(buffer, offset, offset + 8);
  }

  function fromPositiveBE(buffer, offset, value) {
    var pos = offset + 8;
    while (pos > offset) {
      buffer[--pos] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeBE(buffer, offset, value) {
    var pos = offset + 8;
    value++;
    while (pos > offset) {
      buffer[--pos] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  function fromPositiveLE(buffer, offset, value) {
    var end = offset + 8;
    while (offset < end) {
      buffer[offset++] = value & 255;
      value /= 256;
    }
  }

  function fromNegativeLE(buffer, offset, value) {
    var end = offset + 8;
    value++;
    while (offset < end) {
      buffer[offset++] = ((-value) & 255) ^ 255;
      value /= 256;
    }
  }

  // https://github.com/retrofox/is-array
  function _isArray(val) {
    return !!val && "[object Array]" == Object.prototype.toString.call(val);
  }

}( true && typeof exports.nodeName !== 'string' ? exports : (this || {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            var db = openreq.result;
            db.onversionchange = function (e) {
                // Triggered when the database is modified (e.g. adding an objectStore) or
                // deleted (even when initiated by other sessions in different tabs).
                // Closing the connection here prevents those operations from being blocked.
                // If the database is accessed again later by this instance, the connection
                // will be reopened or the database recreated as needed.
                e.target.close();
            };
            resolve(db);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(req.error);
                    };

                    req.onblocked = function () {
                        // Closing all open connections in onversionchange handler should prevent this situation, but if
                        // we do get here, it just means the request remains pending - eventually it will succeed or error
                        console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lz-string/libs/lz-string.js":
/*!**************************************************!*\
  !*** ./node_modules/lz-string/libs/lz-string.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.5
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    undefined
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        var flags = null,
            parsedParts = false,
            isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            isNowValid =
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidEra &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        } else {
            return isNowValid;
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {
        D: 'date',
        dates: 'date',
        date: 'date',
        d: 'day',
        days: 'day',
        day: 'day',
        e: 'weekday',
        weekdays: 'weekday',
        weekday: 'weekday',
        E: 'isoWeekday',
        isoweekdays: 'isoWeekday',
        isoweekday: 'isoWeekday',
        DDD: 'dayOfYear',
        dayofyears: 'dayOfYear',
        dayofyear: 'dayOfYear',
        h: 'hour',
        hours: 'hour',
        hour: 'hour',
        ms: 'millisecond',
        milliseconds: 'millisecond',
        millisecond: 'millisecond',
        m: 'minute',
        minutes: 'minute',
        minute: 'minute',
        M: 'month',
        months: 'month',
        month: 'month',
        Q: 'quarter',
        quarters: 'quarter',
        quarter: 'quarter',
        s: 'second',
        seconds: 'second',
        second: 'second',
        gg: 'weekYear',
        weekyears: 'weekYear',
        weekyear: 'weekYear',
        GG: 'isoWeekYear',
        isoweekyears: 'isoWeekYear',
        isoweekyear: 'isoWeekYear',
        w: 'week',
        weeks: 'week',
        week: 'week',
        W: 'isoWeek',
        isoweeks: 'isoWeek',
        isoweek: 'isoWeek',
        y: 'year',
        years: 'year',
        year: 'year',
    };

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1,
    };

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        match1to2NoLeadingZero = /^[1-9]\d?/, //         1-99
        match1to2HasZero = /^([1-9]\d|\d)/, //           0-99
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        if (!mom.isValid()) {
            return NaN;
        }

        var d = mom._d,
            isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case 'Seconds':
                return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case 'Minutes':
                return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case 'Hours':
                return isUTC ? d.getUTCHours() : d.getHours();
            case 'Date':
                return isUTC ? d.getUTCDate() : d.getDate();
            case 'Day':
                return isUTC ? d.getUTCDay() : d.getDay();
            case 'Month':
                return isUTC ? d.getUTCMonth() : d.getMonth();
            case 'FullYear':
                return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
                return NaN; // Just in case
        }
    }

    function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;

        if (!mom.isValid() || isNaN(value)) {
            return;
        }

        d = mom._d;
        isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return void (isUTC
                    ? d.setUTCMilliseconds(value)
                    : d.setMilliseconds(value));
            case 'Seconds':
                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case 'Minutes':
                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case 'Hours':
                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case 'Date':
                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            // case 'Day': // Not real
            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
            // case 'Month': // Not used because we need to pass two variables
            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
            case 'FullYear':
                break; // See below ...
            default:
                return; // Just in case
        }

        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC
            ? d.setUTCFullYear(year, month, date)
            : d.setFullYear(year, month, date));
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // PARSING

    addRegexToken('M', match1to2, match1to2NoLeadingZero);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        var month = value,
            date = mom.date();

        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC
            ? mom._d.setUTCMonth(month, date)
            : mom._d.setMonth(month, date));
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            shortP,
            longP;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortP = regexEscape(this.monthsShort(mom, ''));
            longP = regexEscape(this.months(mom, ''));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // PARSING

    addRegexToken('w', match1to2, match1to2NoLeadingZero);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2, match1to2NoLeadingZero);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
              ? weekdays[m.day()]
              : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        var day = get(this, 'Day');
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2, match1to2HasZero);
    addRegexToken('h', match1to2, match1to2NoLeadingZero);
    addRegexToken('k', match1to2, match1to2NoLeadingZero);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        // Ensure name is available and function returns boolean
        return !!(name && name.match('^[^/\\\\]*$'));
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                !(function webpackMissingModule() { var e = new Error("Cannot find module 'undefined'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                          ? MINUTE
                          : a[SECOND] < 0 || a[SECOND] > 59
                            ? SECOND
                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                              ? MILLISECOND
                              : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
              ? 'lastWeek'
              : diff < 0
                ? 'lastDay'
                : diff < 1
                  ? 'sameDay'
                  : diff < 2
                    ? 'nextDay'
                    : diff < 7
                      ? 'nextWeek'
                      : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            erasName,
            erasAbbr,
            erasNarrow,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            erasName = regexEscape(eras[i].name);
            erasAbbr = regexEscape(eras[i].abbr);
            erasNarrow = regexEscape(eras[i].narrow);

            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday() + this.localeData()._week.dow,
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // PARSING

    addRegexToken('D', match1to2, match1to2NoLeadingZero);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // PARSING

    addRegexToken('m', match1to2, match1to2HasZero);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // PARSING

    addRegexToken('s', match1to2, match1to2HasZero);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                          ? 'st'
                          : b === 2
                            ? 'nd'
                            : b === 3
                              ? 'rd'
                              : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y'),
        valueOf$1 = asMilliseconds;

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.30.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser.js

exports.encode = __webpack_require__(/*! ./encode */ "./node_modules/msgpack-lite/lib/encode.js").encode;
exports.decode = __webpack_require__(/*! ./decode */ "./node_modules/msgpack-lite/lib/decode.js").decode;

exports.Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/msgpack-lite/lib/encoder.js").Encoder;
exports.Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/msgpack-lite/lib/decoder.js").Decoder;

exports.createCodec = __webpack_require__(/*! ./ext */ "./node_modules/msgpack-lite/lib/ext.js").createCodec;
exports.codec = __webpack_require__(/*! ./codec */ "./node_modules/msgpack-lite/lib/codec.js").codec;


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-global.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* globals Buffer */

module.exports =
  c(("undefined" !== typeof Buffer) && Buffer) ||
  c(this.Buffer) ||
  c(("undefined" !== typeof window) && window.Buffer) ||
  this.Buffer;

function c(B) {
  return B && B.isBuffer && B;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/buffer-lite.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// buffer-lite.js

var MAXBUFLEN = 8192;

exports.copy = copy;
exports.toString = toString;
exports.write = write;

/**
 * Buffer.prototype.write()
 *
 * @param string {String}
 * @param [offset] {Number}
 * @returns {Number}
 */

function write(string, offset) {
  var buffer = this;
  var index = offset || (offset |= 0);
  var length = string.length;
  var chr = 0;
  var i = 0;
  while (i < length) {
    chr = string.charCodeAt(i++);

    if (chr < 128) {
      buffer[index++] = chr;
    } else if (chr < 0x800) {
      // 2 bytes
      buffer[index++] = 0xC0 | (chr >>> 6);
      buffer[index++] = 0x80 | (chr & 0x3F);
    } else if (chr < 0xD800 || chr > 0xDFFF) {
      // 3 bytes
      buffer[index++] = 0xE0 | (chr  >>> 12);
      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
      buffer[index++] = 0x80 | (chr          & 0x3F);
    } else {
      // 4 bytes - surrogate pair
      chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;
      buffer[index++] = 0xF0 | (chr >>> 18);
      buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);
      buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
      buffer[index++] = 0x80 | (chr          & 0x3F);
    }
  }
  return index - offset;
}

/**
 * Buffer.prototype.toString()
 *
 * @param [encoding] {String} ignored
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {String}
 */

function toString(encoding, start, end) {
  var buffer = this;
  var index = start|0;
  if (!end) end = buffer.length;
  var string = '';
  var chr = 0;

  while (index < end) {
    chr = buffer[index++];
    if (chr < 128) {
      string += String.fromCharCode(chr);
      continue;
    }

    if ((chr & 0xE0) === 0xC0) {
      // 2 bytes
      chr = (chr & 0x1F) << 6 |
            (buffer[index++] & 0x3F);

    } else if ((chr & 0xF0) === 0xE0) {
      // 3 bytes
      chr = (chr & 0x0F)             << 12 |
            (buffer[index++] & 0x3F) << 6  |
            (buffer[index++] & 0x3F);

    } else if ((chr & 0xF8) === 0xF0) {
      // 4 bytes
      chr = (chr & 0x07)             << 18 |
            (buffer[index++] & 0x3F) << 12 |
            (buffer[index++] & 0x3F) << 6  |
            (buffer[index++] & 0x3F);
    }

    if (chr >= 0x010000) {
      // A surrogate pair
      chr -= 0x010000;

      string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
    } else {
      string += String.fromCharCode(chr);
    }
  }

  return string;
}

/**
 * Buffer.prototype.copy()
 *
 * @param target {Buffer}
 * @param [targetStart] {Number}
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {number}
 */

function copy(target, targetStart, start, end) {
  var i;
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (!targetStart) targetStart = 0;
  var len = end - start;

  if (target === this && start < targetStart && targetStart < end) {
    // descending
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    // ascending
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start];
    }
  }

  return len;
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-array.js

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");

var exports = module.exports = alloc(0);

exports.alloc = alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Array(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Array}
 */

function from(value) {
  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
    // TypedArray to Uint8Array
    value = Bufferish.Uint8Array.from(value);
  } else if (Bufferish.isArrayBuffer(value)) {
    // ArrayBuffer to Uint8Array
    value = new Uint8Array(value);
  } else if (typeof value === "string") {
    // String to Array
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  // Array-like to Array
  return Array.prototype.slice.call(value);
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-buffer.js":
/*!***********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-buffer.js

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var Buffer = Bufferish.global;

var exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];

exports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Buffer(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Buffer}
 */

function from(value) {
  if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
    // TypedArray to Uint8Array
    value = Bufferish.Uint8Array.from(value);
  } else if (Bufferish.isArrayBuffer(value)) {
    // ArrayBuffer to Uint8Array
    value = new Uint8Array(value);
  } else if (typeof value === "string") {
    // String to Buffer
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  // Array-like to Buffer
  if (Buffer.from && Buffer.from.length !== 1) {
    return Buffer.from(value); // node v6+
  } else {
    return new Buffer(value); // node v4
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-proto.js":
/*!**********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-proto.js

/* jshint eqnull:true */

var BufferLite = __webpack_require__(/*! ./buffer-lite */ "./node_modules/msgpack-lite/lib/buffer-lite.js");

exports.copy = copy;
exports.slice = slice;
exports.toString = toString;
exports.write = gen("write");

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var Buffer = Bufferish.global;

var isBufferShim = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
var brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;

/**
 * @param target {Buffer|Uint8Array|Array}
 * @param [targetStart] {Number}
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function copy(target, targetStart, start, end) {
  var thisIsBuffer = Bufferish.isBuffer(this);
  var targetIsBuffer = Bufferish.isBuffer(target);
  if (thisIsBuffer && targetIsBuffer) {
    // Buffer to Buffer
    return this.copy(target, targetStart, start, end);
  } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&
    Bufferish.isView(this) && Bufferish.isView(target)) {
    // Uint8Array to Uint8Array (except for minor some browsers)
    var buffer = (start || end != null) ? slice.call(this, start, end) : this;
    target.set(buffer, targetStart);
    return buffer.length;
  } else {
    // other cases
    return BufferLite.copy.call(this, target, targetStart, start, end);
  }
}

/**
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function slice(start, end) {
  // for Buffer, Uint8Array (except for minor some browsers) and Array
  var f = this.slice || (!brokenTypedArray && this.subarray);
  if (f) return f.call(this, start, end);

  // Uint8Array (for minor some browsers)
  var target = Bufferish.alloc.call(this, end - start);
  copy.call(this, target, 0, start, end);
  return target;
}

/**
 * Buffer.prototype.toString()
 *
 * @param [encoding] {String} ignored
 * @param [start] {Number}
 * @param [end] {Number}
 * @returns {String}
 */

function toString(encoding, start, end) {
  var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;
  return f.apply(this, arguments);
}

/**
 * @private
 */

function gen(method) {
  return wrap;

  function wrap() {
    var f = this[method] || BufferLite[method];
    return f.apply(this, arguments);
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js":
/*!***************************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// bufferish-uint8array.js

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");

var exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];

exports.alloc = alloc;
exports.concat = Bufferish.concat;
exports.from = from;

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return new Uint8Array(size);
}

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Uint8Array}
 */

function from(value) {
  if (Bufferish.isView(value)) {
    // TypedArray to ArrayBuffer
    var byteOffset = value.byteOffset;
    var byteLength = value.byteLength;
    value = value.buffer;
    if (value.byteLength !== byteLength) {
      if (value.slice) {
        value = value.slice(byteOffset, byteOffset + byteLength);
      } else {
        // Android 4.1 does not have ArrayBuffer.prototype.slice
        value = new Uint8Array(value);
        if (value.byteLength !== byteLength) {
          // TypedArray to ArrayBuffer to Uint8Array to Array
          value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
        }
      }
    }
  } else if (typeof value === "string") {
    // String to Uint8Array
    return Bufferish.from.call(exports, value);
  } else if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }

  return new Uint8Array(value);
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/bufferish.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// bufferish.js

var Buffer = exports.global = __webpack_require__(/*! ./buffer-global */ "./node_modules/msgpack-lite/lib/buffer-global.js");
var hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;
var hasArrayBuffer = exports.hasArrayBuffer = ("undefined" !== typeof ArrayBuffer);

var isArray = exports.isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
var isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;
var isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is("ArrayBuffer", "buffer")) : _false;

exports.alloc = alloc;
exports.concat = concat;
exports.from = from;

var BufferArray = exports.Array = __webpack_require__(/*! ./bufferish-array */ "./node_modules/msgpack-lite/lib/bufferish-array.js");
var BufferBuffer = exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */ "./node_modules/msgpack-lite/lib/bufferish-buffer.js");
var BufferUint8Array = exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js");
var BufferProto = exports.prototype = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");

/**
 * @param value {Array|ArrayBuffer|Buffer|String}
 * @returns {Buffer|Uint8Array|Array}
 */

function from(value) {
  if (typeof value === "string") {
    return fromString.call(this, value);
  } else {
    return auto(this).from(value);
  }
}

/**
 * @param size {Number}
 * @returns {Buffer|Uint8Array|Array}
 */

function alloc(size) {
  return auto(this).alloc(size);
}

/**
 * @param list {Array} array of (Buffer|Uint8Array|Array)s
 * @param [length]
 * @returns {Buffer|Uint8Array|Array}
 */

function concat(list, length) {
  if (!length) {
    length = 0;
    Array.prototype.forEach.call(list, dryrun);
  }
  var ref = (this !== exports) && this || list[0];
  var result = alloc.call(ref, length);
  var offset = 0;
  Array.prototype.forEach.call(list, append);
  return result;

  function dryrun(buffer) {
    length += buffer.length;
  }

  function append(buffer) {
    offset += BufferProto.copy.call(buffer, result, offset);
  }
}

var _isArrayBuffer = _is("ArrayBuffer");

function isArrayBuffer(value) {
  return (value instanceof ArrayBuffer) || _isArrayBuffer(value);
}

/**
 * @private
 */

function fromString(value) {
  var expected = value.length * 3;
  var that = alloc.call(this, expected);
  var actual = BufferProto.write.call(that, value);
  if (expected !== actual) {
    that = BufferProto.slice.call(that, 0, actual);
  }
  return that;
}

function auto(that) {
  return isBuffer(that) ? BufferBuffer
    : isView(that) ? BufferUint8Array
    : isArray(that) ? BufferArray
    : hasBuffer ? BufferBuffer
    : hasArrayBuffer ? BufferUint8Array
    : BufferArray;
}

function _false() {
  return false;
}

function _is(name, key) {
  /* jshint eqnull:true */
  name = "[object " + name + "]";
  return function(value) {
    return (value != null) && {}.toString.call(key ? value[key] : value) === name;
  };
}

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// codec-base.js

var IS_ARRAY = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.createCodec = createCodec;
exports.install = install;
exports.filter = filter;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");

function Codec(options) {
  if (!(this instanceof Codec)) return new Codec(options);
  this.options = options;
  this.init();
}

Codec.prototype.init = function() {
  var options = this.options;

  if (options && options.uint8array) {
    this.bufferish = Bufferish.Uint8Array;
  }

  return this;
};

function install(props) {
  for (var key in props) {
    Codec.prototype[key] = add(Codec.prototype[key], props[key]);
  }
}

function add(a, b) {
  return (a && b) ? ab : (a || b);

  function ab() {
    a.apply(this, arguments);
    return b.apply(this, arguments);
  }
}

function join(filters) {
  filters = filters.slice();

  return function(value) {
    return filters.reduce(iterator, value);
  };

  function iterator(value, filter) {
    return filter(value);
  }
}

function filter(filter) {
  return IS_ARRAY(filter) ? join(filter) : filter;
}

// @public
// msgpack.createCodec()

function createCodec(options) {
  return new Codec(options);
}

// default shared codec

exports.preset = createCodec({preset: true});


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/codec.js":
/*!************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/codec.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// codec.js

// load both interfaces
__webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js");
__webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js");

// @public
// msgpack.codec.preset

exports.codec = {
  preset: __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js").preset
};


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// decode-buffer.js

exports.DecodeBuffer = DecodeBuffer;

var preset = __webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js").preset;

var FlexDecoder = __webpack_require__(/*! ./flex-buffer */ "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexDecoder;

FlexDecoder.mixin(DecodeBuffer.prototype);

function DecodeBuffer(options) {
  if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);

  if (options) {
    this.options = options;
    if (options.codec) {
      var codec = this.codec = options.codec;
      if (codec.bufferish) this.bufferish = codec.bufferish;
    }
  }
}

DecodeBuffer.prototype.codec = preset;

DecodeBuffer.prototype.fetch = function() {
  return this.codec.decode(this);
};


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// decode.js

exports.decode = decode;

var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

function decode(input, options) {
  var decoder = new DecodeBuffer(options);
  decoder.write(input);
  return decoder.read();
}

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/decoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// decoder.js

exports.Decoder = Decoder;

var EventLite = __webpack_require__(/*! event-lite */ "./node_modules/event-lite/event-lite.js");
var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;

function Decoder(options) {
  if (!(this instanceof Decoder)) return new Decoder(options);
  DecodeBuffer.call(this, options);
}

Decoder.prototype = new DecodeBuffer();

EventLite.mixin(Decoder.prototype);

Decoder.prototype.decode = function(chunk) {
  if (arguments.length) this.write(chunk);
  this.flush();
};

Decoder.prototype.push = function(chunk) {
  this.emit("data", chunk);
};

Decoder.prototype.end = function(chunk) {
  this.decode(chunk);
  this.emit("end");
};


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// encode-buffer.js

exports.EncodeBuffer = EncodeBuffer;

var preset = __webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js").preset;

var FlexEncoder = __webpack_require__(/*! ./flex-buffer */ "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexEncoder;

FlexEncoder.mixin(EncodeBuffer.prototype);

function EncodeBuffer(options) {
  if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);

  if (options) {
    this.options = options;
    if (options.codec) {
      var codec = this.codec = options.codec;
      if (codec.bufferish) this.bufferish = codec.bufferish;
    }
  }
}

EncodeBuffer.prototype.codec = preset;

EncodeBuffer.prototype.write = function(input) {
  this.codec.encode(this, input);
};


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encode.js":
/*!*************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// encode.js

exports.encode = encode;

var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

function encode(input, options) {
  var encoder = new EncodeBuffer(options);
  encoder.write(input);
  return encoder.read();
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/encoder.js":
/*!**************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// encoder.js

exports.Encoder = Encoder;

var EventLite = __webpack_require__(/*! event-lite */ "./node_modules/event-lite/event-lite.js");
var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;

function Encoder(options) {
  if (!(this instanceof Encoder)) return new Encoder(options);
  EncodeBuffer.call(this, options);
}

Encoder.prototype = new EncodeBuffer();

EventLite.mixin(Encoder.prototype);

Encoder.prototype.encode = function(chunk) {
  this.write(chunk);
  this.emit("data", this.read());
};

Encoder.prototype.end = function(chunk) {
  if (arguments.length) this.encode(chunk);
  this.flush();
  this.emit("end");
};


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ext-buffer.js

exports.ExtBuffer = ExtBuffer;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");

function ExtBuffer(buffer, type) {
  if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);
  this.buffer = Bufferish.from(buffer);
  this.type = type;
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-packer.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ext-packer.js

exports.setExtPackers = setExtPackers;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var Buffer = Bufferish.global;
var packTypedArray = Bufferish.Uint8Array.from;
var _encode;

var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};

function setExtPackers(codec) {
  codec.addExtPacker(0x0E, Error, [packError, encode]);
  codec.addExtPacker(0x01, EvalError, [packError, encode]);
  codec.addExtPacker(0x02, RangeError, [packError, encode]);
  codec.addExtPacker(0x03, ReferenceError, [packError, encode]);
  codec.addExtPacker(0x04, SyntaxError, [packError, encode]);
  codec.addExtPacker(0x05, TypeError, [packError, encode]);
  codec.addExtPacker(0x06, URIError, [packError, encode]);

  codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);
  codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);
  codec.addExtPacker(0x0C, String, [packValueOf, encode]);
  codec.addExtPacker(0x0D, Date, [Number, encode]);
  codec.addExtPacker(0x0F, Number, [packValueOf, encode]);

  if ("undefined" !== typeof Uint8Array) {
    codec.addExtPacker(0x11, Int8Array, packTypedArray);
    codec.addExtPacker(0x12, Uint8Array, packTypedArray);
    codec.addExtPacker(0x13, Int16Array, packTypedArray);
    codec.addExtPacker(0x14, Uint16Array, packTypedArray);
    codec.addExtPacker(0x15, Int32Array, packTypedArray);
    codec.addExtPacker(0x16, Uint32Array, packTypedArray);
    codec.addExtPacker(0x17, Float32Array, packTypedArray);

    // PhantomJS/1.9.7 doesn't have Float64Array
    if ("undefined" !== typeof Float64Array) {
      codec.addExtPacker(0x18, Float64Array, packTypedArray);
    }

    // IE10 doesn't have Uint8ClampedArray
    if ("undefined" !== typeof Uint8ClampedArray) {
      codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);
    }

    codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);
    codec.addExtPacker(0x1D, DataView, packTypedArray);
  }

  if (Bufferish.hasBuffer) {
    codec.addExtPacker(0x1B, Buffer, Bufferish.from);
  }
}

function encode(input) {
  if (!_encode) _encode = __webpack_require__(/*! ./encode */ "./node_modules/msgpack-lite/lib/encode.js").encode; // lazy load
  return _encode(input);
}

function packValueOf(value) {
  return (value).valueOf();
}

function packRegExp(value) {
  value = RegExp.prototype.toString.call(value).split("/");
  value.shift();
  var out = [value.pop()];
  out.unshift(value.join("/"));
  return out;
}

function packError(value) {
  var out = {};
  for (var key in ERROR_COLUMNS) {
    out[key] = value[key];
  }
  return out;
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext-unpacker.js":
/*!*******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ext-unpacker.js

exports.setExtUnpackers = setExtUnpackers;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var Buffer = Bufferish.global;
var _decode;

var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};

function setExtUnpackers(codec) {
  codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);
  codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);
  codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);
  codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);
  codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);
  codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);
  codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);

  codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);
  codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);
  codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);
  codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);
  codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);

  if ("undefined" !== typeof Uint8Array) {
    codec.addExtUnpacker(0x11, unpackClass(Int8Array));
    codec.addExtUnpacker(0x12, unpackClass(Uint8Array));
    codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);
    codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);
    codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);
    codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);
    codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);

    // PhantomJS/1.9.7 doesn't have Float64Array
    if ("undefined" !== typeof Float64Array) {
      codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);
    }

    // IE10 doesn't have Uint8ClampedArray
    if ("undefined" !== typeof Uint8ClampedArray) {
      codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));
    }

    codec.addExtUnpacker(0x1A, unpackArrayBuffer);
    codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);
  }

  if (Bufferish.hasBuffer) {
    codec.addExtUnpacker(0x1B, unpackClass(Buffer));
  }
}

function decode(input) {
  if (!_decode) _decode = __webpack_require__(/*! ./decode */ "./node_modules/msgpack-lite/lib/decode.js").decode; // lazy load
  return _decode(input);
}

function unpackRegExp(value) {
  return RegExp.apply(null, value);
}

function unpackError(Class) {
  return function(value) {
    var out = new Class();
    for (var key in ERROR_COLUMNS) {
      out[key] = value[key];
    }
    return out;
  };
}

function unpackClass(Class) {
  return function(value) {
    return new Class(value);
  };
}

function unpackArrayBuffer(value) {
  return (new Uint8Array(value)).buffer;
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/ext.js":
/*!**********************************************!*\
  !*** ./node_modules/msgpack-lite/lib/ext.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ext.js

// load both interfaces
__webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js");
__webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js");

exports.createCodec = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js").createCodec;


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/flex-buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// flex-buffer.js

exports.FlexDecoder = FlexDecoder;
exports.FlexEncoder = FlexEncoder;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");

var MIN_BUFFER_SIZE = 2048;
var MAX_BUFFER_SIZE = 65536;
var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";

function FlexDecoder() {
  if (!(this instanceof FlexDecoder)) return new FlexDecoder();
}

function FlexEncoder() {
  if (!(this instanceof FlexEncoder)) return new FlexEncoder();
}

FlexDecoder.mixin = mixinFactory(getDecoderMethods());
FlexDecoder.mixin(FlexDecoder.prototype);

FlexEncoder.mixin = mixinFactory(getEncoderMethods());
FlexEncoder.mixin(FlexEncoder.prototype);

function getDecoderMethods() {
  return {
    bufferish: Bufferish,
    write: write,
    fetch: fetch,
    flush: flush,
    push: push,
    pull: pull,
    read: read,
    reserve: reserve,
    offset: 0
  };

  function write(chunk) {
    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;
    this.offset = 0;
  }

  function flush() {
    while (this.offset < this.buffer.length) {
      var start = this.offset;
      var value;
      try {
        value = this.fetch();
      } catch (e) {
        if (e && e.message != BUFFER_SHORTAGE) throw e;
        // rollback
        this.offset = start;
        break;
      }
      this.push(value);
    }
  }

  function reserve(length) {
    var start = this.offset;
    var end = start + length;
    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);
    this.offset = end;
    return start;
  }
}

function getEncoderMethods() {
  return {
    bufferish: Bufferish,
    write: write,
    fetch: fetch,
    flush: flush,
    push: push,
    pull: pull,
    read: read,
    reserve: reserve,
    send: send,
    maxBufferSize: MAX_BUFFER_SIZE,
    minBufferSize: MIN_BUFFER_SIZE,
    offset: 0,
    start: 0
  };

  function fetch() {
    var start = this.start;
    if (start < this.offset) {
      var end = this.start = this.offset;
      return Bufferish.prototype.slice.call(this.buffer, start, end);
    }
  }

  function flush() {
    while (this.start < this.offset) {
      var value = this.fetch();
      if (value) this.push(value);
    }
  }

  function pull() {
    var buffers = this.buffers || (this.buffers = []);
    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
    buffers.length = 0; // buffer exhausted
    return chunk;
  }

  function reserve(length) {
    var req = length | 0;

    if (this.buffer) {
      var size = this.buffer.length;
      var start = this.offset | 0;
      var end = start + req;

      // is it long enough?
      if (end < size) {
        this.offset = end;
        return start;
      }

      // flush current buffer
      this.flush();

      // resize it to 2x current length
      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
    }

    // minimum buffer size
    length = Math.max(length, this.minBufferSize);

    // allocate new buffer
    this.buffer = this.bufferish.alloc(length);
    this.start = 0;
    this.offset = req;
    return 0;
  }

  function send(buffer) {
    var length = buffer.length;
    if (length > this.minBufferSize) {
      this.flush();
      this.push(buffer);
    } else {
      var offset = this.reserve(length);
      Bufferish.prototype.copy.call(buffer, this.buffer, offset);
    }
  }
}

// common methods

function write() {
  throw new Error("method not implemented: write()");
}

function fetch() {
  throw new Error("method not implemented: fetch()");
}

function read() {
  var length = this.buffers && this.buffers.length;

  // fetch the first result
  if (!length) return this.fetch();

  // flush current buffer
  this.flush();

  // read from the results
  return this.pull();
}

function push(chunk) {
  var buffers = this.buffers || (this.buffers = []);
  buffers.push(chunk);
}

function pull() {
  var buffers = this.buffers || (this.buffers = []);
  return buffers.shift();
}

function mixinFactory(source) {
  return mixin;

  function mixin(target) {
    for (var key in source) {
      target[key] = source[key];
    }
    return target;
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-core.js":
/*!****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// read-core.js

var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
var ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */ "./node_modules/msgpack-lite/lib/ext-unpacker.js");
var readUint8 = __webpack_require__(/*! ./read-format */ "./node_modules/msgpack-lite/lib/read-format.js").readUint8;
var ReadToken = __webpack_require__(/*! ./read-token */ "./node_modules/msgpack-lite/lib/read-token.js");
var CodecBase = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js");

CodecBase.install({
  addExtUnpacker: addExtUnpacker,
  getExtUnpacker: getExtUnpacker,
  init: init
});

exports.preset = init.call(CodecBase.preset);

function getDecoder(options) {
  var readToken = ReadToken.getReadToken(options);
  return decode;

  function decode(decoder) {
    var type = readUint8(decoder);
    var func = readToken[type];
    if (!func) throw new Error("Invalid type: " + (type ? ("0x" + type.toString(16)) : type));
    return func(decoder);
  }
}

function init() {
  var options = this.options;
  this.decode = getDecoder(options);

  if (options && options.preset) {
    ExtUnpacker.setExtUnpackers(this);
  }

  return this;
}

function addExtUnpacker(etype, unpacker) {
  var unpackers = this.extUnpackers || (this.extUnpackers = []);
  unpackers[etype] = CodecBase.filter(unpacker);
}

function getExtUnpacker(type) {
  var unpackers = this.extUnpackers || (this.extUnpackers = []);
  return unpackers[type] || extUnpacker;

  function extUnpacker(buffer) {
    return new ExtBuffer(buffer, type);
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-format.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// read-format.js

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

exports.getReadFormat = getReadFormat;
exports.readUint8 = uint8;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var BufferProto = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");

var HAS_MAP = ("undefined" !== typeof Map);
var NO_ASSERT = true;

function getReadFormat(options) {
  var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
  var int64 = options && options.int64;
  var usemap = HAS_MAP && options && options.usemap;

  var readFormat = {
    map: (usemap ? map_to_map : map_to_obj),
    array: array,
    str: str,
    bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),
    ext: ext,
    uint8: uint8,
    uint16: uint16,
    uint32: uint32,
    uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
    int8: int8,
    int16: int16,
    int32: int32,
    int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
    float32: read(4, readFloatBE),
    float64: read(8, readDoubleBE)
  };

  return readFormat;
}

function map_to_obj(decoder, len) {
  var value = {};
  var i;
  var k = new Array(len);
  var v = new Array(len);

  var decode = decoder.codec.decode;
  for (i = 0; i < len; i++) {
    k[i] = decode(decoder);
    v[i] = decode(decoder);
  }
  for (i = 0; i < len; i++) {
    value[k[i]] = v[i];
  }
  return value;
}

function map_to_map(decoder, len) {
  var value = new Map();
  var i;
  var k = new Array(len);
  var v = new Array(len);

  var decode = decoder.codec.decode;
  for (i = 0; i < len; i++) {
    k[i] = decode(decoder);
    v[i] = decode(decoder);
  }
  for (i = 0; i < len; i++) {
    value.set(k[i], v[i]);
  }
  return value;
}

function array(decoder, len) {
  var value = new Array(len);
  var decode = decoder.codec.decode;
  for (var i = 0; i < len; i++) {
    value[i] = decode(decoder);
  }
  return value;
}

function str(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
}

function bin_buffer(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return Bufferish.from(buf);
}

function bin_arraybuffer(decoder, len) {
  var start = decoder.reserve(len);
  var end = start + len;
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return Bufferish.Uint8Array.from(buf).buffer;
}

function ext(decoder, len) {
  var start = decoder.reserve(len+1);
  var type = decoder.buffer[start++];
  var end = start + len;
  var unpack = decoder.codec.getExtUnpacker(type);
  if (!unpack) throw new Error("Invalid ext type: " + (type ? ("0x" + type.toString(16)) : type));
  var buf = BufferProto.slice.call(decoder.buffer, start, end);
  return unpack(buf);
}

function uint8(decoder) {
  var start = decoder.reserve(1);
  return decoder.buffer[start];
}

function int8(decoder) {
  var start = decoder.reserve(1);
  var value = decoder.buffer[start];
  return (value & 0x80) ? value - 0x100 : value;
}

function uint16(decoder) {
  var start = decoder.reserve(2);
  var buffer = decoder.buffer;
  return (buffer[start++] << 8) | buffer[start];
}

function int16(decoder) {
  var start = decoder.reserve(2);
  var buffer = decoder.buffer;
  var value = (buffer[start++] << 8) | buffer[start];
  return (value & 0x8000) ? value - 0x10000 : value;
}

function uint32(decoder) {
  var start = decoder.reserve(4);
  var buffer = decoder.buffer;
  return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
}

function int32(decoder) {
  var start = decoder.reserve(4);
  var buffer = decoder.buffer;
  return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];
}

function read(len, method) {
  return function(decoder) {
    var start = decoder.reserve(len);
    return method.call(decoder.buffer, start, NO_ASSERT);
  };
}

function readUInt64BE(start) {
  return new Uint64BE(this, start).toNumber();
}

function readInt64BE(start) {
  return new Int64BE(this, start).toNumber();
}

function readUInt64BE_int64(start) {
  return new Uint64BE(this, start);
}

function readInt64BE_int64(start) {
  return new Int64BE(this, start);
}

function readFloatBE(start) {
  return ieee754.read(this, start, false, 23, 4);
}

function readDoubleBE(start) {
  return ieee754.read(this, start, false, 52, 8);
}

/***/ }),

/***/ "./node_modules/msgpack-lite/lib/read-token.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// read-token.js

var ReadFormat = __webpack_require__(/*! ./read-format */ "./node_modules/msgpack-lite/lib/read-format.js");

exports.getReadToken = getReadToken;

function getReadToken(options) {
  var format = ReadFormat.getReadFormat(options);

  if (options && options.useraw) {
    return init_useraw(format);
  } else {
    return init_token(format);
  }
}

function init_token(format) {
  var i;
  var token = new Array(256);

  // positive fixint -- 0x00 - 0x7f
  for (i = 0x00; i <= 0x7f; i++) {
    token[i] = constant(i);
  }

  // fixmap -- 0x80 - 0x8f
  for (i = 0x80; i <= 0x8f; i++) {
    token[i] = fix(i - 0x80, format.map);
  }

  // fixarray -- 0x90 - 0x9f
  for (i = 0x90; i <= 0x9f; i++) {
    token[i] = fix(i - 0x90, format.array);
  }

  // fixstr -- 0xa0 - 0xbf
  for (i = 0xa0; i <= 0xbf; i++) {
    token[i] = fix(i - 0xa0, format.str);
  }

  // nil -- 0xc0
  token[0xc0] = constant(null);

  // (never used) -- 0xc1
  token[0xc1] = null;

  // false -- 0xc2
  // true -- 0xc3
  token[0xc2] = constant(false);
  token[0xc3] = constant(true);

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = flex(format.uint8, format.bin);
  token[0xc5] = flex(format.uint16, format.bin);
  token[0xc6] = flex(format.uint32, format.bin);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = flex(format.uint8, format.ext);
  token[0xc8] = flex(format.uint16, format.ext);
  token[0xc9] = flex(format.uint32, format.ext);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = format.float32;
  token[0xcb] = format.float64;

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = format.uint8;
  token[0xcd] = format.uint16;
  token[0xce] = format.uint32;
  token[0xcf] = format.uint64;

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = format.int8;
  token[0xd1] = format.int16;
  token[0xd2] = format.int32;
  token[0xd3] = format.int64;

  // fixext 1 -- 0xd4
  // fixext 2 -- 0xd5
  // fixext 4 -- 0xd6
  // fixext 8 -- 0xd7
  // fixext 16 -- 0xd8
  token[0xd4] = fix(1, format.ext);
  token[0xd5] = fix(2, format.ext);
  token[0xd6] = fix(4, format.ext);
  token[0xd7] = fix(8, format.ext);
  token[0xd8] = fix(16, format.ext);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = flex(format.uint8, format.str);
  token[0xda] = flex(format.uint16, format.str);
  token[0xdb] = flex(format.uint32, format.str);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = flex(format.uint16, format.array);
  token[0xdd] = flex(format.uint32, format.array);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = flex(format.uint16, format.map);
  token[0xdf] = flex(format.uint32, format.map);

  // negative fixint -- 0xe0 - 0xff
  for (i = 0xe0; i <= 0xff; i++) {
    token[i] = constant(i - 0x100);
  }

  return token;
}

function init_useraw(format) {
  var i;
  var token = init_token(format).slice();

  // raw 8 -- 0xd9
  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  token[0xd9] = token[0xc4];
  token[0xda] = token[0xc5];
  token[0xdb] = token[0xc6];

  // fixraw -- 0xa0 - 0xbf
  for (i = 0xa0; i <= 0xbf; i++) {
    token[i] = fix(i - 0xa0, format.bin);
  }

  return token;
}

function constant(value) {
  return function() {
    return value;
  };
}

function flex(lenFunc, decodeFunc) {
  return function(decoder) {
    var len = lenFunc(decoder);
    return decodeFunc(decoder, len);
  };
}

function fix(len, method) {
  return function(decoder) {
    return method(decoder, len);
  };
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-core.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// write-core.js

var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
var ExtPacker = __webpack_require__(/*! ./ext-packer */ "./node_modules/msgpack-lite/lib/ext-packer.js");
var WriteType = __webpack_require__(/*! ./write-type */ "./node_modules/msgpack-lite/lib/write-type.js");
var CodecBase = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js");

CodecBase.install({
  addExtPacker: addExtPacker,
  getExtPacker: getExtPacker,
  init: init
});

exports.preset = init.call(CodecBase.preset);

function getEncoder(options) {
  var writeType = WriteType.getWriteType(options);
  return encode;

  function encode(encoder, value) {
    var func = writeType[typeof value];
    if (!func) throw new Error("Unsupported type \"" + (typeof value) + "\": " + value);
    func(encoder, value);
  }
}

function init() {
  var options = this.options;
  this.encode = getEncoder(options);

  if (options && options.preset) {
    ExtPacker.setExtPackers(this);
  }

  return this;
}

function addExtPacker(etype, Class, packer) {
  packer = CodecBase.filter(packer);
  var name = Class.name;
  if (name && name !== "Object") {
    var packers = this.extPackers || (this.extPackers = {});
    packers[name] = extPacker;
  } else {
    // fallback for IE
    var list = this.extEncoderList || (this.extEncoderList = []);
    list.unshift([Class, extPacker]);
  }

  function extPacker(value) {
    if (packer) value = packer(value);
    return new ExtBuffer(value, etype);
  }
}

function getExtPacker(value) {
  var packers = this.extPackers || (this.extPackers = {});
  var c = value.constructor;
  var e = c && c.name && packers[c.name];
  if (e) return e;

  // fallback for IE
  var list = this.extEncoderList || (this.extEncoderList = []);
  var len = list.length;
  for (var i = 0; i < len; i++) {
    var pair = list[i];
    if (c === pair[0]) return pair[1];
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-token.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// write-token.js

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

var uint8 = __webpack_require__(/*! ./write-uint8 */ "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var Buffer = Bufferish.global;
var IS_BUFFER_SHIM = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
var Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};

exports.getWriteToken = getWriteToken;

function getWriteToken(options) {
  if (options && options.uint8array) {
    return init_uint8array();
  } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {
    return init_safe();
  } else {
    return init_token();
  }
}

function init_uint8array() {
  var token = init_token();

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, writeFloatBE);
  token[0xcb] = writeN(0xcb, 8, writeDoubleBE);

  return token;
}

// Node.js and browsers with TypedArray

function init_token() {
  // (immediate values)
  // positive fixint -- 0x00 - 0x7f
  // nil -- 0xc0
  // false -- 0xc2
  // true -- 0xc3
  // negative fixint -- 0xe0 - 0xff
  var token = uint8.slice();

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = write1(0xc4);
  token[0xc5] = write2(0xc5);
  token[0xc6] = write4(0xc6);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = write1(0xc7);
  token[0xc8] = write2(0xc8);
  token[0xc9] = write4(0xc9);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);
  token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = write1(0xcc);
  token[0xcd] = write2(0xcd);
  token[0xce] = write4(0xce);
  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = write1(0xd0);
  token[0xd1] = write2(0xd1);
  token[0xd2] = write4(0xd2);
  token[0xd3] = writeN(0xd3, 8, writeInt64BE);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = write1(0xd9);
  token[0xda] = write2(0xda);
  token[0xdb] = write4(0xdb);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = write2(0xdc);
  token[0xdd] = write4(0xdd);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = write2(0xde);
  token[0xdf] = write4(0xdf);

  return token;
}

// safe mode: for old browsers and who needs asserts

function init_safe() {
  // (immediate values)
  // positive fixint -- 0x00 - 0x7f
  // nil -- 0xc0
  // false -- 0xc2
  // true -- 0xc3
  // negative fixint -- 0xe0 - 0xff
  var token = uint8.slice();

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);
  token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);
  token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);

  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);
  token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);
  token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);

  // float 32 -- 0xca
  // float 64 -- 0xcb
  token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);
  token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);

  // uint 8 -- 0xcc
  // uint 16 -- 0xcd
  // uint 32 -- 0xce
  // uint 64 -- 0xcf
  token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);
  token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);
  token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);
  token[0xcf] = writeN(0xcf, 8, writeUInt64BE);

  // int 8 -- 0xd0
  // int 16 -- 0xd1
  // int 32 -- 0xd2
  // int 64 -- 0xd3
  token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);
  token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);
  token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);
  token[0xd3] = writeN(0xd3, 8, writeInt64BE);

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);
  token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);
  token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);

  // array 16 -- 0xdc
  // array 32 -- 0xdd
  token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);
  token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);

  // map 16 -- 0xde
  // map 32 -- 0xdf
  token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);
  token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);

  return token;
}

function write1(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(2);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset] = value;
  };
}

function write2(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(3);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset++] = value >>> 8;
    buffer[offset] = value;
  };
}

function write4(type) {
  return function(encoder, value) {
    var offset = encoder.reserve(5);
    var buffer = encoder.buffer;
    buffer[offset++] = type;
    buffer[offset++] = value >>> 24;
    buffer[offset++] = value >>> 16;
    buffer[offset++] = value >>> 8;
    buffer[offset] = value;
  };
}

function writeN(type, len, method, noAssert) {
  return function(encoder, value) {
    var offset = encoder.reserve(len + 1);
    encoder.buffer[offset++] = type;
    method.call(encoder.buffer, value, offset, noAssert);
  };
}

function writeUInt64BE(value, offset) {
  new Uint64BE(this, offset, value);
}

function writeInt64BE(value, offset) {
  new Int64BE(this, offset, value);
}

function writeFloatBE(value, offset) {
  ieee754.write(this, value, offset, false, 23, 4);
}

function writeDoubleBE(value, offset) {
  ieee754.write(this, value, offset, false, 52, 8);
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-type.js":
/*!*****************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// write-type.js

var IS_ARRAY = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
var Uint64BE = Int64Buffer.Uint64BE;
var Int64BE = Int64Buffer.Int64BE;

var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
var BufferProto = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");
var WriteToken = __webpack_require__(/*! ./write-token */ "./node_modules/msgpack-lite/lib/write-token.js");
var uint8 = __webpack_require__(/*! ./write-uint8 */ "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;

var HAS_UINT8ARRAY = ("undefined" !== typeof Uint8Array);
var HAS_MAP = ("undefined" !== typeof Map);

var extmap = [];
extmap[1] = 0xd4;
extmap[2] = 0xd5;
extmap[4] = 0xd6;
extmap[8] = 0xd7;
extmap[16] = 0xd8;

exports.getWriteType = getWriteType;

function getWriteType(options) {
  var token = WriteToken.getWriteToken(options);
  var useraw = options && options.useraw;
  var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
  var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
  var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
  var usemap = HAS_MAP && options && options.usemap;
  var map = usemap ? map_to_map : obj_to_map;

  var writeType = {
    "boolean": bool,
    "function": nil,
    "number": number,
    "object": (useraw ? object_raw : object),
    "string": _string(useraw ? raw_head_size : str_head_size),
    "symbol": nil,
    "undefined": nil
  };

  return writeType;

  // false -- 0xc2
  // true -- 0xc3
  function bool(encoder, value) {
    var type = value ? 0xc3 : 0xc2;
    token[type](encoder, value);
  }

  function number(encoder, value) {
    var ivalue = value | 0;
    var type;
    if (value !== ivalue) {
      // float 64 -- 0xcb
      type = 0xcb;
      token[type](encoder, value);
      return;
    } else if (-0x20 <= ivalue && ivalue <= 0x7F) {
      // positive fixint -- 0x00 - 0x7f
      // negative fixint -- 0xe0 - 0xff
      type = ivalue & 0xFF;
    } else if (0 <= ivalue) {
      // uint 8 -- 0xcc
      // uint 16 -- 0xcd
      // uint 32 -- 0xce
      type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;
    } else {
      // int 8 -- 0xd0
      // int 16 -- 0xd1
      // int 32 -- 0xd2
      type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;
    }
    token[type](encoder, ivalue);
  }

  // uint 64 -- 0xcf
  function uint64(encoder, value) {
    var type = 0xcf;
    token[type](encoder, value.toArray());
  }

  // int 64 -- 0xd3
  function int64(encoder, value) {
    var type = 0xd3;
    token[type](encoder, value.toArray());
  }

  // str 8 -- 0xd9
  // str 16 -- 0xda
  // str 32 -- 0xdb
  // fixstr -- 0xa0 - 0xbf
  function str_head_size(length) {
    return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;
  }

  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  // fixraw -- 0xa0 - 0xbf
  function raw_head_size(length) {
    return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;
  }

  function _string(head_size) {
    return string;

    function string(encoder, value) {
      // prepare buffer
      var length = value.length;
      var maxsize = 5 + length * 3;
      encoder.offset = encoder.reserve(maxsize);
      var buffer = encoder.buffer;

      // expected header size
      var expected = head_size(length);

      // expected start point
      var start = encoder.offset + expected;

      // write string
      length = BufferProto.write.call(buffer, value, start);

      // actual header size
      var actual = head_size(length);

      // move content when needed
      if (expected !== actual) {
        var targetStart = start + actual - expected;
        var end = start + length;
        BufferProto.copy.call(buffer, buffer, targetStart, start, end);
      }

      // write header
      var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;
      token[type](encoder, length);

      // move cursor
      encoder.offset += length;
    }
  }

  function object(encoder, value) {
    // null
    if (value === null) return nil(encoder, value);

    // Buffer
    if (isBuffer(value)) return bin(encoder, value);

    // Array
    if (IS_ARRAY(value)) return array(encoder, value);

    // int64-buffer objects
    if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);
    if (Int64BE.isInt64BE(value)) return int64(encoder, value);

    // ext formats
    var packer = encoder.codec.getExtPacker(value);
    if (packer) value = packer(value);
    if (value instanceof ExtBuffer) return ext(encoder, value);

    // plain old Objects or Map
    map(encoder, value);
  }

  function object_raw(encoder, value) {
    // Buffer
    if (isBuffer(value)) return raw(encoder, value);

    // others
    object(encoder, value);
  }

  // nil -- 0xc0
  function nil(encoder, value) {
    var type = 0xc0;
    token[type](encoder, value);
  }

  // fixarray -- 0x90 - 0x9f
  // array 16 -- 0xdc
  // array 32 -- 0xdd
  function array(encoder, value) {
    var length = value.length;
    var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    for (var i = 0; i < length; i++) {
      encode(encoder, value[i]);
    }
  }

  // bin 8 -- 0xc4
  // bin 16 -- 0xc5
  // bin 32 -- 0xc6
  function bin_buffer(encoder, value) {
    var length = value.length;
    var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;
    token[type](encoder, length);
    encoder.send(value);
  }

  function bin_arraybuffer(encoder, value) {
    bin_buffer(encoder, new Uint8Array(value));
  }

  // fixext 1 -- 0xd4
  // fixext 2 -- 0xd5
  // fixext 4 -- 0xd6
  // fixext 8 -- 0xd7
  // fixext 16 -- 0xd8
  // ext 8 -- 0xc7
  // ext 16 -- 0xc8
  // ext 32 -- 0xc9
  function ext(encoder, value) {
    var buffer = value.buffer;
    var length = buffer.length;
    var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);
    token[type](encoder, length);
    uint8[value.type](encoder);
    encoder.send(buffer);
  }

  // fixmap -- 0x80 - 0x8f
  // map 16 -- 0xde
  // map 32 -- 0xdf
  function obj_to_map(encoder, value) {
    var keys = Object.keys(value);
    var length = keys.length;
    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    keys.forEach(function(key) {
      encode(encoder, key);
      encode(encoder, value[key]);
    });
  }

  // fixmap -- 0x80 - 0x8f
  // map 16 -- 0xde
  // map 32 -- 0xdf
  function map_to_map(encoder, value) {
    if (!(value instanceof Map)) return obj_to_map(encoder, value);

    var length = value.size;
    var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
    token[type](encoder, length);

    var encode = encoder.codec.encode;
    value.forEach(function(val, key, m) {
      encode(encoder, key);
      encode(encoder, val);
    });
  }

  // raw 16 -- 0xda
  // raw 32 -- 0xdb
  // fixraw -- 0xa0 - 0xbf
  function raw(encoder, value) {
    var length = value.length;
    var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;
    token[type](encoder, length);
    encoder.send(value);
  }
}


/***/ }),

/***/ "./node_modules/msgpack-lite/lib/write-uint8.js":
/*!******************************************************!*\
  !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// write-unit8.js

var constant = exports.uint8 = new Array(256);

for (var i = 0x00; i <= 0xFF; i++) {
  constant[i] = write0(i);
}

function write0(type) {
  return function(encoder) {
    var offset = encoder.reserve(1);
    encoder.buffer[offset] = type;
  };
}


/***/ }),

/***/ "./node_modules/percipio/src/bandits.js":
/*!**********************************************!*\
  !*** ./node_modules/percipio/src/bandits.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js")
var rbeta = __webpack_require__(/*! ./stats */ "./node_modules/percipio/src/stats.js").rbeta
var pdfbeta = __webpack_require__(/*! ./stats */ "./node_modules/percipio/src/stats.js").pdfbeta
var beta = __webpack_require__(/*! ./stats */ "./node_modules/percipio/src/stats.js").beta

var Predictor = function(arms) {

    var self = {}
    var bayesianBanditStrategy = BayesianBanditStrategy(arms)

    self.predict = function() {
        var arm = bayesianBanditStrategy.maxPrizeArm()
        return arm
    }

    self.learn = function(prediction, result) {
        bayesianBanditStrategy.update(prediction, result)
    }

    self.posteriorProbabilities = function() {
        return bayesianBanditStrategy.armPosteriors()
    }

    return self
}

function createArm(id, reward) {
    return Arm(id, reward, 0 ,0)
}

var Arm = function(id, reward, wins, trials) {

    var self = {}

    self.id = id
    self.reward = reward
    self.wins = wins
    self.trials = trials

    self.losses = function() {
        return self.trials - self.wins
    }

    self.prizeProbability = function() {
        return rbeta(1 + self.wins, 1 + self.losses())
    }

    self.posterior = function(range) {
        return pdfbeta(range, 1 + self.wins, 1 + self.losses()) 
    }

    return self
}

var BayesianBanditStrategy = function(arms) {

    var self = {}
    self.arms = arms

    self.maxPrizeArm = function() {
        return _.max(self.arms, function(a) { return a.prizeProbability() })
    }

    self.update = function(arm, result) {
        var arm = _.find(self.arms, function(a) { return a.id == arm.id })
        arm.wins += result
        arm.trials += 1
    }

    self.armPosteriors = function() {
        x = _.range(0, 1, 0.01)
        return self.arms.map(function(a) { return a.posterior(x) })
    }

    return self
}

module.exports.Predictor = Predictor
module.exports.Arm = Arm
module.exports.createArm = createArm


/***/ }),

/***/ "./node_modules/percipio/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/percipio/src/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports.bandits = __webpack_require__(/*! ./bandits */ "./node_modules/percipio/src/bandits.js")
module.exports.naiveBayes = __webpack_require__(/*! ./naive_bayes */ "./node_modules/percipio/src/naive_bayes.js")
module.exports.stats = __webpack_require__(/*! ./stats */ "./node_modules/percipio/src/stats.js")
module.exports.metrics = __webpack_require__(/*! ./metrics */ "./node_modules/percipio/src/metrics.js")


/***/ }),

/***/ "./node_modules/percipio/src/metrics.js":
/*!**********************************************!*\
  !*** ./node_modules/percipio/src/metrics.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js")

function totalRegret(probabilities, choices) {
    var regret = []
    var maxProbability = _.max(probabilities)
    var cumulative = 0
    choices.forEach(function(c) {
        cumulative += maxProbability - probabilities[c]
        regret.push(cumulative)
    })
    return regret
}

module.exports.totalRegret = totalRegret


/***/ }),

/***/ "./node_modules/percipio/src/naive_bayes.js":
/*!**************************************************!*\
  !*** ./node_modules/percipio/src/naive_bayes.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js")

var Predictor = function() {

    var self = {}
    self.totalCount = 0
    self.classCounts = {}
    self.conditionalCounts = {}

    self.learn = function(prediction, result) {
        self.totalCount++ 
        self.classCounts[result] = self.classCounts[result] === undefined ? 1 : self.classCounts[result] + 1
        if(self.conditionalCounts[result] === undefined) {
            self.conditionalCounts[result] = new Array(prediction.length+1).join('0').split('').map(parseFloat)
        }
        prediction.forEach(function(value, i) {
            self.conditionalCounts[result][i] += value
        })
    }

    function computePriors(classCounts, totalCount) {
        var priors = {}
        _.keys(classCounts).forEach(function(className) {
            priors[className] = classCounts[className] / totalCount 
        })
        return priors
    }

    function computeConditionals(conditionalCounts, classCounts) {
        var conditionals = {}
        _.keys(classCounts).forEach(function(className) {
            var classCount = classCounts[className]
            conditionals[className] = {}
            conditionalCounts[className].forEach(function(featureValue, i) {
                conditionals[className][i] = featureValue / classCount 
            })
        })
        return conditionals
    }

    self.predict = function(prediction) {
        var priors = computePriors(self.classCounts, self.totalCount)
        var conditionals = computeConditionals(self.conditionalCounts, self.classCounts)
        var classProbabilities = {}

        _.keys(self.classCounts).forEach(function(className) {
            classProbabilities[className] = Math.log(priors[className])
            prediction.forEach(function(featureValue, i) {
                if(featureValue > 0) {
                    classProbabilities[className] += Math.log(conditionals[className][i])
                }
            })
        })
        var maxProbability = _.max(classProbabilities)
        return parseFloat(_.invert(classProbabilities)[maxProbability])
    }
    

    return self
}

module.exports.Predictor = Predictor


/***/ }),

/***/ "./node_modules/percipio/src/stats.js":
/*!********************************************!*\
  !*** ./node_modules/percipio/src/stats.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/modules/index-all.js")

function sum(x) {
    return x.reduce(function(a, b) {
        return a + b
    })
}

function mean(x) {
    return sum(x) / x.length
}

function min(x) {
    return _.min(x)
}

function max(x) {
    return _.max(x)
}

function variance(x) {
    var xMean = mean(x)
    var deviations = x.map(function(value) {
        return Math.pow(value - xMean, 2)
    })
    return mean(deviations)
}
function pdfbeta(x,a,b){
    _beta = beta(a, b)
    function _pdfbeta(y){
        return (Math.pow(y,a-1)*Math.pow(1-y, b - 1) )/_beta 
    }
    return x.map(_pdfbeta)
}

function beta(a,b){
    var log_n = Math.log(a)*(a - 0.5) + Math.log(b)*( b-0.5)
    var log_d = Math.log( a + b)*(a+ b-0.5)
    return Math.sqrt( 2*Math.PI)*Math.exp(log_n - log_d)
}


function rbeta(a,b){

    var p = a/b
    if (Math.min(a,b) <= 1){
        var lambda =  Math.min(a,b)
    }else{
        var lambda = Math.sqrt( (2*a*b - a - b)/(a+b-2) )
    }

    while (true) {
        var R1 = Math.random()
        var R2 = Math.random()
        var y = Math.pow( ( 1./R1 - 1.), 1./lambda )
        if ( 4*R1*R2*R2 < (Math.pow(y, a - lambda)*Math.pow(  (1.+ p)/(1 + p*y) , a + b ) )){
            return (p*y)/(1+ p*y) 
        }
    }
}

module.exports.sum = sum
module.exports.mean = mean
module.exports.min = min
module.exports.max = max
module.exports.variance = variance
module.exports.beta = beta
module.exports.rbeta = rbeta
module.exports.pdfbeta = pdfbeta


/***/ }),

/***/ "./node_modules/prelude-ls/lib/Func.js":
/*!*********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Func.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by LiveScript 1.6.0
var apply, curry, flip, fix, over, memoize, toString$ = {}.toString;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
memoize = function(f){
  var memo;
  memo = {};
  return function(){
    var args, res$, i$, to$, key, arg;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    key = (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
        arg = ref$[i$];
        results$.push(arg + toString$.call(arg).slice(8, -1));
      }
      return results$;
    }()).join('');
    return memo[key] = key in memo
      ? memo[key]
      : f.apply(null, args);
  };
};
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

/***/ }),

/***/ "./node_modules/prelude-ls/lib/List.js":
/*!*********************************************!*\
  !*** ./node_modules/prelude-ls/lib/List.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by LiveScript 1.6.0
var each, map, compact, filter, reject, remove, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
remove = curry$(function(el, xs){
  var i, x$;
  i = elemIndex(el, xs);
  x$ = xs.slice();
  if (i != null) {
    x$.splice(i, 1);
  }
  return x$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  yss = res$;
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  yss = res$;
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, res$, i$, to$, results, len$, xs, j$, len1$, x;
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(compose$(p, not$), xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, res$, i$, to$, minLength, len$, xs, ref$, i, lresult$, j$, results$ = [];
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, res$, i$, to$, minLength, len$, xs, ref$, i, results$ = [];
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  remove: remove,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
function not$(x){ return !x; }

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Num.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Num.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by LiveScript 1.6.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Obj.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Obj.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by LiveScript 1.6.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, resultObj$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    resultObj$[x[0]] = x[1];
  }
  return resultObj$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, resultObj$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    resultObj$[key] = values[i];
  }
  return resultObj$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    resultObj$[k] = f(x);
  }
  return resultObj$;
});
compact = function(object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (x) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
};
filter = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
reject = curry$(function(f, object){
  var k, x, resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (!f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

/***/ }),

/***/ "./node_modules/prelude-ls/lib/Str.js":
/*!********************************************!*\
  !*** ./node_modules/prelude-ls/lib/Str.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by LiveScript 1.6.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

/***/ }),

/***/ "./node_modules/prelude-ls/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/prelude-ls/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by LiveScript 1.6.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = __webpack_require__(/*! ./Func.js */ "./node_modules/prelude-ls/lib/Func.js");
List = __webpack_require__(/*! ./List.js */ "./node_modules/prelude-ls/lib/List.js");
Obj = __webpack_require__(/*! ./Obj.js */ "./node_modules/prelude-ls/lib/Obj.js");
Str = __webpack_require__(/*! ./Str.js */ "./node_modules/prelude-ls/lib/Str.js");
Num = __webpack_require__(/*! ./Num.js */ "./node_modules/prelude-ls/lib/Num.js");
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.2.1';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-debounce/index.js":
/*!************************************************!*\
  !*** ./node_modules/promise-debounce/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = promiseDebounce;
function promiseDebounce(fn, ctx) {
	var pending = null;
	function clear() { pending = null; }
	return function() {
		if (pending) return pending;
		pending = fn.apply(ctx, arguments);
		pending.then(clear, clear);
		return pending;
	}
}


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/jspm_packages/system.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./src/jspm_packages/system.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "(function(){'use strict';function t(wa){return yt?Symbol():'@@'+wa}function n(wa,Ga){ct||(Ga=Ga.replace(mt?/file:\\/\\/\\//g:/file:\\/\\//g,''));var Fa,Ua=(wa.message||wa)+'\\n  '+Ga;Fa=vt&&wa.fileName?new Error(Ua,wa.fileName,wa.lineNumber):new Error(Ua);var qa=wa.originalErr?wa.originalErr.stack:wa.stack;return Fa.stack=ft?Ua+'\\n  '+qa:qa,Fa.originalErr=wa.originalErr||wa,Fa}function r(wa,Ga){throw new RangeError('Unable to resolve \"'+wa+'\" to '+Ga)}function s(wa,Ga){wa=wa.trim();var Ua=Ga&&Ga.substr(0,Ga.indexOf(':')+1),Fa=wa[0],qa=wa[1];if('/'===Fa&&'/'===qa)return Ua||r(wa,Ga),Ua+wa;if('.'===Fa&&('/'===qa||'.'===qa&&('/'===wa[2]||2===wa.length&&(wa+='/'))||1===wa.length&&(wa+='/'))||'/'===Fa){var Ja,za=!Ua||'/'!==Ga[Ua.length];if(za?(void 0===Ga&&r(wa,Ga),Ja=Ga):'/'===Ga[Ua.length+1]?'file:'===Ua?Ja=Ga.substr(8):(Ja=Ga.substr(Ua.length+2),Ja=Ja.substr(Ja.indexOf('/')+1)):Ja=Ga.substr(Ua.length+1),'/'===Fa)if(za)r(wa,Ga);else return Ga.substr(0,Ga.length-Ja.length-1)+wa;for(var Ya=Ja.substr(0,Ja.lastIndexOf('/')+1)+wa,Ba=[],Ha=-1,Va=0;Va<Ya.length;Va++){if(-1!=Ha){'/'===Ya[Va]&&(Ba.push(Ya.substring(Ha,Va+1)),Ha=-1);continue}if('.'===Ya[Va]){if('.'===Ya[Va+1]&&'/'===Ya[Va+2])Ba.pop(),Va+=2;else if('/'===Ya[Va+1])Va+=1;else{Ha=Va;continue}za&&0===Ba.length&&r(wa,Ga),Va===Ya.length&&Ba.push('');continue}Ha=Va}return-1!==Ha&&Ba.push(Ya.substr(Ha)),Ga.substr(0,Ga.length-Ja.length)+Ba.join('')}var Wa=wa.indexOf(':');if(-1!==Wa)return ft&&':'===wa[1]&&'\\\\'===wa[2]&&wa[0].match(/[a-z]/i)?'file:///'+wa.replace(/\\\\/g,'/'):wa}function l(wa){if(wa.values)return wa.values();if('undefined'==typeof Symbol||!Symbol.iterator)throw new Error('Symbol.iterator not supported in this browser');var Ga={};return Ga[Symbol.iterator]=function(){var Ua=Object.keys(wa),Fa=0;return{next:function(){return Fa<Ua.length?{value:wa[Ua[Fa++]],done:!1}:{value:void 0,done:!0}}}},Ga}function o(){this.registry=new f}function d(wa){if(!(wa instanceof h))throw new TypeError('Module instantiation did not return a valid namespace object.');return wa}function u(wa){if(void 0===wa)throw new RangeError('No resolution found.');return wa}function f(){this[Ot]={}}function h(wa){Object.defineProperty(this,_t,{value:wa}),Object.keys(wa).forEach(y,this)}function y(wa){Object.defineProperty(this,wa,{enumerable:!0,get:function(){return this[_t][wa]}})}function k(){o.call(this);var wa=this.registry.delete;this.registry.delete=function(Ua){var Fa=wa.call(this,Ua);return Ga.hasOwnProperty(Ua)&&!Ga[Ua].linkRecord&&(delete Ga[Ua],Fa=!0),Fa};var Ga={};this[Ct]={lastRegister:void 0,records:Ga},this.trace=!1}function x(wa,Ga,Ua){return wa.records[Ga]={key:Ga,registration:Ua,module:void 0,importerSetters:void 0,loadError:void 0,evalError:void 0,linkRecord:{instantiatePromise:void 0,dependencies:void 0,execute:void 0,executingRequire:!1,moduleObj:void 0,setters:void 0,depsInstantiatePromise:void 0,dependencyInstantiations:void 0}}}function E(wa,Ga,Ua,Fa,qa){var za=Fa[Ga];if(za)return Promise.resolve(za);var Ja=qa.records[Ga];return Ja&&!Ja.module?Ja.loadError?Promise.reject(Ja.loadError):R(wa,Ja,Ja.linkRecord,Fa,qa):wa.resolve(Ga,Ua).then(function(Ya){if(za=Fa[Ya],za)return za;if(Ja=qa.records[Ya],(!Ja||Ja.module)&&(Ja=x(qa,Ya,Ja&&Ja.registration)),Ja.loadError)return Promise.reject(Ja.loadError);var Ba=Ja.linkRecord;return Ba?R(wa,Ja,Ba,Fa,qa):Ja})}function S(wa,Ga,Ua){return function(){var Fa=Ua.lastRegister;return Fa?(Ua.lastRegister=void 0,Ga.registration=Fa,!0):!!Ga.registration}}function R(wa,Ga,Ua,Fa,qa){return Ua.instantiatePromise||(Ua.instantiatePromise=(Ga.registration?Promise.resolve():Promise.resolve().then(function(){return qa.lastRegister=void 0,wa[Mt](Ga.key,1<wa[Mt].length&&S(wa,Ga,qa))})).then(function(za){if(void 0!==za){if(!(za instanceof h))throw new TypeError('Instantiate did not return a valid Module object.');return delete qa.records[Ga.key],wa.trace&&O(wa,Ga,Ua),Fa[Ga.key]=za}var Ja=Ga.registration;if(Ga.registration=void 0,!Ja)throw new TypeError('Module instantiation did not call an anonymous or correctly named System.register.');return Ua.dependencies=Ja[0],Ga.importerSetters=[],Ua.moduleObj={},Ja[2]?(Ua.moduleObj.default=Ua.moduleObj.__useDefault={},Ua.executingRequire=Ja[1],Ua.execute=Ja[2]):_(wa,Ga,Ua,Ja[1]),Ga}).catch(function(za){throw Ga.linkRecord=void 0,Ga.loadError=Ga.loadError||n(za,'Instantiating '+Ga.key)}))}function I(wa,Ga,Ua,Fa,qa,za){return wa.resolve(Ga,Ua).then(function(Ja){za&&(za[Ga]=Ja);var Ya=qa.records[Ja],Ba=Fa[Ja];if(Ba&&(!Ya||Ya.module&&Ba!==Ya.module))return Ba;if(Ya&&Ya.loadError)throw Ya.loadError;Ya&&(Ba||!Ya.module)||(Ya=x(qa,Ja,Ya&&Ya.registration));var Ha=Ya.linkRecord;return Ha?R(wa,Ya,Ha,Fa,qa):Ya})}function O(wa,Ga,Ua){wa.loads=wa.loads||{},wa.loads[Ga.key]={key:Ga.key,deps:Ua.dependencies,dynamicDeps:[],depMap:Ua.depMap||{}}}function _(wa,Ga,Ua,Fa){var qa=Ua.moduleObj,za=Ga.importerSetters,Ja=!1,Ya=Fa.call(ht,function(Ba,Ha){if('object'==typeof Ba){var Va=!1;for(var Wa in Ba)Ha=Ba[Wa],'__useDefault'==Wa||Wa in qa&&qa[Wa]===Ha||(Va=!0,qa[Wa]=Ha);if(!1==Va)return Ha}else{if((Ja||Ba in qa)&&qa[Ba]===Ha)return Ha;qa[Ba]=Ha}for(var $a=0;$a<za.length;$a++)za[$a](qa);return Ha},new T(wa,Ga.key));Ua.setters=Ya.setters,Ua.execute=Ya.execute,Ya.exports&&(Ua.moduleObj=qa=Ya.exports,Ja=!0)}function C(wa,Ga,Ua,Fa,qa){if(Ua.depsInstantiatePromise)return Ua.depsInstantiatePromise;for(var za=Array(Ua.dependencies.length),Ja=0;Ja<Ua.dependencies.length;Ja++)za[Ja]=I(wa,Ua.dependencies[Ja],Ga.key,Fa,qa,wa.trace&&Ua.depMap||(Ua.depMap={}));var Ya=Promise.all(za).then(function(Ba){if(Ua.dependencyInstantiations=Ba,Ua.setters)for(var Va,Ha=0;Ha<Ba.length;Ha++)if(Va=Ua.setters[Ha],Va){var Wa=Ba[Ha];if(Wa instanceof h)Va(Wa);else{if(Wa.loadError)throw Wa.loadError;Va(Wa.module||Wa.linkRecord.moduleObj),Wa.importerSetters&&Wa.importerSetters.push(Va)}}return Ga});return wa.trace&&(Ya=Ya.then(function(){return O(wa,Ga,Ua),Ga})),Ya=Ya.catch(function(Ba){throw Ua.depsInstantiatePromise=void 0,n(Ba,'Loading '+Ga.key)}),Ya.catch(function(){}),Ua.depsInstantiatePromise=Ya}function M(wa,Ga,Ua,Fa,qa){return new Promise(function(za,Ja){function Ya(Wa){var $a=Wa.linkRecord;$a&&-1===Ha.indexOf(Wa)&&(Ha.push(Wa),Va++,C(wa,Wa,$a,Fa,qa).then(Ba,Ja))}function Ba(Wa){Va--;var $a=Wa.linkRecord;if($a)for(var Qa,Xa=0;Xa<$a.dependencies.length;Xa++)Qa=$a.dependencyInstantiations[Xa],Qa instanceof h||Ya(Qa);0===Va&&za()}var Ha=[],Va=0;Ya(Ga)})}function T(wa,Ga){this.loader=wa,this.key=this.id=Ga,this.meta={url:Ga}}function L(wa,Ga,Ua,Fa,qa,za){if(Ga.module)return Ga.module;if(Ga.evalError)throw Ga.evalError;if(za&&-1!==za.indexOf(Ga))return Ga.linkRecord.moduleObj;var Ja=j(wa,Ga,Ua,Fa,qa,Ua.setters?[]:za||[]);if(Ja)throw Ja;return Ga.module}function A(wa,Ga,Ua,Fa,qa,za,Ja){return function(Ya){for(var Ba=0;Ba<Ua.length;Ba++)if(Ua[Ba]===Ya){var Va,Ha=Fa[Ba];return Va=Ha instanceof h?Ha:L(wa,Ha,Ha.linkRecord,qa,za,Ja),'__useDefault'in Va?Va.__useDefault:Va}throw new Error('Module '+Ya+' not declared as a System.registerDynamic dependency of '+Ga)}}function j(wa,Ga,Ua,Fa,qa,za){za.push(Ga);var Ja;if(Ua.setters)for(var Ya,Ba,Ha=0;Ha<Ua.dependencies.length;Ha++)if(Ya=Ua.dependencyInstantiations[Ha],!(Ya instanceof h)&&(Ba=Ya.linkRecord,Ba&&-1===za.indexOf(Ya)&&(Ya.evalError?Ja=Ya.evalError:Ja=j(wa,Ya,Ba,Fa,qa,Ba.setters?za:[])),Ja))return Ga.linkRecord=void 0,Ga.evalError=n(Ja,'Evaluating '+Ga.key),Ga.evalError;if(Ua.execute)if(Ua.setters)Ja=N(Ua.execute);else{var Va={id:Ga.key},Wa=Ua.moduleObj;Object.defineProperty(Va,'exports',{configurable:!0,set:function(Za){Wa.default=Wa.__useDefault=Za},get:function(){return Wa.__useDefault}});var $a=A(wa,Ga.key,Ua.dependencies,Ua.dependencyInstantiations,Fa,qa,za);if(!Ua.executingRequire)for(var Ha=0;Ha<Ua.dependencies.length;Ha++)$a(Ua.dependencies[Ha]);Ja=K(Ua.execute,$a,Wa.default,Va),Va.exports!==Wa.default&&(Wa.default=Wa.__useDefault=Va.exports);var Xa=Wa.default;if(Xa&&Xa.__esModule)for(var Qa in Xa)Object.hasOwnProperty.call(Xa,Qa)&&(Wa[Qa]=Xa[Qa])}if(Ga.linkRecord=void 0,Ja)return Ga.evalError=n(Ja,'Evaluating '+Ga.key);if(Fa[Ga.key]=Ga.module=new h(Ua.moduleObj),!Ua.setters){if(Ga.importerSetters)for(var Ha=0;Ha<Ga.importerSetters.length;Ha++)Ga.importerSetters[Ha](Ga.module);Ga.importerSetters=void 0}}function N(wa){try{wa.call(Tt)}catch(Ga){return Ga}}function K(wa,Ga,Ua,Fa){try{var qa=wa.call(ht,Ga,Ua,Fa);void 0!==qa&&(Fa.exports=qa)}catch(za){return za}}function P(){}function D(wa){return wa instanceof h?wa:wa&&wa.__esModule?new h(wa):new h({default:wa,__useDefault:wa})}function G(wa,Ga){(Ga||this.warnings&&'undefined'!=typeof console&&console.warn)&&console.warn(wa)}function U(wa,Ga,Ua){var Fa=new Uint8Array(Ga);return 0===Fa[0]&&97===Fa[1]&&115===Fa[2]?WebAssembly.compile(Ga).then(function(qa){var za=[],Ja=[],Ya={};return WebAssembly.Module.imports&&WebAssembly.Module.imports(qa).forEach(function(Ba){var Ha=Ba.module;Ja.push(function(Va){Ya[Ha]=Va}),-1===za.indexOf(Ha)&&za.push(Ha)}),wa.register(za,function(Ba){return{setters:Ja,execute:function(){Ba(new WebAssembly.Instance(qa,Ya).exports)}}}),Ua(),!0}):Promise.resolve(!1)}function F(wa,Ga){if('.'===wa[0])throw new Error('Node module '+wa+' can\\'t be loaded as it is not a package require.');if(!Dt){var Ua=this._nodeRequire('module'),Fa=decodeURI(Ga.substr(mt?8:7));Dt=new Ua(Fa),Dt.paths=Ua._nodeModulePaths(Fa)}return Dt.require(wa)}function q(wa,Ga){for(var Ua in Ga)Object.hasOwnProperty.call(Ga,Ua)&&(wa[Ua]=Ga[Ua]);return wa}function z(wa,Ga){for(var Ua in Ga)Object.hasOwnProperty.call(Ga,Ua)&&void 0===wa[Ua]&&(wa[Ua]=Ga[Ua]);return wa}function J(wa,Ga,Ua){for(var Fa in Ga)if(Object.hasOwnProperty.call(Ga,Fa)){var qa=Ga[Fa];void 0===wa[Fa]?wa[Fa]=qa:qa instanceof Array&&wa[Fa]instanceof Array?wa[Fa]=[].concat(Ua?qa:wa[Fa]).concat(Ua?wa[Fa]:qa):'object'==typeof qa&&null!==qa&&'object'==typeof wa[Fa]?wa[Fa]=(Ua?z:q)(q({},wa[Fa]),qa):!Ua&&(wa[Fa]=qa)}}function Y(wa){if(!wt&&!Gt){var Ga=new Image;return void(Ga.src=wa)}var Ua=document.createElement('link');wt?(Ua.rel='preload',Ua.as='script'):Ua.rel='prefetch',Ua.href=wa,document.head.appendChild(Ua),document.head.removeChild(Ua)}function B(wa,Ga,Ua){try{importScripts(wa)}catch(Fa){Ua(Fa)}Ga()}function H(wa,Ga,Ua,Fa,qa){function za(){Fa(),Ya()}function Ja(){Ya(),qa(new Error('Fetching '+wa))}function Ya(){for(var Ha=0;Ha<Ut.length;Ha++)if(Ut[Ha].err===Ja){Ut.splice(Ha,1);break}Ba.removeEventListener('load',za,!1),Ba.removeEventListener('error',Ja,!1),document.head.removeChild(Ba)}if(wa=wa.replace(/#/g,'%23'),Pt)return B(wa,Fa,qa);var Ba=document.createElement('script');Ba.type='text/javascript',Ba.charset='utf-8',Ba.async=!0,Ga&&(Ba.crossOrigin=Ga),Ua&&(Ba.integrity=Ua),Ba.addEventListener('load',za,!1),Ba.addEventListener('error',Ja,!1),Ba.src=wa,document.head.appendChild(Ba)}function V(wa,Ga){for(var Ua=wa.split('.');Ua.length;)Ga=Ga[Ua.shift()];return Ga}function W(wa,Ga,Ua){var Fa=X(Ga,Ua);if(Fa){var qa=Ga[Fa]+Ua.substr(Fa.length),za=s(qa,bt);return void 0===za?wa+qa:za}return-1===Ua.indexOf(':')?wa+Ua:Ua}function $(wa){var Ga=this.name;if(Ga.substr(0,wa.length)===wa&&(Ga.length===wa.length||'/'===Ga[wa.length]||'/'===wa[wa.length-1]||':'===wa[wa.length-1])){var Ua=wa.split('/').length;Ua>this.len&&(this.match=wa,this.len=Ua)}}function X(wa,Ga){if(Object.hasOwnProperty.call(wa,Ga))return Ga;var Ua={name:Ga,match:void 0,len:0};return Object.keys(wa).forEach($,Ua),Ua.match}function Z(wa,Ga,Ua,Fa){return new Promise(function(qa,za){function Ja(){qa(Fa?Ba.response:Ba.responseText)}function Ya(){za(new Error('XHR error: '+(Ba.status?' ('+Ba.status+(Ba.statusText?' '+Ba.statusText:'')+')':'')+' loading '+wa))}wa=wa.replace(/#/g,'%23');var Ba=new XMLHttpRequest;Fa&&(Ba.responseType='arraybuffer'),Ba.onreadystatechange=function(){4===Ba.readyState&&(0==Ba.status?Ba.response?Ja():(Ba.addEventListener('error',Ya),Ba.addEventListener('load',Ja)):200===Ba.status?Ja():Ya())},Ba.open('GET',wa,!0),Ba.setRequestHeader&&(Ba.setRequestHeader('Accept','application/x-es-module, */*'),Ga&&('string'==typeof Ga&&Ba.setRequestHeader('Authorization',Ga),Ba.withCredentials=!0)),Ba.send(null)})}function ae(){return{pluginKey:void 0,pluginArgument:void 0,pluginModule:void 0,packageKey:void 0,packageConfig:void 0,load:void 0}}function ne(wa,Ga,Ua){var Fa=ae();if(Ua){var qa;Ga.pluginFirst?-1!==(qa=Ua.lastIndexOf('!'))&&(Fa.pluginArgument=Fa.pluginKey=Ua.substr(0,qa)):-1!==(qa=Ua.indexOf('!'))&&(Fa.pluginArgument=Fa.pluginKey=Ua.substr(qa+1)),Fa.packageKey=X(Ga.packages,Ua),Fa.packageKey&&(Fa.packageConfig=Ga.packages[Fa.packageKey])}return Fa}function se(wa,Ga){var Ua=ge(wa.pluginFirst,Ga);if(Ua){var Fa=se.call(this,wa,Ua.plugin);return ce(wa.pluginFirst,oe.call(this,wa,Ua.argument,void 0,!1,!1),Fa)}return oe.call(this,wa,Ga,void 0,!1,!1)}function le(wa,Ga){var Ua=this[Nt],Fa=ae(),qa=qa||ne(this,Ua,Ga),za=ge(Ua.pluginFirst,wa);return za?(Fa.pluginKey=le.call(this,za.plugin,Ga),ce(Ua.pluginFirst,ie.call(this,Ua,za.argument,qa.pluginArgument||Ga,Fa,qa,!!Fa.pluginKey),Fa.pluginKey)):ie.call(this,Ua,wa,qa.pluginArgument||Ga,Fa,qa,!!Fa.pluginKey)}function oe(wa,Ga,Ua,Fa,qa){var za=s(Ga,Ua||bt);if(za)return W(wa.baseURL,wa.paths,za);if(Fa){var Ja=X(wa.map,Ga);if(Ja&&(Ga=wa.map[Ja]+Ga.substr(Ja.length),za=s(Ga,bt),za))return W(wa.baseURL,wa.paths,za)}if(this.registry.has(Ga))return Ga;if('@node/'===Ga.substr(0,6))return Ga;var Ya=qa&&'/'!==Ga[Ga.length-1],Ba=W(wa.baseURL,wa.paths,Ya?Ga+'/':Ga);return Ya?Ba.substr(0,Ba.length-1):Ba}function ie(wa,Ga,Ua,Fa,qa,za){if(qa&&qa.packageConfig&&'.'!==Ga[0]){var Ja=qa.packageConfig.map,Ya=Ja&&X(Ja,Ga);if(Ya&&'string'==typeof Ja[Ya]){var Ba=ye(this,wa,qa.packageConfig,qa.packageKey,Ya,Ga,Fa,za);if(Ba)return Ba}}var Ha=oe.call(this,wa,Ga,Ua,!0,!0),Va=ve(wa,Ha);if(Fa.packageKey=Va&&Va.packageKey||X(wa.packages,Ha),!Fa.packageKey)return Ha;if(-1!==wa.packageConfigKeys.indexOf(Ha))return Fa.packageKey=void 0,Ha;Fa.packageConfig=wa.packages[Fa.packageKey]||(wa.packages[Fa.packageKey]=je());var Wa=Ha.substr(Fa.packageKey.length+1);return me(this,wa,Fa.packageConfig,Fa.packageKey,Wa,Fa,za)}function de(wa,Ga,Ua,Fa,qa,za){var Ja=this;return Lt.then(function(){if(qa&&qa.packageConfig&&'./'!==Ga.substr(0,2)){var Ya=qa.packageConfig.map,Ba=Ya&&X(Ya,Ga);if(Ba)return ke(Ja,wa,qa.packageConfig,qa.packageKey,Ba,Ga,Fa,za)}return Lt}).then(function(Ya){if(Ya)return Ya;var Ba=oe.call(Ja,wa,Ga,Ua,!0,!0),Ha=ve(wa,Ba);if(Fa.packageKey=Ha&&Ha.packageKey||X(wa.packages,Ba),!Fa.packageKey)return Promise.resolve(Ba);if(-1!==wa.packageConfigKeys.indexOf(Ba))return Fa.packageKey=void 0,Fa.load=pe(),Fa.load.format='json',Fa.load.loader='',Promise.resolve(Ba);Fa.packageConfig=wa.packages[Fa.packageKey]||(wa.packages[Fa.packageKey]=je());var Va=Ha&&!Fa.packageConfig.configured;return(Va?Ee(Ja,wa,Ha.configPath,Fa):Lt).then(function(){var Wa=Ba.substr(Fa.packageKey.length+1);return be(Ja,wa,Fa.packageConfig,Fa.packageKey,Wa,Fa,za)})})}function pe(){return{extension:'',deps:void 0,format:void 0,loader:void 0,scriptLoad:void 0,globals:void 0,nonce:void 0,integrity:void 0,sourceMap:void 0,exports:void 0,encapsulateGlobal:!1,crossOrigin:void 0,cjsRequireDetection:!0,cjsDeferDepsExecute:!1,esModule:!1}}function ue(wa,Ga,Ua){Ua.load=Ua.load||pe();var qa,Fa=0;for(var za in wa.meta)if(qa=za.indexOf('*'),-1!==qa&&za.substr(0,qa)===Ga.substr(0,qa)&&za.substr(qa+1)===Ga.substr(Ga.length-za.length+qa+1)){var Ja=za.split('/').length;Ja>Fa&&(Fa=Ja),J(Ua.load,wa.meta[za],Fa!==Ja)}if(wa.meta[Ga]&&J(Ua.load,wa.meta[Ga],!1),Ua.packageKey){var Ya=Ga.substr(Ua.packageKey.length+1),Ba={};if(Ua.packageConfig.meta){var Fa=0;Se(Ua.packageConfig.meta,Ya,function(Ha,Va,Wa){Wa>Fa&&(Fa=Wa),J(Ba,Va,Wa&&Fa>Wa)}),J(Ua.load,Ba,!1)}!Ua.packageConfig.format||Ua.pluginKey||Ua.load.loader||(Ua.load.format=Ua.load.format||Ua.packageConfig.format)}}function ge(wa,Ga){var Ua,Fa,qa=wa?Ga.indexOf('!'):Ga.lastIndexOf('!');if(-1!==qa)return wa?(Ua=Ga.substr(qa+1),Fa=Ga.substr(0,qa)):(Ua=Ga.substr(0,qa),Fa=Ga.substr(qa+1)||Ua.substr(Ua.lastIndexOf('.')+1)),{argument:Ua,plugin:Fa}}function ce(wa,Ga,Ua){return wa?Ua+'!'+Ga:Ga+'!'+Ua}function fe(wa,Ga,Ua,Fa,qa){if(!Fa||!Ga.defaultExtension||'/'===Fa[Fa.length-1]||qa)return Fa;var za=!1;if(Ga.meta&&Se(Ga.meta,Fa,function(Ya,Ba,Ha){if(0===Ha||Ya.lastIndexOf('*')!==Ya.length-1)return za=!0}),!za&&wa.meta&&Se(wa.meta,Ua+'/'+Fa,function(Ya,Ba,Ha){if(0===Ha||Ya.lastIndexOf('*')!==Ya.length-1)return za=!0}),za)return Fa;var Ja='.'+Ga.defaultExtension;return Fa.substr(Fa.length-Ja.length)===Ja?Fa:Fa+Ja}function me(wa,Ga,Ua,Fa,qa,za,Ja){if(!qa)if(Ua.main)qa='./'===Ua.main.substr(0,2)?Ua.main.substr(2):Ua.main;else return Fa;if(Ua.map){var Ya='./'+qa,Ba=X(Ua.map,Ya);if(Ba||(Ya='./'+fe(Ga,Ua,Fa,qa,Ja),Ya!='./'+qa&&(Ba=X(Ua.map,Ya))),Ba){var Ha=ye(wa,Ga,Ua,Fa,Ba,Ya,za,Ja);if(Ha)return Ha}}return Fa+'/'+fe(Ga,Ua,Fa,qa,Ja)}function he(wa,Ga,Ua){return Ga.substr(0,wa.length)===wa&&Ua.length>wa.length?!1:!0}function ye(wa,Ga,Ua,Fa,qa,za,Ja,Ya){'/'===za[za.length-1]&&(za=za.substr(0,za.length-1));var Ba=Ua.map[qa];if('object'==typeof Ba)throw new Error('Synchronous conditional normalization not supported sync normalizing '+qa+' in '+Fa);return he(qa,Ba,za)&&'string'==typeof Ba?ie.call(wa,Ga,Ba+za.substr(qa.length),Fa+'/',Ja,Ja,Ya):void 0}function be(wa,Ga,Ua,Fa,qa,za,Ja){if(!qa)if(Ua.main)qa='./'===Ua.main.substr(0,2)?Ua.main.substr(2):Ua.main;else return Promise.resolve(Fa);var Ya,Ba;return Ua.map&&(Ya='./'+qa,Ba=X(Ua.map,Ya),!Ba&&(Ya='./'+fe(Ga,Ua,Fa,qa,Ja),Ya!=='./'+qa&&(Ba=X(Ua.map,Ya)))),(Ba?ke(wa,Ga,Ua,Fa,Ba,Ya,za,Ja):Lt).then(function(Ha){return Ha?Promise.resolve(Ha):Promise.resolve(Fa+'/'+fe(Ga,Ua,Fa,qa,Ja))})}function ke(wa,Ga,Ua,Fa,qa,za,Ja,Ya){'/'===za[za.length-1]&&(za=za.substr(0,za.length-1));var Ba=Ua.map[qa];if('string'==typeof Ba)return he(qa,Ba,za)?de.call(wa,Ga,Ba+za.substr(qa.length),Fa+'/',Ja,Ja,Ya).then(function(Xa){return Oe.call(wa,Xa,Fa+'/',Ja)}):Lt;var Ha=[],Va=[];for(var Wa in Ba){var $a=Re(Wa);Va.push({condition:$a,map:Ba[Wa]}),Ha.push(k.prototype.import.call(wa,$a.module,Fa))}return Promise.all(Ha).then(function(Xa){for(var Qa=0;Qa<Va.length;Qa++){var Za=Va[Qa].condition,en=V(Za.prop,'__useDefault'in Xa[Qa]?Xa[Qa].__useDefault:Xa[Qa]);if(!Za.negate&&en||Za.negate&&!en)return Va[Qa].map}}).then(function(Xa){if(Xa)return he(qa,Xa,za)?de.call(wa,Ga,Xa+za.substr(qa.length),Fa+'/',Ja,Ja,Ya).then(function(Qa){return Oe.call(wa,Qa,Fa+'/',Ja)}):Lt})}function xe(wa){var Ga=wa.lastIndexOf('*'),Ua=Math.max(Ga+1,wa.lastIndexOf('/'));return{length:Ua,regEx:new RegExp('^('+wa.substr(0,Ua).replace(/[.+?^${}()|[\\]\\\\]/g,'\\\\$&').replace(/\\*/g,'[^\\\\/]+')+')(\\\\/|$)'),wildcard:-1!==Ga}}function ve(wa,Ga){for(var Ua,qa,Fa=!1,za=0;za<wa.packageConfigPaths.length;za++){var Ja=wa.packageConfigPaths[za],Ya=Ht[Ja]||(Ht[Ja]=xe(Ja));if(!(Ga.length<Ya.length)){var Ba=Ga.match(Ya.regEx);Ba&&(!Ua||!(Fa&&Ya.wildcard)&&Ua.length<Ba[1].length)&&(Ua=Ba[1],Fa=!Ya.wildcard,qa=Ua+Ja.substr(Ya.length))}}return Ua?{packageKey:Ua,configPath:qa}:void 0}function Ee(wa,Ga,Ua,Fa){var za=wa.pluginLoader||wa;return-1===Ga.packageConfigKeys.indexOf(Ua)&&Ga.packageConfigKeys.push(Ua),za.import(Ua).then(function(Ja){Ne(Fa.packageConfig,Ja,Fa.packageKey,!0,Ga),Fa.packageConfig.configured=!0}).catch(function(Ja){throw n(Ja,'Unable to fetch package configuration file '+Ua)})}function Se(wa,Ga,Ua){var Fa;for(var qa in wa){var za='./'===qa.substr(0,2)?'./':'';if(za&&(qa=qa.substr(2)),Fa=qa.indexOf('*'),-1!==Fa&&qa.substr(0,Fa)===Ga.substr(0,Fa)&&qa.substr(Fa+1)===Ga.substr(Ga.length-qa.length+Fa+1)&&Ua(qa,wa[za+qa],qa.split('/').length))return}var Ja=wa[Ga]&&Object.hasOwnProperty.call(wa,Ga)?wa[Ga]:wa['./'+Ga];Ja&&Ua(Ja,Ja,0)}function Re(wa){var Ga,Ua,Fa,Fa,qa=wa.lastIndexOf('|');return-1===qa?(Fa='~'===wa[0],Ga='default',Ua=wa.substr(Fa),-1!==Vt.indexOf(Ua)&&(Ga=Ua,Ua=null)):(Ga=wa.substr(qa+1),Ua=wa.substr(0,qa),'~'===Ga[0]&&(Fa=!0,Ga=Ga.substr(1))),{module:Ua||'@system-env',prop:Ga,negate:Fa}}function Ie(wa,Ga,Ua){return k.prototype.import.call(this,wa.module,Ga).then(function(Fa){var qa=V(wa.prop,Fa);if(Ua&&'boolean'!=typeof qa)throw new TypeError('Condition did not resolve to a boolean.');return wa.negate?!qa:qa})}function Oe(wa,Ga){var Fa=wa.match(Wt);if(!Fa)return Promise.resolve(wa);var qa=Re.call(this,Fa[0].substr(2,Fa[0].length-3));return Ie.call(this,qa,Ga,!1).then(function(za){if('string'!=typeof za)throw new TypeError('The condition value for '+wa+' doesn\\'t resolve to a string.');if(-1!==za.indexOf('/'))throw new TypeError('Unabled to interpolate conditional '+wa+(Ga?' in '+Ga:'')+'\\n\\tThe condition value '+za+' cannot contain a \"/\" separator.');return wa.replace(Wt,za)})}function Ce(wa,Ga,Ua){for(var qa,Fa=0;Fa<$t.length;Fa++)qa=$t[Fa],Ga[qa]&&ja[qa.substr(0,qa.length-6)]&&Ua(Ga[qa])}function Me(wa,Ga){var Ua={};for(var Fa in wa){var qa=wa[Fa];1<Ga?qa instanceof Array?Ua[Fa]=[].concat(qa):'object'==typeof qa?Ua[Fa]=Me(qa,Ga-1):'packageConfig'!=Fa&&(Ua[Fa]=qa):Ua[Fa]=qa}return Ua}function Te(wa,Ga){var Ua=wa[Ga];return Ua instanceof Array?wa[Ga].concat([]):'object'==typeof Ua?Me(Ua,3):wa[Ga]}function je(){return{defaultExtension:void 0,main:void 0,format:void 0,meta:void 0,map:void 0,packageConfig:void 0,configured:!1}}function Ne(wa,Ga,Ua,Fa,qa){for(var za in Ga)'main'===za||'format'===za||'defaultExtension'===za||'configured'===za?Fa&&void 0!==wa[za]||(wa[za]=Ga[za]):'map'===za?(Fa?z:q)(wa.map=wa.map||{},Ga.map):'meta'===za?(Fa?z:q)(wa.meta=wa.meta||{},Ga.meta):Object.hasOwnProperty.call(Ga,za)&&G.call(qa,'\"'+za+'\" is not a valid package configuration option in package '+Ua);return void 0===wa.defaultExtension&&(wa.defaultExtension='js'),void 0===wa.main&&wa.map&&wa.map['.']?(wa.main=wa.map['.'],delete wa.map['.']):'object'==typeof wa.main&&(wa.map=wa.map||{},wa.map['./@main']=wa.main,wa.main['default']=wa.main['default']||'./',wa.main='@main'),wa}function Ke(wa){return Xt?Qt+new Buffer(wa).toString('base64'):'undefined'==typeof btoa?'':Qt+btoa(unescape(encodeURIComponent(wa)))}function Pe(wa,Ga,Ua,Fa){var qa=wa.lastIndexOf('\\n');if(Ga){if('object'!=typeof Ga)throw new TypeError('load.metadata.sourceMap must be set to an object.');Ga=JSON.stringify(Ga)}return(Fa?'(function(System, SystemJS) {':'')+wa+(Fa?'\\n})(System, System);':'')+('\\n//# sourceURL='==wa.substr(qa,15)?'':'\\n//# sourceURL='+Ua+(Ga?'!transpiled':''))+(Ga&&Ke(Ga)||'')}function De(wa,Ga,Ua,Fa,qa){Zt||(Zt=document.head||document.body||document.documentElement);var za=document.createElement('script');za.text=Pe(Ga,Ua,Fa,!1);var Ya,Ja=window.onerror;if(window.onerror=function(Ba){Ya=addToError(Ba,'Evaluating '+Fa),Ja&&Ja.apply(this,arguments)},we(wa),qa&&za.setAttribute('nonce',qa),Zt.appendChild(za),Zt.removeChild(za),Ge(),window.onerror=Ja,Ya)return Ya}function we(wa){0==na++&&(aa=ht.System),ht.System=ht.SystemJS=wa}function Ge(){0==--na&&(ht.System=ht.SystemJS=aa)}function Ue(wa,Ga,Ua,Fa,qa,za,Ja){if(Ga){if(za&&ra)return De(wa,Ga,Ua,Fa,za);try{we(wa),!ea&&wa._nodeRequire&&(ea=wa._nodeRequire('vm'),ta=ea.runInThisContext('typeof System !== \\'undefined\\' && System')===wa),ta?ea.runInThisContext(Pe(Ga,Ua,Fa,!Ja),{filename:Fa+(Ua?'!transpiled':'')}):(0,eval)(Pe(Ga,Ua,Fa,!Ja)),Ge()}catch(Ya){return Ge(),Ya}}}function Fe(wa){return'file:///'===wa.substr(0,8)?wa.substr(7+!!mt):la&&wa.substr(0,la.length)===la?wa.substr(la.length):wa}function qe(wa,Ga){return Fe(this.normalizeSync(wa,Ga))}function ze(wa){var Ua,Ga=wa.lastIndexOf('!');Ua=-1===Ga?wa:wa.substr(0,Ga);var Fa=Ua.split('/');return Fa.pop(),Fa=Fa.join('/'),{filename:Fe(Ua),dirname:Fe(Fa)}}function Je(wa){function Ga(Ya,Ba){for(var Ha=0;Ha<Ya.length;Ha++)if(Ya[Ha][0]<Ba.index&&Ya[Ha][1]>Ba.index)return!0;return!1}qt.lastIndex=oa.lastIndex=ia.lastIndex=0;var Fa,Ua=[],qa=[],za=[];if(200>wa.length/wa.split('\\n').length){for(;Fa=ia.exec(wa);)qa.push([Fa.index,Fa.index+Fa[0].length]);for(;Fa=oa.exec(wa);)Ga(qa,Fa)||za.push([Fa.index+Fa[1].length,Fa.index+Fa[0].length-1])}for(;Fa=qt.exec(wa);)if(!Ga(qa,Fa)&&!Ga(za,Fa)){var Ja=Fa[1].substr(1,Fa[1].length-2);if(Ja.match(/\"|'/))continue;Ua.push(Ja)}return Ua}function Ye(wa){if(-1===da.indexOf(wa)){try{var Ga=ht[wa]}catch(Ua){da.push(wa)}this(wa,Ga)}}function Be(wa){if('string'==typeof wa)return V(wa,ht);if(!(wa instanceof Array))throw new Error('Global exports must be a string or array.');for(var Ga={},Ua=0;Ua<wa.length;Ua++)Ga[wa[Ua].split('.').pop()]=V(wa[Ua],ht);return Ga}function He(wa,Ga,Ua,Fa){var qa=ht.define;ht.define=void 0;var za;if(Ua)for(var Ja in za={},Ua)za[Ja]=ht[Ja],ht[Ja]=Ua[Ja];return Ga||(pa={},Object.keys(ht).forEach(Ye,function(Ya,Ba){pa[Ya]=Ba})),function(){var Ba,Ya=Ga?Be(Ga):{},Ha=!!Ga;if((!Ga||Fa)&&Object.keys(ht).forEach(Ye,function(Wa,$a){pa[Wa]===$a||void 0===$a||(Fa&&(ht[Wa]=void 0),!Ga&&(Ya[Wa]=$a,void 0==Ba?Ba=$a:!Ha&&Ba!==$a&&(Ha=!0)))}),Ya=Ha?Ya:Ba,za)for(var Va in za)ht[Va]=za[Va];return ht.define=qa,Ya}}function Ve(wa,Ga){wa=wa.replace(oa,'');var Ua=wa.match(ca),Fa=(Ua[1].split(',')[Ga]||'require').replace(fa,''),qa=ma[Fa]||(ma[Fa]=new RegExp(ua+Fa+ga,'g'));qa.lastIndex=0;for(var Ja,za=[];Ja=qa.exec(wa);)za.push(Ja[2]||Ja[3]);return za}function We(wa){return function(Ga,Ua,Fa){wa(Ga,Ua,Fa),Ua=Fa.exports,'object'!=typeof Ua&&'function'!=typeof Ua||'__esModule'in Ua||Object.defineProperty(Fa.exports,'__esModule',{value:!0})}}function $e(wa,Ga){ba=wa,ka=Ga,ya=void 0,ha=!1}function Xe(wa){ya?wa.registerDynamic(ba?ya[0].concat(ba):ya[0],!1,ka?We(ya[1]):ya[1]):ha&&wa.registerDynamic([],!1,P)}function Qe(wa,Ga){wa.load.esModule&&('object'==typeof Ga||'function'==typeof Ga)&&!('__esModule'in Ga)&&Object.defineProperty(Ga,'__esModule',{value:!0})}function et(wa,Ga,Ua){return Ua.pluginKey?wa.import(Ua.pluginKey).then(function(Fa){Ua.pluginModule=Fa,Ua.pluginLoad={name:Ga,address:Ua.pluginArgument,source:void 0,metadata:Ua.load},Ua.load.deps=Ua.load.deps||[]}):Lt}function tt(wa,Ga,Ua){var Fa=wa.depCache[Ua];if(Fa)for(var qa=0;qa<Fa.length;qa++)Ga.normalize(Fa[qa],Ua).then(Y);else{var za=!1;for(var Ja in wa.bundles){for(var Ya,qa=0;qa<wa.bundles[Ja].length;qa++){if(Ya=wa.bundles[Ja][qa],Ya===Ua){za=!0;break}if(-1!==Ya.indexOf('*')){var Ba=Ya.split('*');if(2!==Ba.length){wa.bundles[Ja].splice(qa--,1);continue}if(Ua.substr(0,Ba[0].length)===Ba[0]&&Ua.substr(Ua.length-Ba[1].length,Ba[1].length)===Ba[1]){za=!0;break}}}if(za)return Ga.import(Ja)}}}function at(wa,Ga,Ua,Fa,qa){return Ua.load.exports&&!Ua.load.format&&(Ua.load.format='global'),Lt.then(function(){return Ua.pluginModule&&Ua.pluginModule.locate?Promise.resolve(Ua.pluginModule.locate.call(wa,Ua.pluginLoad)).then(function(za){za&&(Ua.pluginLoad.address=za)}):void 0}).then(function(){return Ua.pluginModule?(qa=!1,Ua.pluginModule.fetch?Ua.pluginModule.fetch.call(wa,Ua.pluginLoad,function(za){return Bt(za.address,Ua.load.authorization,Ua.load.integrity,!1)}):Bt(Ua.pluginLoad.address,Ua.load.authorization,Ua.load.integrity,!1)):Bt(Ga,Ua.load.authorization,Ua.load.integrity,qa)}).then(function(za){return qa&&'string'!=typeof za?U(wa,za,Fa).then(function(Ja){if(!Ja){var Ya=ct?new TextDecoder('utf-8').decode(new Uint8Array(za)):za.toString();return nt(wa,Ga,Ya,Ua,Fa)}}):nt(wa,Ga,za,Ua,Fa)})}function nt(wa,Ga,Ua,Fa,qa){return Promise.resolve(Ua).then(function(za){return('detect'===Fa.load.format&&(Fa.load.format=void 0),dt(za,Fa),!Fa.pluginModule)?za:(Fa.pluginLoad.source=za,Fa.pluginModule.translate?Promise.resolve(Fa.pluginModule.translate.call(wa,Fa.pluginLoad,Fa.traceOpts)).then(function(Ja){if(Fa.load.sourceMap){if('object'!=typeof Fa.load.sourceMap)throw new Error('metadata.load.sourceMap must be set to an object.');lt(Fa.pluginLoad.address,Fa.load.sourceMap)}return'string'==typeof Ja?Ja:Fa.pluginLoad.source}):za)}).then(function(za){return Fa.load.format||'\"bundle\"'!==za.substring(0,8)?'register'===Fa.load.format||!Fa.load.format&&rt(za)?(Fa.load.format='register',za):'esm'!==Fa.load.format&&(Fa.load.format||!za.match(Sa))?za:(Fa.load.format='esm',ot(wa,za,Ga,Fa,qa)):(Fa.load.format='system',za)}).then(function(za){if('string'!=typeof za||!Fa.pluginModule||!Fa.pluginModule.instantiate)return za;var Ja=!1;return Fa.pluginLoad.source=za,Promise.resolve(Fa.pluginModule.instantiate.call(wa,Fa.pluginLoad,function(Ya){if(za=Ya.source,Fa.load=Ya.metadata,Ja)throw new Error('Instantiate must only be called once.');Ja=!0})).then(function(Ya){return Ja?za:D(Ya)})}).then(function(za){if('string'!=typeof za)return za;Fa.load.format||(Fa.load.format=st(za));var Ja=!1;switch(Fa.load.format){case'esm':case'register':case'system':var Ya=Ue(wa,za,Fa.load.sourceMap,Ga,Fa.load.integrity,Fa.load.nonce,!1);if(Ya)throw Ya;return qa()?void 0:At;break;case'json':var Ba=JSON.parse(za);return wa.newModule({default:Ba,__useDefault:Ba});case'amd':var Ha=ht.define;ht.define=wa.amdDefine,$e(Fa.load.deps,Fa.load.esModule);var Ya=Ue(wa,za,Fa.load.sourceMap,Ga,Fa.load.integrity,Fa.load.nonce,!1);if(Ja=qa(),Ja||(Xe(wa),Ja=qa()),ht.define=Ha,Ya)throw Ya;break;case'cjs':var Va=Fa.load.deps,Wa=(Fa.load.deps||[]).concat(Fa.load.cjsRequireDetection?Je(za):[]);for(var $a in Fa.load.globals)Fa.load.globals[$a]&&Wa.push(Fa.load.globals[$a]);wa.registerDynamic(Wa,!0,function(Qa,Za,en){if(Qa.resolve=function(dn){return qe.call(wa,dn,en.id)},en.paths=[],en.require=Qa,!Fa.load.cjsDeferDepsExecute&&Va)for(var tn=0;tn<Va.length;tn++)Qa(Va[tn]);var an=ze(en.id),nn={exports:Za,args:[Qa,Za,en,an.filename,an.dirname,ht,ht]},rn='(function (require, exports, module, __filename, __dirname, global, GLOBAL';if(Fa.load.globals)for(var sn in Fa.load.globals)nn.args.push(Qa(Fa.load.globals[sn])),rn+=', '+sn;var ln=ht.define;ht.define=void 0,ht.__cjsWrapper=nn,za=rn+') {'+za.replace(_a,'')+'\\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);';var on=Ue(wa,za,Fa.load.sourceMap,Ga,Fa.load.integrity,Fa.load.nonce,!1);if(on)throw on;Qe(Fa,Za),ht.__cjsWrapper=void 0,ht.define=ln}),Ja=qa();break;case'global':var Wa=Fa.load.deps||[];for(var $a in Fa.load.globals){var Xa=Fa.load.globals[$a];Xa&&Wa.push(Xa)}wa.registerDynamic(Wa,!1,function(Qa,Za,en){var tn;if(Fa.load.globals)for(var an in tn={},Fa.load.globals)Fa.load.globals[an]&&(tn[an]=Qa(Fa.load.globals[an]));var nn=Fa.load.exports;nn&&(za+='\\n'+Ea+'[\"'+nn+'\"] = '+nn+';');var rn=He(en.id,nn,tn,Fa.load.encapsulateGlobal),sn=Ue(wa,za,Fa.load.sourceMap,Ga,Fa.load.integrity,Fa.load.nonce,!0);if(sn)throw sn;var ln=rn();return Qe(Fa,ln),ln}),Ja=qa();break;default:throw new TypeError('Unknown module format \"'+Fa.load.format+'\" for \"'+Ga+'\".'+('es6'===Fa.load.format?' Use \"esm\" instead here.':''));}if(!Ja)throw new Error('Module '+Ga+' detected as '+Fa.load.format+' but didn\\'t execute correctly.')})}function rt(wa){var Ga=wa.match(Ra);return Ga&&'System.register'===wa.substr(Ga[0].length,15)}function st(wa){return wa.match(Ia)?'amd':(Oa.lastIndex=0,qt.lastIndex=0,qt.exec(wa)||Oa.exec(wa)?'cjs':'global')}function lt(wa,Ga){var Ua=wa.split('!')[0];Ga.file&&Ga.file!=wa||(Ga.file=Ua+'!transpiled'),Ga.sources&&(!(1>=Ga.sources.length)||Ga.sources[0]&&Ga.sources[0]!==wa)||(Ga.sources=[Ua])}function ot(wa,Ga,Ua,Fa){if(!wa.transpiler)throw new TypeError('Unable to dynamically transpile ES module\\n   A loader plugin needs to be configured via `SystemJS.config({ transpiler: \\'transpiler-module\\' })`.');if(Fa.load.deps){for(var za='',Ja=0;Ja<Fa.load.deps.length;Ja++)za+='import \"'+Fa.load.deps[Ja]+'\"; ';Ga=za+Ga}return wa.import.call(wa,wa.transpiler).then(function(Ya){if(Ya=Ya.__useDefault||Ya,!Ya.translate)throw new Error(wa.transpiler+' is not a valid transpiler plugin.');return Ya===Fa.pluginModule?Ga:('string'==typeof Fa.load.sourceMap&&(Fa.load.sourceMap=JSON.parse(Fa.load.sourceMap)),Fa.pluginLoad=Fa.pluginLoad||{name:Ua,address:Ua,source:Ga,metadata:Fa.load},Fa.load.deps=Fa.load.deps||[],Promise.resolve(Ya.translate.call(wa,Fa.pluginLoad,Fa.traceOpts)).then(function(Ba){var Ha=Fa.load.sourceMap;return Ha&&'object'==typeof Ha&&lt(Ua,Ha),'esm'===Fa.load.format&&rt(Ba)&&(Fa.load.format='register'),Ba}))},function(Ya){throw n(Ya,'Unable to load transpiler to transpile '+Ua)})}function it(wa,Ga,Ua){for(var qa,Fa=Ga.split('.');1<Fa.length;)qa=Fa.shift(),wa=wa[qa]=wa[qa]||{};qa=Fa.shift(),void 0===wa[qa]&&(wa[qa]=Ua)}function dt(wa,Ga){var Ua=wa.match(Ca);if(Ua)for(var Fa=Ua[0].match(Ma),qa=0;qa<Fa.length;qa++){var za=Fa[qa],Ja=za.length,Ya=za.substr(0,1);if(';'==za.substr(Ja-1,1)&&Ja--,'\"'==Ya||'\\''==Ya){var Ba=za.substr(1,za.length-3),Ha=Ba.substr(0,Ba.indexOf(' '));if(Ha){var Va=Ba.substr(Ha.length+1,Ba.length-Ha.length-1);'deps'===Ha&&(Ha='deps[]'),'[]'===Ha.substr(Ha.length-2,2)?(Ha=Ha.substr(0,Ha.length-2),Ga.load[Ha]=Ga.load[Ha]||[],Ga.load[Ha].push(Va)):'use'!==Ha&&it(Ga.load,Ha,Va)}else Ga.load[Ba]=!0}}}function pt(){k.call(this),this._loader={},this[Kt]={},this[Nt]={baseURL:bt,paths:{},packageConfigPaths:[],packageConfigKeys:[],map:{},packages:{},depCache:{},meta:{},bundles:{},production:!1,transpiler:void 0,loadedBundles:{},warnings:!1,pluginFirst:!1,wasm:!1},this.scriptSrc=Ta,this._nodeRequire=va,this.registry.set('@empty',At),ut.call(this,!1,!1),sa(this)}function ut(wa,Ga){this[Nt].production=wa,this.registry.set('@system-env',ja=this.newModule({browser:ct,node:!!this._nodeRequire,production:!Ga&&wa,dev:Ga||!wa,build:Ga,default:!0}))}function gt(wa,Ga){G.call(wa[Nt],'SystemJS.'+Ga+' is deprecated for SystemJS.registry.'+Ga)}var bt,ct='undefined'!=typeof window&&'undefined'!=typeof document,ft='undefined'!=typeof process&&process.versions&&process.versions.node,mt='undefined'!=typeof process&&'string'==typeof process.platform&&process.platform.match(/^win/),ht='undefined'==typeof self?global:self,yt='undefined'!=typeof Symbol;if(!('undefined'!=typeof document&&document.getElementsByTagName))'undefined'!=typeof location&&(bt=location.href);else if(bt=document.baseURI,!bt){var kt=document.getElementsByTagName('base');bt=kt[0]&&kt[0].href||window.location.href}if(bt){bt=bt.split('#')[0].split('?')[0];var xt=bt.lastIndexOf('/');-1!==xt&&(bt=bt.substr(0,xt+1))}else if('undefined'!=typeof process&&process.cwd)bt='file://'+(mt?'/':'')+process.cwd(),mt&&(bt=bt.replace(/\\\\/g,'/'));else throw new TypeError('No environment baseURI');'/'!==bt[bt.length-1]&&(bt+='/');var vt='_'==new Error(0,'_').fileName,Et=Promise.resolve();o.prototype.constructor=o,o.prototype.import=function(wa,Ga){if('string'!=typeof wa)throw new TypeError('Loader import method must be passed a module key string');var Ua=this;return Et.then(function(){return Ua[Rt](wa,Ga)}).then(d).catch(function(Fa){throw n(Fa,'Loading '+wa+(Ga?' from '+Ga:''))})};var St=o.resolve=t('resolve'),Rt=o.resolveInstantiate=t('resolveInstantiate');o.prototype[Rt]=function(wa,Ga){var Ua=this;return Ua.resolve(wa,Ga).then(function(Fa){return Ua.registry.get(Fa)})},o.prototype.resolve=function(wa,Ga){var Ua=this;return Et.then(function(){return Ua[St](wa,Ga)}).then(u).catch(function(Fa){throw n(Fa,'Resolving '+wa+(Ga?' to '+Ga:''))})};var It='undefined'!=typeof Symbol&&Symbol.iterator,Ot=t('registry');It&&(f.prototype[Symbol.iterator]=function(){return this.entries()[Symbol.iterator]()},f.prototype.entries=function(){var wa=this[Ot];return l(Object.keys(wa).map(function(Ga){return[Ga,wa[Ga]]}))}),f.prototype.keys=function(){return l(Object.keys(this[Ot]))},f.prototype.values=function(){var wa=this[Ot];return l(Object.keys(wa).map(function(Ga){return wa[Ga]}))},f.prototype.get=function(wa){return this[Ot][wa]},f.prototype.set=function(wa,Ga){if(!(Ga instanceof h))throw new Error('Registry must be set with an instance of Module Namespace');return this[Ot][wa]=Ga,this},f.prototype.has=function(wa){return Object.hasOwnProperty.call(this[Ot],wa)},f.prototype.delete=function(wa){return!!Object.hasOwnProperty.call(this[Ot],wa)&&(delete this[Ot][wa],!0)};var _t=t('baseObject');h.prototype=Object.create(null),'undefined'!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(h.prototype,Symbol.toStringTag,{value:'Module'});var Ct=t('register-internal');k.prototype=Object.create(o.prototype),k.prototype.constructor=k;var Mt=k.instantiate=t('instantiate');k.prototype[k.resolve=o.resolve]=function(wa,Ga){return s(wa,Ga||bt)},k.prototype[Mt]=function(){},k.prototype[o.resolveInstantiate]=function(wa,Ga){var Ua=this,Fa=this[Ct],qa=this.registry[Ot];return E(Ua,wa,Ga,qa,Fa).then(function(za){if(za instanceof h)return za;var Ja=za.linkRecord;if(!Ja){if(za.module)return za.module;throw za.evalError}return M(Ua,za,Ja,qa,Fa).then(function(){return L(Ua,za,Ja,qa,Fa,void 0)})})},k.prototype.register=function(wa,Ga,Ua){var Fa=this[Ct];if(void 0===Ua)Fa.lastRegister=[wa,Ga,void 0];else{var qa=Fa.records[wa]||x(Fa,wa,void 0);qa.registration=[Ga,Ua,void 0]}},k.prototype.registerDynamic=function(wa,Ga,Ua,Fa){var qa=this[Ct];if('string'!=typeof wa)qa.lastRegister=[wa,Ga,Ua];else{var za=qa.records[wa]||x(qa,wa,void 0);za.registration=[Ga,Ua,Fa]}},T.prototype.import=function(wa){return this.loader.trace&&this.loader.loads[this.key].dynamicDeps.push(wa),this.loader.import(wa,this.key)};var Tt={};Object.freeze&&Object.freeze(Tt);var jt,Dt,Lt=Promise.resolve(),At=new h({}),Nt=t('loader-config'),Kt=t('metadata'),Pt='undefined'==typeof window&&'undefined'!=typeof self&&'undefined'!=typeof importScripts,wt=!1,Gt=!1;if(ct&&function(){var wa=document.createElement('link').relList;if(wa&&wa.supports){Gt=!0;try{wt=wa.supports('preload')}catch(Ga){}}}(),ct){var Ut=[],Ft=window.onerror;window.onerror=function(Ga,Ua){for(var Fa=0;Fa<Ut.length;Fa++)if(Ut[Fa].src===Ua)return void Ut[Fa].err(Ga);Ft&&Ft.apply(this,arguments)}}var zt,Jt,qt=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.\"'])require\\s*\\(\\s*(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\.[^'\\\\]*)*')\\s*\\)/g,Yt='undefined'!=typeof XMLHttpRequest;Jt='undefined'!=typeof self&&'undefined'!=typeof self.fetch?function(wa,Ga,Ua,Fa){if('file:///'===wa.substr(0,8)){if(Yt)return Z(wa,Ga,Ua,Fa);throw new Error('Unable to fetch file URLs in this environment.')}wa=wa.replace(/#/g,'%23');var qa={headers:{Accept:'application/x-es-module, */*'}};Ua&&(qa.integrity=Ua),Ga&&('string'==typeof Ga&&(qa.headers.Authorization=Ga),qa.credentials='include');var za;return za='undefined'!=typeof self&&'undefined'!=typeof self.systemjs_fetch?self.systemjs_fetch:fetch,za(wa,qa).then(function(Ja){if(Ja.ok)return Fa?Ja.arrayBuffer():Ja.text();throw new Error('Fetch error: '+Ja.status+' '+Ja.statusText)})}:Yt?Z:'undefined'!=typeof require&&'undefined'!=typeof process?function(wa,Ga,Ua,Fa){return'file:///'==wa.substr(0,8)?(zt=zt||require('fs'),wa=mt?wa.replace(/\\//g,'\\\\').substr(8):wa.substr(7),new Promise(function(qa,za){zt.readFile(wa,function(Ja,Ya){if(Ja)return za(Ja);if(Fa)qa(Ya);else{var Ba=Ya+'';'\\uFEFF'===Ba[0]&&(Ba=Ba.substr(1)),qa(Ba)}})})):Promise.reject(new Error('Unable to fetch \"'+wa+'\". Only file URLs of the form file:/// supported running in Node.'))}:function(){throw new Error('No fetch method is defined for this environment.')};var Bt=Jt,Ht={},Vt=['browser','node','dev','build','production','default'],Wt=/#\\{[^\\}]+\\}/,$t=['browserConfig','nodeConfig','devConfig','buildConfig','productionConfig'],Xt='undefined'!=typeof Buffer;try{Xt&&'YQ=='!==new Buffer('a').toString('base64')&&(Xt=!1)}catch(wa){Xt=!1}var Zt,ea,ta,aa,Qt='\\n//# sourceMappingURL=data:application/json;base64,',na=0,ra=!1;ct&&'undefined'!=typeof document&&document.getElementsByTagName&&!(window.chrome&&window.chrome.extension||navigator.userAgent.match(/^Node\\.js/))&&(ra=!0);var la,sa=function(wa){function Ga(Fa,qa,za,Ja){if('object'==typeof Fa&&!(Fa instanceof Array))return Ga.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if('string'==typeof Fa&&'function'==typeof qa&&(Fa=[Fa]),Fa instanceof Array){for(var Ya=[],Ba=0;Ba<Fa.length;Ba++)Ya.push(wa.import(Fa[Ba],Ja));Promise.all(Ya).then(function(Wa){qa&&qa.apply(null,Wa)},za)}else{if('string'==typeof Fa){var Ha=wa.decanonicalize(Fa,Ja),Va=wa.get(Ha);if(!Va)throw new Error('Module not already loaded loading \"'+Fa+'\" as '+Ha+(Ja?' from \"'+Ja+'\".':'.'));return'__useDefault'in Va?Va.__useDefault:Va}throw new TypeError('Invalid require')}}function Ua(Fa,qa,za){function Ja(Va,Wa,$a){for(var Xa=[],Qa=0;Qa<qa.length;Qa++)Xa.push(Va(qa[Qa]));if($a.uri=$a.id,$a.config=P,-1!==Ha&&Xa.splice(Ha,0,$a),-1!==Ba&&Xa.splice(Ba,0,Wa),-1!==Ya){var Za=function(an,nn,rn){return'string'==typeof an&&'function'!=typeof nn?Va(an):Ga.call(wa,an,nn,rn,$a.id)};Za.toUrl=function(an){return wa.normalizeSync(an,$a.id)},Xa.splice(Ya,0,Za)}var en=ht.require;ht.require=Ga;var tn=za.apply(-1===Ba?ht:Wa,Xa);ht.require=en,'undefined'!=typeof tn&&($a.exports=tn)}'string'!=typeof Fa&&(za=qa,qa=Fa,Fa=null),qa instanceof Array||(za=qa,qa=['require','exports','module'].splice(0,za.length)),'function'!=typeof za&&(za=function(Va){return function(){return Va}}(za)),!Fa&&ba&&(qa=qa.concat(ba),ba=void 0);var Ya,Ba,Ha;-1!==(Ya=qa.indexOf('require'))&&(qa.splice(Ya,1),!Fa&&(qa=qa.concat(Ve(za.toString(),Ya)))),-1!==(Ba=qa.indexOf('exports'))&&qa.splice(Ba,1),-1!==(Ha=qa.indexOf('module'))&&qa.splice(Ha,1),Fa?(wa.registerDynamic(Fa,qa,!1,Ja),ya?(ya=void 0,ha=!0):!ha&&(ya=[qa,Ja])):wa.registerDynamic(qa,!1,ka?We(Ja):Ja)}wa.set('@@cjs-helpers',wa.newModule({requireResolve:qe.bind(wa),getPathVars:ze})),wa.set('@@global-helpers',wa.newModule({prepareGlobal:He})),Ua.amd={},wa.amdDefine=Ua,wa.amdRequire=Ga};'undefined'!=typeof window&&'undefined'!=typeof document&&window.location&&(la=location.protocol+'//'+location.hostname+(location.port?':'+location.port:''));var pa,ya,ba,va,oa=/(^|[^\\\\])(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,ia=/(\"[^\"\\\\\\n\\r]*(\\\\.[^\"\\\\\\n\\r]*)*\"|'[^'\\\\\\n\\r]*(\\\\.[^'\\\\\\n\\r]*)*')/g,da=['_g','sessionStorage','localStorage','clipboardData','frames','frameElement','external','mozAnimationStartTime','webkitStorageInfo','webkitIndexedDB','mozInnerScreenY','mozInnerScreenX'],ua='(?:^|[^$_a-zA-Z\\\\xA0-\\\\uFFFF.])',ga='\\\\s*\\\\(\\\\s*(\"([^\"]+)\"|\\'([^\\']+)\\')\\\\s*\\\\)',ca=/\\(([^\\)]*)\\)/,fa=/^\\s+|\\s+$/g,ma={},ha=!1,ka=!1,xa=(ct||Pt)&&'undefined'!=typeof navigator&&navigator.userAgent&&!navigator.userAgent.match(/MSIE (9|10).0/);'undefined'==typeof require||'undefined'==typeof process||process.browser||(va=require);var Ta,Ea='undefined'==typeof self?'global':'self',Sa=/(^\\s*|[}\\);\\n]\\s*)(import\\s*(['\"]|(\\*\\s+as\\s+)?(?!type)([^\"'\\(\\)\\n; ]+)\\s*from\\s*['\"]|\\{)|export\\s+\\*\\s+from\\s+[\"']|export\\s*(\\{|default|function|class|var|const|let|async\\s+function))/,Ra=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*\"[^\"]+\"\\s*;?|\\s*'[^']+'\\s*;?)*\\s*/,Ia=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*(\"[^\"]+\"\\s*,\\s*|'[^']+'\\s*,\\s*)?\\s*(\\[(\\s*((\"[^\"]+\"|'[^']+')\\s*,|\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*(\\s*(\"[^\"]+\"|'[^']+')\\s*,?)?(\\s*(\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*\\s*\\]|function\\s*|{|[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*\\))/,Oa=/(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])(exports\\s*(\\[['\"]|\\.)|module(\\.exports|\\['exports'\\]|\\[\"exports\"\\])\\s*(\\[['\"]|[=,\\.]))/,_a=/^\\#\\!.*/,Ca=/^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*\"[^\"]+\"\\s*;?|\\s*'[^']+'\\s*;?)+/,Ma=/\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\/\\/[^\\n]*|\"[^\"]+\"\\s*;?|'[^']+'\\s*;?/g;if('undefined'==typeof Promise)throw new Error('SystemJS needs a Promise polyfill.');if('undefined'!=typeof document){var La=document.getElementsByTagName('script'),Aa=La[La.length-1];document.currentScript&&(Aa.defer||Aa.async)&&(Aa=document.currentScript),Ta=Aa&&Aa.src}else if('undefined'!=typeof importScripts)try{throw new Error('_')}catch(wa){wa.stack.replace(/(?:at|@).*(http.+):[\\d]+:[\\d]+/,function(Ga,Ua){Ta=Ua})}else'undefined'!=typeof __filename&&(Ta=__filename);var ja;pt.prototype=Object.create(k.prototype),pt.prototype.constructor=pt,pt.prototype[pt.resolve=k.resolve]=pt.prototype.normalize=function(wa,Ga){var Ua=this[Nt],Fa=ae(),qa=ne(this,Ua,Ga),za=this;return Promise.resolve().then(function(){var Ja=wa.lastIndexOf('#?');if(-1===Ja)return Promise.resolve(wa);var Ya=Re.call(za,wa.substr(Ja+2));return Ie.call(za,Ya,Ga,!0).then(function(Ba){return Ba?wa.substr(0,Ja):'@empty'})}).then(function(Ja){var Ya=ge(Ua.pluginFirst,Ja);return Ya?(Fa.pluginKey=Ya.plugin,Promise.all([de.call(za,Ua,Ya.argument,qa&&qa.pluginArgument||Ga,Fa,qa,!0),za.resolve(Ya.plugin,Ga)]).then(function(Ba){if(Fa.pluginArgument=Ba[0],Fa.pluginKey=Ba[1],Fa.pluginArgument===Fa.pluginKey)throw new Error('Plugin '+Fa.pluginArgument+' cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.');return ce(Ua.pluginFirst,Ba[0],Ba[1])})):de.call(za,Ua,Ja,qa&&qa.pluginArgument||Ga,Fa,qa,!1)}).then(function(Ja){return Oe.call(za,Ja,Ga,qa)}).then(function(Ja){return ue.call(za,Ua,Ja,Fa),Fa.pluginKey||!Fa.load.loader?Ja:za.resolve(Fa.load.loader,Ja).then(function(Ya){return Fa.pluginKey=Ya,Fa.pluginArgument=Ja,Ja})}).then(function(Ja){return za[Kt][Ja]=Fa,Ja})},pt.prototype.load=function(wa,Ga){return G.call(this[Nt],'System.load is deprecated.'),this.import(wa,Ga)},pt.prototype.decanonicalize=pt.prototype.normalizeSync=pt.prototype.resolveSync=le,pt.prototype[pt.instantiate=k.instantiate]=function(wa,Ga){var Ua=this,Fa=this[Nt];return(tt(Fa,this,wa)||Lt).then(function(){if(!Ga()){var qa=Ua[Kt][wa];if('@node/'===wa.substr(0,6)){if(!Ua._nodeRequire)throw new TypeError('Error loading '+wa+'. Can only load node core modules in Node.');return Ua.registerDynamic([],!1,function(){return F.call(Ua,wa.substr(6),Ua.baseURL)}),void Ga()}return qa.load.scriptLoad?(qa.load.pluginKey||!xa)&&(qa.load.scriptLoad=!1,G.call(Fa,'scriptLoad not supported for \"'+wa+'\"')):!1!==qa.load.scriptLoad&&!qa.load.pluginKey&&xa&&!qa.load.deps&&!qa.load.globals&&('system'===qa.load.format||'register'===qa.load.format||'global'===qa.load.format&&qa.load.exports)&&(qa.load.scriptLoad=!0),qa.load.scriptLoad?new Promise(function(za,Ja){if('amd'===qa.load.format&&ht.define!==Ua.amdDefine)throw new Error('Loading AMD with scriptLoad requires setting the global `'+Ea+'.define = SystemJS.amdDefine`');H(wa,qa.load.crossOrigin,qa.load.integrity,function(){if(!Ga()){qa.load.format='global';var Ya=qa.load.exports&&Be(qa.load.exports);Ua.registerDynamic([],!1,function(){return Qe(qa,Ya),Ya}),Ga()}za()},Ja)}):et(Ua,wa,qa).then(function(){return at(Ua,wa,qa,Ga,Fa.wasm)})}}).then(function(qa){return delete Ua[Kt][wa],qa})},pt.prototype.config=function(wa,Ga){var Ua=this,Fa=this[Nt];if('warnings'in wa&&(Fa.warnings=wa.warnings),'wasm'in wa&&(Fa.wasm='undefined'!=typeof WebAssembly&&wa.wasm),('production'in wa||'build'in wa)&&ut.call(Ua,!!wa.production,!!(wa.build||ja&&ja.build)),!Ga){var qa;for(var za in Ce(Ua,wa,function(an){qa=qa||an.baseURL}),qa=qa||wa.baseURL,qa&&(Fa.baseURL=s(qa,bt)||s('./'+qa,bt),'/'!==Fa.baseURL[Fa.baseURL.length-1]&&(Fa.baseURL+='/')),wa.paths&&q(Fa.paths,wa.paths),Ce(Ua,wa,function(an){an.paths&&q(Fa.paths,an.paths)}),Fa.paths)-1!==Fa.paths[za].indexOf('*')&&(G.call(Fa,'Path config '+za+' -> '+Fa.paths[za]+' is no longer supported as wildcards are deprecated.'),delete Fa.paths[za])}if(wa.defaultJSExtensions&&G.call(Fa,'The defaultJSExtensions configuration option is deprecated.\\n  Use packages defaultExtension instead.',!0),'boolean'==typeof wa.pluginFirst&&(Fa.pluginFirst=wa.pluginFirst),wa.map)for(var za in wa.map){var Ja=wa.map[za];if('string'==typeof Ja){var Ya=oe.call(Ua,Fa,Ja,void 0,!1,!1);'/'===Ya[Ya.length-1]&&':'!==za[za.length-1]&&'/'!==za[za.length-1]&&(Ya=Ya.substr(0,Ya.length-1)),Fa.map[za]=Ya}else{var Ba=oe.call(Ua,Fa,'/'===za[za.length-1]?za:za+'/',void 0,!0,!0);Ba=Ba.substr(0,Ba.length-1);var Ha=Fa.packages[Ba];Ha||(Ha=Fa.packages[Ba]=je(),Ha.defaultExtension=''),Ne(Ha,{map:Ja},Ba,!1,Fa)}}if(wa.packageConfigPaths){for(var Va=[],Wa=0;Wa<wa.packageConfigPaths.length;Wa++){var $a=wa.packageConfigPaths[Wa],Xa=Math.max($a.lastIndexOf('*')+1,$a.lastIndexOf('/')),Qa=oe.call(Ua,Fa,$a.substr(0,Xa),void 0,!1,!1);Va[Wa]=Qa+$a.substr(Xa)}Fa.packageConfigPaths=Va}if(wa.bundles)for(var za in wa.bundles){for(var Za=[],Wa=0;Wa<wa.bundles[za].length;Wa++)Za.push(Ua.normalizeSync(wa.bundles[za][Wa]));Fa.bundles[za]=Za}if(wa.packages)for(var za in wa.packages){if(za.match(/^([^\\/]+:)?\\/\\/$/))throw new TypeError('\"'+za+'\" is not a valid package name.');var Ba=oe.call(Ua,Fa,'/'===za[za.length-1]?za:za+'/',void 0,!0,!0);Ba=Ba.substr(0,Ba.length-1),Ne(Fa.packages[Ba]=Fa.packages[Ba]||je(),wa.packages[za],Ba,!1,Fa)}if(wa.depCache)for(var za in wa.depCache)Fa.depCache[Ua.normalizeSync(za)]=[].concat(wa.depCache[za]);if(wa.meta)for(var za in wa.meta)if('*'===za[0])q(Fa.meta[za]=Fa.meta[za]||{},wa.meta[za]);else{var en=oe.call(Ua,Fa,za,void 0,!0,!0);q(Fa.meta[en]=Fa.meta[en]||{},wa.meta[za])}for(var tn in'transpiler'in wa&&(Fa.transpiler=wa.transpiler),wa)-1===Na.indexOf(tn)&&-1===$t.indexOf(tn)&&(Ua[tn]=wa[tn]);Ce(Ua,wa,function(an){Ua.config(an,!0)})},pt.prototype.getConfig=function(wa){if(wa){if(-1!==Na.indexOf(wa))return Te(this[Nt],wa);throw new Error('\"'+wa+'\" is not a valid configuration name. Must be one of '+Na.join(', ')+'.')}for(var Ga={},Ua=0;Ua<Na.length;Ua++){var Fa=Na[Ua],qa=Te(this[Nt],Fa);void 0!==qa&&(Ga[Fa]=qa)}return Ga},pt.prototype.global=ht,pt.prototype.import=function(){return k.prototype.import.apply(this,arguments).then(function(wa){return'__useDefault'in wa?wa.__useDefault:wa})};for(var Na=['baseURL','map','paths','packages','packageConfigPaths','depCache','meta','bundles','transpiler','warnings','pluginFirst','production','wasm'],Ka='undefined'!=typeof Proxy,Pa=0;Pa<Na.length;Pa++)(function(wa){Object.defineProperty(pt.prototype,wa,{get:function(){var Ga=Te(this[Nt],wa);return Ka&&'object'==typeof Ga&&(Ga=new Proxy(Ga,{set:function(Ua,Fa){throw new Error('Cannot set SystemJS.'+wa+'[\"'+Fa+'\"] directly. Use SystemJS.config({ '+wa+': { \"'+Fa+'\": ... } }) rather.')}})),Ga},set:function(){throw new Error('Setting `SystemJS.'+wa+'` directly is no longer supported. Use `SystemJS.config({ '+wa+': ... })`.')}})})(Na[Pa]);pt.prototype.delete=function(wa){return gt(this,'delete'),this.registry.delete(wa)},pt.prototype.get=function(wa){return gt(this,'get'),this.registry.get(wa)},pt.prototype.has=function(wa){return gt(this,'has'),this.registry.has(wa)},pt.prototype.set=function(wa,Ga){return gt(this,'set'),this.registry.set(wa,Ga)},pt.prototype.newModule=function(wa){return new h(wa)},pt.prototype.isModule=function(wa){return void 0===jt&&(jt='undefined'!=typeof Symbol&&!!Symbol.toStringTag),wa instanceof h||jt&&'[object Module]'==Object.prototype.toString.call(wa)},pt.prototype.register=function(wa,Ga,Ua){return'string'==typeof wa&&(wa=se.call(this,this[Nt],wa)),k.prototype.register.call(this,wa,Ga,Ua)},pt.prototype.registerDynamic=function(wa,Ga,Ua,Fa){return'string'==typeof wa&&(wa=se.call(this,this[Nt],wa)),k.prototype.registerDynamic.call(this,wa,Ga,Ua,Fa)},pt.prototype.version='0.20.18 Dev';var Da=new pt;(ct||Pt)&&(ht.SystemJS=ht.System=Da),'undefined'!=typeof module&&module.exports&&(module.exports=Da)})();\n\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./src/jspm_packages/system.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./src/jspm_packages/system.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./src/jspm_packages/system.js */ "./node_modules/raw-loader/index.js!./src/jspm_packages/system.js"))

/***/ }),

/***/ "./node_modules/semver/semver.js":
/*!***************************************!*\
  !*** ./node_modules/semver/semver.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

// The actual regexps go on exports.re
var re = exports.re = []
var safeRe = exports.safeRe = []
var src = exports.src = []
var R = 0

var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
var safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

function makeSafeRe (value) {
  for (var i = 0; i < safeRegexReplacements.length; i++) {
    var token = safeRegexReplacements[i][0]
    var max = safeRegexReplacements[i][1]
    value = value
      .split(token + '*').join(token + '{0,' + max + '}')
      .split(token + '+').join(token + '{1,' + max + '}')
  }
  return value
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '\\d+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])

    // Replace all greedy whitespace to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    safeRe[i] = new RegExp(makeSafeRe(src[i]))
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? safeRe[LOOSE] : safeRe[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  comp = comp.trim().split(/\s+/).join(' ')
  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First reduce all whitespace as much as possible so we do not have to rely
  // on potentially slow regexes like \s*. This is then stored and used for
  // future error messages as well.
  this.raw = range
    .trim()
    .split(/\s+/)
    .join(' ')

  // First, split based on boolean or ||
  this.set = this.raw.split('||').map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + this.raw)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, safeRe[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(safeRe[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(safeRe[CARETTRIM], caretTrimReplace)

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.
  var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(safeRe[STAR], '')
}

// This function is passed to string.replace(safeRe[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(safeRe[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/shuffle-array/index.js":
/*!*********************************************!*\
  !*** ./node_modules/shuffle-array/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Randomize the order of the elements in a given array.
 * @param {Array} arr - The given array.
 * @param {Object} [options] - Optional configuration options.
 * @param {Boolean} [options.copy] - Sets if should return a shuffled copy of the given array. By default it's a falsy value.
 * @param {Function} [options.rng] - Specifies a custom random number generator.
 * @returns {Array}
 */
function shuffle(arr, options) {

  if (!Array.isArray(arr)) {
    throw new Error('shuffle expect an array as parameter.');
  }

  options = options || {};

  var collection = arr,
      len = arr.length,
      rng = options.rng || Math.random,
      random,
      temp;

  if (options.copy === true) {
    collection = arr.slice();
  }

  while (len) {
    random = Math.floor(rng() * len);
    len -= 1;
    temp = collection[len];
    collection[len] = collection[random];
    collection[random] = temp;
  }

  return collection;
};

/**
 * Pick one or more random elements from the given array.
 * @param {Array} arr - The given array.
 * @param {Object} [options] - Optional configuration options.
 * @param {Number} [options.picks] - Specifies how many random elements you want to pick. By default it picks 1.
 * @param {Function} [options.rng] - Specifies a custom random number generator.
 * @returns {Object}
 */
shuffle.pick = function(arr, options) {

  if (!Array.isArray(arr)) {
    throw new Error('shuffle.pick() expect an array as parameter.');
  }

  options = options || {};

  var rng = options.rng || Math.random,
      picks = options.picks || 1;

  if (typeof picks === 'number' && picks !== 1) {
    var len = arr.length,
        collection = arr.slice(),
        random = [],
        index;

    while (picks && len) {
      index = Math.floor(rng() * len);
      random.push(collection[index]);
      collection.splice(index, 1);
      len -= 1;
      picks -= 1;
    }

    return random;
  }

  return arr[Math.floor(rng() * arr.length)];
};

/**
 * Expose
 */
module.exports = shuffle;


/***/ }),

/***/ "./node_modules/shuffled/index.js":
/*!****************************************!*\
  !*** ./node_modules/shuffled/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function(){
  var shuffle, exports;
  shuffle = __webpack_require__(/*! shuffle-array */ "./node_modules/shuffle-array/index.js");
  module.exports = exports = function(arr){
    return shuffle(arr, {
      copy: true
    });
  };
}).call(this);


/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/underscore/modules/_baseCreate.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseCreate.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return baseCreate; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype)) return {};
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeCreate"]) return Object(_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeCreate"])(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_baseIteratee.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_baseIteratee.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return baseIteratee; });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");








// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) return Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, context, argCount);
  if (Object(_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) && !Object(_isArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) return Object(_matcher_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
  return Object(_property_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_cb.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/_cb.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cb; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");
/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");




// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee !== _iteratee_js__WEBPACK_IMPORTED_MODULE_2__["default"]) return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee(value, context);
  return Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, argCount);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_chainResult.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_chainResult.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chainResult; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? Object(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj).chain() : obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_collectNonEnumProps.js":
/*!*****************************************************************!*\
  !*** ./node_modules/underscore/modules/_collectNonEnumProps.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return collectNonEnumProps; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");




// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key] === true; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = _setup_js__WEBPACK_IMPORTED_MODULE_0__["nonEnumerableProps"].length;
  var constructor = obj.constructor;
  var proto = (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(constructor) && constructor.prototype) || _setup_js__WEBPACK_IMPORTED_MODULE_0__["ObjProto"];

  // Constructor is a special case.
  var prop = 'constructor';
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = _setup_js__WEBPACK_IMPORTED_MODULE_0__["nonEnumerableProps"][nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createAssigner.js":
/*!************************************************************!*\
  !*** ./node_modules/underscore/modules/_createAssigner.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createAssigner; });
// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createEscaper.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_createEscaper.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createEscaper; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createIndexFinder.js":
/*!***************************************************************!*\
  !*** ./node_modules/underscore/modules/_createIndexFinder.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createIndexFinder; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");




// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(_setup_js__WEBPACK_IMPORTED_MODULE_1__["slice"].call(array, i, length), _isNaN_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createPredicateIndexFinder.js":
/*!************************************************************************!*\
  !*** ./node_modules/underscore/modules/_createPredicateIndexFinder.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createPredicateIndexFinder; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
    var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createReduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_createReduce.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createReduce; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");




// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context, 4), memo, initial);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_createSizePropertyCheck.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/_createSizePropertyCheck.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createSizePropertyCheck; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= _setup_js__WEBPACK_IMPORTED_MODULE_0__["MAX_ARRAY_INDEX"];
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/_deepGet.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_deepGet.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return deepGet; });
// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_escapeMap.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_escapeMap.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Internal list of HTML entities for escaping.
/* harmony default export */ __webpack_exports__["default"] = ({
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
});


/***/ }),

/***/ "./node_modules/underscore/modules/_executeBound.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_executeBound.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return executeBound; });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");



// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = Object(_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (Object(_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) return result;
  return self;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/_flatten.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return flatten; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");





// Internal implementation of a recursive `flatten` function.
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input); i < length; i++) {
    var value = input[i];
    if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_getByteLength.js":
/*!***********************************************************!*\
  !*** ./node_modules/underscore/modules/_getByteLength.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `byteLength` property of an object.
/* harmony default export */ __webpack_exports__["default"] = (Object(_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('byteLength'));


/***/ }),

/***/ "./node_modules/underscore/modules/_getLength.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_getLength.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shallowProperty.js */ "./node_modules/underscore/modules/_shallowProperty.js");


// Internal helper to obtain the `length` property of an object.
/* harmony default export */ __webpack_exports__["default"] = (Object(_shallowProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('length'));


/***/ }),

/***/ "./node_modules/underscore/modules/_group.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_group.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return group; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_has.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/_has.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return has; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function to check whether `key` is an own property name of `obj`.
function has(obj, key) {
  return obj != null && _setup_js__WEBPACK_IMPORTED_MODULE_0__["hasOwnProperty"].call(obj, key);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_hasObjectTag.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_hasObjectTag.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Object'));


/***/ }),

/***/ "./node_modules/underscore/modules/_isArrayLike.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_isArrayLike.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
/* harmony default export */ __webpack_exports__["default"] = (Object(_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_isBufferLike.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_isBufferLike.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createSizePropertyCheck.js */ "./node_modules/underscore/modules/_createSizePropertyCheck.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");



// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createSizePropertyCheck_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_getByteLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/_keyInObj.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/_keyInObj.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return keyInObj; });
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/_methodFingerprint.js":
/*!***************************************************************!*\
  !*** ./node_modules/underscore/modules/_methodFingerprint.js ***!
  \***************************************************************/
/*! exports provided: ie11fingerprint, mapMethods, weakMapMethods, setMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ie11fingerprint", function() { return ie11fingerprint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapMethods", function() { return mapMethods; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "weakMapMethods", function() { return weakMapMethods; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMethods", function() { return setMethods; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");




// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(methods);
  return function(obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = Object(_allKeys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    if (Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
    hasName = 'has',
    commonInit = ['clear', 'delete'],
    mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
    weakMapMethods = commonInit.concat(mapTail),
    setMethods = ['add'].concat(commonInit, forEachName, hasName);


/***/ }),

/***/ "./node_modules/underscore/modules/_optimizeCb.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/_optimizeCb.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return optimizeCb; });
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_setup.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/_setup.js ***!
  \***************************************************/
/*! exports provided: VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayProto", function() { return ArrayProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjProto", function() { return ObjProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolProto", function() { return SymbolProto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "push", function() { return push; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOwnProperty", function() { return hasOwnProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsArrayBuffer", function() { return supportsArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsDataView", function() { return supportsDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeIsArray", function() { return nativeIsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeKeys", function() { return nativeKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeCreate", function() { return nativeCreate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nativeIsView", function() { return nativeIsView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isNaN", function() { return _isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isFinite", function() { return _isFinite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasEnumBug", function() { return hasEnumBug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonEnumerableProps", function() { return nonEnumerableProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_ARRAY_INDEX", function() { return MAX_ARRAY_INDEX; });
// Current version.
var VERSION = '1.13.6';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self == 'object' && self.self === self && self) ||
          (typeof global == 'object' && global.global === global && global) ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/underscore/modules/_shallowProperty.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/_shallowProperty.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowProperty; });
// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_stringTagBug.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_stringTagBug.js ***!
  \**********************************************************/
/*! exports provided: hasStringTagBug, isIE11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasStringTagBug", function() { return hasStringTagBug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE11", function() { return isIE11; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasObjectTag.js */ "./node_modules/underscore/modules/_hasObjectTag.js");



// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
var hasStringTagBug = (
      _setup_js__WEBPACK_IMPORTED_MODULE_0__["supportsDataView"] && Object(_hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new DataView(new ArrayBuffer(8)))
    ),
    isIE11 = (typeof Map !== 'undefined' && Object(_hasObjectTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new Map));


/***/ }),

/***/ "./node_modules/underscore/modules/_tagTester.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/_tagTester.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return tagTester; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function(obj) {
    return _setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj) === tag;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/_toBufferView.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/_toBufferView.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toBufferView; });
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");


// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    Object(_getByteLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bufferSource)
  );
}


/***/ }),

/***/ "./node_modules/underscore/modules/_toPath.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/_toPath.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toPath; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPath.js */ "./node_modules/underscore/modules/toPath.js");



// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function toPath(path) {
  return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].toPath(path);
}


/***/ }),

/***/ "./node_modules/underscore/modules/_unescapeMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/_unescapeMap.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Internal list of HTML entities for unescaping.
/* harmony default export */ __webpack_exports__["default"] = (Object(_invert_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/after.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/after.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return after; });
// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/allKeys.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/allKeys.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return allKeys; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");




// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["hasEnumBug"]) Object(_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/before.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/before.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return before; });
// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/bind.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/bind.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");




// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, context, args) {
  if (!Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func)) throw new TypeError('Bind must be called on a function');
  var bound = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(callArgs) {
    return Object(_executeBound_js__WEBPACK_IMPORTED_MODULE_2__["default"])(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/bindAll.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/bindAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");




// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  keys = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = Object(_bind_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj[key], obj);
  }
  return obj;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/chain.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chain.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chain; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = Object(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  instance._chain = true;
  return instance;
}


/***/ }),

/***/ "./node_modules/underscore/modules/chunk.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/chunk.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chunk; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(_setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, i, i += count));
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/clone.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/clone.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clone; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");




// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return obj;
  return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) ? obj.slice() : Object(_extend_js__WEBPACK_IMPORTED_MODULE_2__["default"])({}, obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compact.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compact.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compact; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");


// Trim out all falsy values from an array.
function compact(array) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Boolean);
}


/***/ }),

/***/ "./node_modules/underscore/modules/compose.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/compose.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return compose; });
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return constant; });
// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function() {
    return value;
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/contains.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/contains.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return contains; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");




// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return Object(_indexOf_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, item, fromIndex) >= 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/countBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/countBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key]++; else result[key] = 1;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/create.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/create.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return create; });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/underscore/modules/_baseCreate.js");
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");



// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = Object(_baseCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype);
  if (props) Object(_extendOwn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, props);
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/debounce.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/debounce.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");



// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(_args) {
    context = this;
    args = _args;
    previous = Object(_now_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}


/***/ }),

/***/ "./node_modules/underscore/modules/defaults.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/defaults.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Fill in a given object with default properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"], true));


/***/ }),

/***/ "./node_modules/underscore/modules/defer.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/defer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Defers a function, scheduling it to run after the current call stack has
// cleared.
/* harmony default export */ __webpack_exports__["default"] = (Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_delay_js__WEBPACK_IMPORTED_MODULE_1__["default"], _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"], 1));


/***/ }),

/***/ "./node_modules/underscore/modules/delay.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/delay.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");


// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/difference.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/difference.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, rest) {
  rest = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rest, true, true);
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, function(value){
    return !Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(rest, value);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/each.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/each.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return each; });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var i, length;
  if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/escape.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _escapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeMap.js */ "./node_modules/underscore/modules/_escapeMap.js");



// Function for escaping strings to HTML interpolation.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_escapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/every.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/every.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return every; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/extend.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/extend.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");



// Extend a given object with all the properties in passed-in object(s).
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_allKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/extendOwn.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/extendOwn.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/underscore/modules/_createAssigner.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
/* harmony default export */ __webpack_exports__["default"] = (Object(_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/filter.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/filter.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return filter; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");



// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/find.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/find.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return find; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");




// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _findKey_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}


/***/ }),

/***/ "./node_modules/underscore/modules/findIndex.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findIndex.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the first index on an array-like that passes a truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/findKey.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/findKey.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return findKey; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}


/***/ }),

/***/ "./node_modules/underscore/modules/findLastIndex.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/findLastIndex.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createPredicateIndexFinder.js */ "./node_modules/underscore/modules/_createPredicateIndexFinder.js");


// Returns the last index on an array-like that passes a truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createPredicateIndexFinder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/findWhere.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/findWhere.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return findWhere; });
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return Object(_find_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/first.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/first.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return first; });
/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");


// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return Object(_initial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, array.length - n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/flatten.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/flatten.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return flatten; });
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");


// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten(array, depth) {
  return Object(_flatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, depth, false);
}


/***/ }),

/***/ "./node_modules/underscore/modules/functions.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/functions.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return functions; });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");


// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj[key])) names.push(key);
  }
  return names.sort();
}


/***/ }),

/***/ "./node_modules/underscore/modules/get.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/get.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return get; });
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _isUndefined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isUndefined.js */ "./node_modules/underscore/modules/isUndefined.js");




// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, Object(_toPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path));
  return Object(_isUndefined_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ? defaultValue : value;
}


/***/ }),

/***/ "./node_modules/underscore/modules/groupBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/groupBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key)) result[key].push(value); else result[key] = [value];
}));


/***/ }),

/***/ "./node_modules/underscore/modules/has.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/has.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return has; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has(obj, path) {
  path = Object(_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!Object(_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/identity.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/identity.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return identity; });
// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}


/***/ }),

/***/ "./node_modules/underscore/modules/index-all.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/index-all.js ***!
  \******************************************************/
/*! exports provided: default, VERSION, restArguments, isObject, isNull, isUndefined, isBoolean, isElement, isString, isNumber, isDate, isRegExp, isError, isSymbol, isArrayBuffer, isDataView, isArray, isFunction, isArguments, isFinite, isNaN, isTypedArray, isEmpty, isMatch, isEqual, isMap, isWeakMap, isSet, isWeakSet, keys, allKeys, values, pairs, invert, functions, methods, extend, extendOwn, assign, defaults, create, clone, tap, get, has, mapObject, identity, constant, noop, toPath, property, propertyOf, matcher, matches, times, random, now, escape, unescape, templateSettings, template, result, uniqueId, chain, iteratee, partial, bind, bindAll, memoize, delay, defer, throttle, debounce, wrap, negate, compose, after, before, once, findKey, findIndex, findLastIndex, sortedIndex, indexOf, lastIndexOf, find, detect, findWhere, each, forEach, map, collect, reduce, foldl, inject, reduceRight, foldr, filter, select, reject, every, all, some, any, contains, includes, include, invoke, pluck, where, max, min, shuffle, sample, sortBy, groupBy, indexBy, countBy, partition, toArray, size, pick, omit, first, head, take, initial, last, rest, tail, drop, compact, flatten, without, uniq, unique, union, intersection, difference, unzip, transpose, zip, object, range, chunk, mixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_default_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-default.js */ "./node_modules/underscore/modules/index-default.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _index_default_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["VERSION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restArguments", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["restArguments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNull"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isBoolean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isDate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRegExp", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isRegExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isError", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSymbol", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isSymbol"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDataView", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isFunction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArguments", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isArguments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isFinite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isNaN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isTypedArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isEmpty"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMatch", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakMap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isWeakMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSet", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakSet", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["isWeakSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allKeys", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["allKeys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["values"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pairs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["invert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "functions", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["functions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "methods", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["methods"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["extend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendOwn", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["extendOwn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["assign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["defaults"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["create"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["tap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["get"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["has"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["mapObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["constant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["noop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPath", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["toPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propertyOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["propertyOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["matcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["matches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["times"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["random"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["escape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unescape", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unescape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateSettings", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["templateSettings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "template", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["template"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "result", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["result"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["uniqueId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["chain"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iteratee", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["iteratee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["partial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["bind"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindAll", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["bindAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["memoize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["delay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["defer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["throttle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["debounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["wrap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["negate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["compose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "after", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["after"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "before", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["before"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["once"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findKey", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findLastIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortedIndex", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sortedIndex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["indexOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["lastIndexOf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["find"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detect", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["detect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findWhere", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["findWhere"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["each"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["map"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "collect", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["collect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reduce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldl", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["foldl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["inject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reduceRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldr", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["foldr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["filter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["reject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["every"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "some", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["some"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["contains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["includes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "include", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["include"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoke", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["invoke"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pluck"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["shuffle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sample"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["sortBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["groupBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["indexBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["countBy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["partition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["toArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "size", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["size"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["pick"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["omit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["first"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["head"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["take"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initial", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["initial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["last"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rest", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["rest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["tail"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["drop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compact", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["compact"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["flatten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["without"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["uniq"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unique"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["union"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["intersection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["difference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unzip", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["unzip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["zip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["object"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chunk", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["chunk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixin", function() { return _index_js__WEBPACK_IMPORTED_MODULE_1__["mixin"]; });

// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.




/***/ }),

/***/ "./node_modules/underscore/modules/index-default.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/index-default.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/underscore/modules/index.js");
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```



// Add all of the Underscore functions to the wrapper object.
var _ = Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["mixin"])(_index_js__WEBPACK_IMPORTED_MODULE_0__);
// Legacy Node.js API.
_._ = _;
// Export the Underscore API.
/* harmony default export */ __webpack_exports__["default"] = (_);


/***/ }),

/***/ "./node_modules/underscore/modules/index.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/index.js ***!
  \**************************************************/
/*! exports provided: VERSION, restArguments, isObject, isNull, isUndefined, isBoolean, isElement, isString, isNumber, isDate, isRegExp, isError, isSymbol, isArrayBuffer, isDataView, isArray, isFunction, isArguments, isFinite, isNaN, isTypedArray, isEmpty, isMatch, isEqual, isMap, isWeakMap, isSet, isWeakSet, keys, allKeys, values, pairs, invert, functions, methods, extend, extendOwn, assign, defaults, create, clone, tap, get, has, mapObject, identity, constant, noop, toPath, property, propertyOf, matcher, matches, times, random, now, escape, unescape, templateSettings, template, result, uniqueId, chain, iteratee, partial, bind, bindAll, memoize, delay, defer, throttle, debounce, wrap, negate, compose, after, before, once, findKey, findIndex, findLastIndex, sortedIndex, indexOf, lastIndexOf, find, detect, findWhere, each, forEach, map, collect, reduce, foldl, inject, reduceRight, foldr, filter, select, reject, every, all, some, any, contains, includes, include, invoke, pluck, where, max, min, shuffle, sample, sortBy, groupBy, indexBy, countBy, partition, toArray, size, pick, omit, first, head, take, initial, last, rest, tail, drop, compact, flatten, without, uniq, unique, union, intersection, difference, unzip, transpose, zip, object, range, chunk, mixin, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _setup_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"]; });

/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "restArguments", function() { return _restArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _isNull_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isNull.js */ "./node_modules/underscore/modules/isNull.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return _isNull_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isUndefined.js */ "./node_modules/underscore/modules/isUndefined.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return _isUndefined_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return _isBoolean_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _isElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isElement.js */ "./node_modules/underscore/modules/isElement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return _isElement_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _isString_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _isNumber_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _isDate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./isDate.js */ "./node_modules/underscore/modules/isDate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return _isDate_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isRegExp.js */ "./node_modules/underscore/modules/isRegExp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRegExp", function() { return _isRegExp_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _isError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./isError.js */ "./node_modules/underscore/modules/isError.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isError", function() { return _isError_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSymbol", function() { return _isSymbol_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isArrayBuffer.js */ "./node_modules/underscore/modules/isArrayBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDataView", function() { return _isDataView_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _isArray_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return _isFunction_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArguments", function() { return _isArguments_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _isFinite_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./isFinite.js */ "./node_modules/underscore/modules/isFinite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _isFinite_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _isNaN_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./isNaN.js */ "./node_modules/underscore/modules/isNaN.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _isNaN_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTypedArray", function() { return _isTypedArray_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _isEmpty_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./isEmpty.js */ "./node_modules/underscore/modules/isEmpty.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return _isEmpty_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMatch", function() { return _isMatch_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _isEqual_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./isEqual.js */ "./node_modules/underscore/modules/isEqual.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqual", function() { return _isEqual_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./isMap.js */ "./node_modules/underscore/modules/isMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMap", function() { return _isMap_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _isWeakMap_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./isWeakMap.js */ "./node_modules/underscore/modules/isWeakMap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakMap", function() { return _isWeakMap_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./isSet.js */ "./node_modules/underscore/modules/isSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSet", function() { return _isSet_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _isWeakSet_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./isWeakSet.js */ "./node_modules/underscore/modules/isWeakSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWeakSet", function() { return _isWeakSet_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "allKeys", function() { return _allKeys_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _pairs_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./pairs.js */ "./node_modules/underscore/modules/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _pairs_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _invert_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./invert.js */ "./node_modules/underscore/modules/invert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return _invert_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "functions", function() { return _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "methods", function() { return _functions_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _extend_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./extend.js */ "./node_modules/underscore/modules/extend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _extend_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendOwn", function() { return _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return _extendOwn_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return _defaults_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _create_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./create.js */ "./node_modules/underscore/modules/create.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return _create_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./clone.js */ "./node_modules/underscore/modules/clone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _clone_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _tap_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./tap.js */ "./node_modules/underscore/modules/tap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return _tap_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./get.js */ "./node_modules/underscore/modules/get.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get", function() { return _get_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./has.js */ "./node_modules/underscore/modules/has.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "has", function() { return _has_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _mapObject_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./mapObject.js */ "./node_modules/underscore/modules/mapObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mapObject", function() { return _mapObject_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _identity_js__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return _constant_js__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./noop.js */ "./node_modules/underscore/modules/noop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return _noop_js__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./toPath.js */ "./node_modules/underscore/modules/toPath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toPath", function() { return _toPath_js__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _property_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _propertyOf_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./propertyOf.js */ "./node_modules/underscore/modules/propertyOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "propertyOf", function() { return _propertyOf_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return _matcher_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _times_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./times.js */ "./node_modules/underscore/modules/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "times", function() { return _times_js__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "random", function() { return _random_js__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _now_js__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./escape.js */ "./node_modules/underscore/modules/escape.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return _escape_js__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./unescape.js */ "./node_modules/underscore/modules/unescape.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unescape", function() { return _unescape_js__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateSettings", function() { return _templateSettings_js__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./template.js */ "./node_modules/underscore/modules/template.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "template", function() { return _template_js__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony import */ var _result_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./result.js */ "./node_modules/underscore/modules/result.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "result", function() { return _result_js__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony import */ var _uniqueId_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./uniqueId.js */ "./node_modules/underscore/modules/uniqueId.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return _uniqueId_js__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony import */ var _chain_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./chain.js */ "./node_modules/underscore/modules/chain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return _chain_js__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony import */ var _iteratee_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./iteratee.js */ "./node_modules/underscore/modules/iteratee.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "iteratee", function() { return _iteratee_js__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partial", function() { return _partial_js__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony import */ var _bind_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./bind.js */ "./node_modules/underscore/modules/bind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return _bind_js__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _bindAll_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./bindAll.js */ "./node_modules/underscore/modules/bindAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindAll", function() { return _bindAll_js__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./memoize.js */ "./node_modules/underscore/modules/memoize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memoize", function() { return _memoize_js__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./delay.js */ "./node_modules/underscore/modules/delay.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _delay_js__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _defer_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./defer.js */ "./node_modules/underscore/modules/defer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return _defer_js__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/underscore/modules/throttle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return _throttle_js__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/underscore/modules/debounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return _debounce_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/underscore/modules/wrap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return _wrap_js__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return _negate_js__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./compose.js */ "./node_modules/underscore/modules/compose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _compose_js__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _after_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./after.js */ "./node_modules/underscore/modules/after.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "after", function() { return _after_js__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "before", function() { return _before_js__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _once_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./once.js */ "./node_modules/underscore/modules/once.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "once", function() { return _once_js__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony import */ var _findKey_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./findKey.js */ "./node_modules/underscore/modules/findKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findKey", function() { return _findKey_js__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return _findIndex_js__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findLastIndex", function() { return _findLastIndex_js__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortedIndex", function() { return _sortedIndex_js__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony import */ var _indexOf_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./indexOf.js */ "./node_modules/underscore/modules/indexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return _indexOf_js__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./lastIndexOf.js */ "./node_modules/underscore/modules/lastIndexOf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return _lastIndexOf_js__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./find.js */ "./node_modules/underscore/modules/find.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "find", function() { return _find_js__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detect", function() { return _find_js__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony import */ var _findWhere_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./findWhere.js */ "./node_modules/underscore/modules/findWhere.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findWhere", function() { return _findWhere_js__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "each", function() { return _each_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _each_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "collect", function() { return _map_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony import */ var _reduce_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./reduce.js */ "./node_modules/underscore/modules/reduce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldl", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _reduce_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony import */ var _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./reduceRight.js */ "./node_modules/underscore/modules/reduceRight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reduceRight", function() { return _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "foldr", function() { return _reduceRight_js__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return _filter_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _filter_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony import */ var _reject_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./reject.js */ "./node_modules/underscore/modules/reject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return _reject_js__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony import */ var _every_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./every.js */ "./node_modules/underscore/modules/every.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "every", function() { return _every_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _every_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony import */ var _some_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./some.js */ "./node_modules/underscore/modules/some.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "some", function() { return _some_js__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _some_js__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "include", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony import */ var _invoke_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./invoke.js */ "./node_modules/underscore/modules/invoke.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "invoke", function() { return _invoke_js__WEBPACK_IMPORTED_MODULE_92__["default"]; });

/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return _pluck_js__WEBPACK_IMPORTED_MODULE_93__["default"]; });

/* harmony import */ var _where_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./where.js */ "./node_modules/underscore/modules/where.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _where_js__WEBPACK_IMPORTED_MODULE_94__["default"]; });

/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max_js__WEBPACK_IMPORTED_MODULE_95__["default"]; });

/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./min.js */ "./node_modules/underscore/modules/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min_js__WEBPACK_IMPORTED_MODULE_96__["default"]; });

/* harmony import */ var _shuffle_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./shuffle.js */ "./node_modules/underscore/modules/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _shuffle_js__WEBPACK_IMPORTED_MODULE_97__["default"]; });

/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sample", function() { return _sample_js__WEBPACK_IMPORTED_MODULE_98__["default"]; });

/* harmony import */ var _sortBy_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./sortBy.js */ "./node_modules/underscore/modules/sortBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return _sortBy_js__WEBPACK_IMPORTED_MODULE_99__["default"]; });

/* harmony import */ var _groupBy_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./groupBy.js */ "./node_modules/underscore/modules/groupBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "groupBy", function() { return _groupBy_js__WEBPACK_IMPORTED_MODULE_100__["default"]; });

/* harmony import */ var _indexBy_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./indexBy.js */ "./node_modules/underscore/modules/indexBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "indexBy", function() { return _indexBy_js__WEBPACK_IMPORTED_MODULE_101__["default"]; });

/* harmony import */ var _countBy_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./countBy.js */ "./node_modules/underscore/modules/countBy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "countBy", function() { return _countBy_js__WEBPACK_IMPORTED_MODULE_102__["default"]; });

/* harmony import */ var _partition_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./partition.js */ "./node_modules/underscore/modules/partition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return _partition_js__WEBPACK_IMPORTED_MODULE_103__["default"]; });

/* harmony import */ var _toArray_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./toArray.js */ "./node_modules/underscore/modules/toArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return _toArray_js__WEBPACK_IMPORTED_MODULE_104__["default"]; });

/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./size.js */ "./node_modules/underscore/modules/size.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "size", function() { return _size_js__WEBPACK_IMPORTED_MODULE_105__["default"]; });

/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return _pick_js__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony import */ var _omit_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./omit.js */ "./node_modules/underscore/modules/omit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return _omit_js__WEBPACK_IMPORTED_MODULE_107__["default"]; });

/* harmony import */ var _first_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./first.js */ "./node_modules/underscore/modules/first.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "first", function() { return _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "head", function() { return _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "take", function() { return _first_js__WEBPACK_IMPORTED_MODULE_108__["default"]; });

/* harmony import */ var _initial_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./initial.js */ "./node_modules/underscore/modules/initial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initial", function() { return _initial_js__WEBPACK_IMPORTED_MODULE_109__["default"]; });

/* harmony import */ var _last_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./last.js */ "./node_modules/underscore/modules/last.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "last", function() { return _last_js__WEBPACK_IMPORTED_MODULE_110__["default"]; });

/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rest", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return _rest_js__WEBPACK_IMPORTED_MODULE_111__["default"]; });

/* harmony import */ var _compact_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./compact.js */ "./node_modules/underscore/modules/compact.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compact", function() { return _compact_js__WEBPACK_IMPORTED_MODULE_112__["default"]; });

/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./flatten.js */ "./node_modules/underscore/modules/flatten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _flatten_js__WEBPACK_IMPORTED_MODULE_113__["default"]; });

/* harmony import */ var _without_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./without.js */ "./node_modules/underscore/modules/without.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "without", function() { return _without_js__WEBPACK_IMPORTED_MODULE_114__["default"]; });

/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return _uniq_js__WEBPACK_IMPORTED_MODULE_115__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unique", function() { return _uniq_js__WEBPACK_IMPORTED_MODULE_115__["default"]; });

/* harmony import */ var _union_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./union.js */ "./node_modules/underscore/modules/union.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "union", function() { return _union_js__WEBPACK_IMPORTED_MODULE_116__["default"]; });

/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./intersection.js */ "./node_modules/underscore/modules/intersection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return _intersection_js__WEBPACK_IMPORTED_MODULE_117__["default"]; });

/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return _difference_js__WEBPACK_IMPORTED_MODULE_118__["default"]; });

/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unzip", function() { return _unzip_js__WEBPACK_IMPORTED_MODULE_119__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _unzip_js__WEBPACK_IMPORTED_MODULE_119__["default"]; });

/* harmony import */ var _zip_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./zip.js */ "./node_modules/underscore/modules/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip_js__WEBPACK_IMPORTED_MODULE_120__["default"]; });

/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./object.js */ "./node_modules/underscore/modules/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _object_js__WEBPACK_IMPORTED_MODULE_121__["default"]; });

/* harmony import */ var _range_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./range.js */ "./node_modules/underscore/modules/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range_js__WEBPACK_IMPORTED_MODULE_122__["default"]; });

/* harmony import */ var _chunk_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./chunk.js */ "./node_modules/underscore/modules/chunk.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chunk", function() { return _chunk_js__WEBPACK_IMPORTED_MODULE_123__["default"]; });

/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./mixin.js */ "./node_modules/underscore/modules/mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixin", function() { return _mixin_js__WEBPACK_IMPORTED_MODULE_124__["default"]; });

/* harmony import */ var _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./underscore-array-methods.js */ "./node_modules/underscore/modules/underscore-array-methods.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _underscore_array_methods_js__WEBPACK_IMPORTED_MODULE_125__["default"]; });

// Named Exports
// =============

//     Underscore.js 1.13.6
//     https://underscorejs.org
//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

// Baseline setup.



// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.

// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.



























// Functions that treat an object as a dictionary of key-value pairs.
















// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.



















// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.















// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.









// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
























// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.



// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.

















// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.




/***/ }),

/***/ "./node_modules/underscore/modules/indexBy.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexBy.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  result[key] = value;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/indexOf.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/indexOf.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sortedIndex.js */ "./node_modules/underscore/modules/sortedIndex.js");
/* harmony import */ var _findIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./findIndex.js */ "./node_modules/underscore/modules/findIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");




// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_2__["default"])(1, _findIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"], _sortedIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/initial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/initial.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return initial; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}


/***/ }),

/***/ "./node_modules/underscore/modules/intersection.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/intersection.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return intersection; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");



// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array); i < length; i++) {
    var item = array[i];
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invert.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invert.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return invert; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/invoke.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/invoke.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");






// Invoke a method (with arguments) on every item in a collection.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, path, args) {
  var contextPath, func;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path)) {
    func = path;
  } else {
    path = Object(_toPath_js__WEBPACK_IMPORTED_MODULE_4__["default"])(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return Object(_map_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_3__["default"])(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
}));


/***/ }),

/***/ "./node_modules/underscore/modules/isArguments.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isArguments.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");



var isArguments = Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return Object(_has_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, 'callee');
    };
  }
}());

/* harmony default export */ __webpack_exports__["default"] = (isArguments);


/***/ }),

/***/ "./node_modules/underscore/modules/isArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isArray.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");



// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
/* harmony default export */ __webpack_exports__["default"] = (_setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsArray"] || Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_1__["default"])('Array'));


/***/ }),

/***/ "./node_modules/underscore/modules/isArrayBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/isArrayBuffer.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('ArrayBuffer'));


/***/ }),

/***/ "./node_modules/underscore/modules/isBoolean.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isBoolean.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBoolean; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || _setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj) === '[object Boolean]';
}


/***/ }),

/***/ "./node_modules/underscore/modules/isDataView.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isDataView.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArrayBuffer.js */ "./node_modules/underscore/modules/isArrayBuffer.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");





var isDataView = Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
  return obj != null && Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj.getInt8) && Object(_isArrayBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj.buffer);
}

/* harmony default export */ __webpack_exports__["default"] = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_3__["hasStringTagBug"] ? ie10IsDataView : isDataView);


/***/ }),

/***/ "./node_modules/underscore/modules/isDate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isDate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Date'));


/***/ }),

/***/ "./node_modules/underscore/modules/isElement.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isElement.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElement; });
// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEmpty.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEmpty.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isEmpty; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/underscore/modules/isArguments.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");






// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  if (typeof length == 'number' && (
    Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) || Object(_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj) || Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)
  )) return length === 0;
  return Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_keys_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj)) === 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isEqual.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isEqual.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isEqual; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _getByteLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getByteLength.js */ "./node_modules/underscore/modules/_getByteLength.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/underscore/modules/isTypedArray.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _toBufferView_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_toBufferView.js */ "./node_modules/underscore/modules/_toBufferView.js");











// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) a = a._wrapped;
  if (b instanceof _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = _setup_js__WEBPACK_IMPORTED_MODULE_1__["toString"].call(a);
  if (className !== _setup_js__WEBPACK_IMPORTED_MODULE_1__["toString"].call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_5__["hasStringTagBug"] && className == '[object Object]' && Object(_isDataView_js__WEBPACK_IMPORTED_MODULE_6__["default"])(a)) {
    if (!Object(_isDataView_js__WEBPACK_IMPORTED_MODULE_6__["default"])(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return _setup_js__WEBPACK_IMPORTED_MODULE_1__["SymbolProto"].valueOf.call(a) === _setup_js__WEBPACK_IMPORTED_MODULE_1__["SymbolProto"].valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq(Object(_toBufferView_js__WEBPACK_IMPORTED_MODULE_9__["default"])(a), Object(_toBufferView_js__WEBPACK_IMPORTED_MODULE_9__["default"])(b), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays && Object(_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(a)) {
      var byteLength = Object(_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(a);
      if (byteLength !== Object(_getByteLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(aCtor) && aCtor instanceof aCtor &&
                             Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_4__["default"])(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (Object(_keys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(Object(_has_js__WEBPACK_IMPORTED_MODULE_8__["default"])(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isError.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isError.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Error'));


/***/ }),

/***/ "./node_modules/underscore/modules/isFinite.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isFinite.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isFinite; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/underscore/modules/isSymbol.js");



// Is a given object a finite number?
function isFinite(obj) {
  return !Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["_isFinite"])(obj) && !isNaN(parseFloat(obj));
}


/***/ }),

/***/ "./node_modules/underscore/modules/isFunction.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/isFunction.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");



var isFunction = Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = _setup_js__WEBPACK_IMPORTED_MODULE_1__["root"].document && _setup_js__WEBPACK_IMPORTED_MODULE_1__["root"].document.childNodes;
if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (isFunction);


/***/ }),

/***/ "./node_modules/underscore/modules/isMap.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isMap.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ __webpack_exports__["default"] = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__["isIE11"] ? Object(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["ie11fingerprint"])(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["mapMethods"]) : Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Map'));


/***/ }),

/***/ "./node_modules/underscore/modules/isMatch.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/isMatch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isMatch; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNaN.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isNaN.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNaN; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNumber.js */ "./node_modules/underscore/modules/isNumber.js");



// Is the given value `NaN`?
function isNaN(obj) {
  return Object(_isNumber_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["_isNaN"])(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNull.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/isNull.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNull; });
// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isNumber.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isNumber.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Number'));


/***/ }),

/***/ "./node_modules/underscore/modules/isObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isObject.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isObject; });
// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === 'function' || (type === 'object' && !!obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/isRegExp.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isRegExp.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('RegExp'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSet.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/isSet.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ __webpack_exports__["default"] = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__["isIE11"] ? Object(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["ie11fingerprint"])(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["setMethods"]) : Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Set'));


/***/ }),

/***/ "./node_modules/underscore/modules/isString.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isString.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('String'));


/***/ }),

/***/ "./node_modules/underscore/modules/isSymbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/isSymbol.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('Symbol'));


/***/ }),

/***/ "./node_modules/underscore/modules/isTypedArray.js":
/*!*********************************************************!*\
  !*** ./node_modules/underscore/modules/isTypedArray.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isDataView.js */ "./node_modules/underscore/modules/isDataView.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/underscore/modules/constant.js");
/* harmony import */ var _isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isBufferLike.js */ "./node_modules/underscore/modules/_isBufferLike.js");





// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsView"] ? (Object(_setup_js__WEBPACK_IMPORTED_MODULE_0__["nativeIsView"])(obj) && !Object(_isDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj)) :
                Object(_isBufferLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj) && typedArrayPattern.test(_setup_js__WEBPACK_IMPORTED_MODULE_0__["toString"].call(obj));
}

/* harmony default export */ __webpack_exports__["default"] = (_setup_js__WEBPACK_IMPORTED_MODULE_0__["supportsArrayBuffer"] ? isTypedArray : Object(_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(false));


/***/ }),

/***/ "./node_modules/underscore/modules/isUndefined.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/isUndefined.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isUndefined; });
// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakMap.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakMap.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");
/* harmony import */ var _stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stringTagBug.js */ "./node_modules/underscore/modules/_stringTagBug.js");
/* harmony import */ var _methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_methodFingerprint.js */ "./node_modules/underscore/modules/_methodFingerprint.js");




/* harmony default export */ __webpack_exports__["default"] = (_stringTagBug_js__WEBPACK_IMPORTED_MODULE_1__["isIE11"] ? Object(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["ie11fingerprint"])(_methodFingerprint_js__WEBPACK_IMPORTED_MODULE_2__["weakMapMethods"]) : Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakMap'));


/***/ }),

/***/ "./node_modules/underscore/modules/isWeakSet.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/isWeakSet.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tagTester_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_tagTester.js */ "./node_modules/underscore/modules/_tagTester.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_tagTester_js__WEBPACK_IMPORTED_MODULE_0__["default"])('WeakSet'));


/***/ }),

/***/ "./node_modules/underscore/modules/iteratee.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/iteratee.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return iteratee; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/underscore/modules/_baseIteratee.js");



// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return Object(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, context, Infinity);
}
_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].iteratee = iteratee;


/***/ }),

/***/ "./node_modules/underscore/modules/keys.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/keys.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return keys; });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/underscore/modules/isObject.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");
/* harmony import */ var _collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_collectNonEnumProps.js */ "./node_modules/underscore/modules/_collectNonEnumProps.js");





// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return [];
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeKeys"]) return Object(_setup_js__WEBPACK_IMPORTED_MODULE_1__["nativeKeys"])(obj);
  var keys = [];
  for (var key in obj) if (Object(_has_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (_setup_js__WEBPACK_IMPORTED_MODULE_1__["hasEnumBug"]) Object(_collectNonEnumProps_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, keys);
  return keys;
}


/***/ }),

/***/ "./node_modules/underscore/modules/last.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/last.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return last; });
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest.js */ "./node_modules/underscore/modules/rest.js");


// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return Object(_rest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, Math.max(0, array.length - n));
}


/***/ }),

/***/ "./node_modules/underscore/modules/lastIndexOf.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/lastIndexOf.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./findLastIndex.js */ "./node_modules/underscore/modules/findLastIndex.js");
/* harmony import */ var _createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_createIndexFinder.js */ "./node_modules/underscore/modules/_createIndexFinder.js");



// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createIndexFinder_js__WEBPACK_IMPORTED_MODULE_1__["default"])(-1, _findLastIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/map.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/map.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return map; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mapObject.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/mapObject.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mapObject; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}


/***/ }),

/***/ "./node_modules/underscore/modules/matcher.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/matcher.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return matcher; });
/* harmony import */ var _extendOwn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extendOwn.js */ "./node_modules/underscore/modules/extendOwn.js");
/* harmony import */ var _isMatch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isMatch.js */ "./node_modules/underscore/modules/isMatch.js");



// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = Object(_extendOwn_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, attrs);
  return function(obj) {
    return Object(_isMatch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, attrs);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/max.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/max.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return max; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/memoize.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/memoize.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return memoize; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_has.js */ "./node_modules/underscore/modules/_has.js");


// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!Object(_has_js__WEBPACK_IMPORTED_MODULE_0__["default"])(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}


/***/ }),

/***/ "./node_modules/underscore/modules/min.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/min.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return min; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");





// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj : Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, context);
    Object(_each_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/mixin.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/mixin.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mixin; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/underscore/modules/functions.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");






// Add your own custom functions to the Underscore object.
function mixin(obj) {
  Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_functions_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj), function(name) {
    var func = _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"][name] = obj[name];
    _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
      var args = [this._wrapped];
      _setup_js__WEBPACK_IMPORTED_MODULE_3__["push"].apply(args, arguments);
      return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_4__["default"])(this, func.apply(_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"], args));
    };
  });
  return _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"];
}


/***/ }),

/***/ "./node_modules/underscore/modules/negate.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/negate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return negate; });
// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/noop.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/noop.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
// Predicate-generating function. Often useful outside of Underscore.
function noop(){}


/***/ }),

/***/ "./node_modules/underscore/modules/now.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/now.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// A (possibly faster) way to get the current timestamp as an integer.
/* harmony default export */ __webpack_exports__["default"] = (Date.now || function() {
  return new Date().getTime();
});


/***/ }),

/***/ "./node_modules/underscore/modules/object.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return object; });
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");


// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object(list, values) {
  var result = {};
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/omit.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/omit.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");
/* harmony import */ var _pick_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pick.js */ "./node_modules/underscore/modules/pick.js");








// Return a copy of the object without the disallowed properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var iteratee = keys[0], context;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    iteratee = Object(_negate_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = Object(_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_flatten_js__WEBPACK_IMPORTED_MODULE_4__["default"])(keys, false, false), String);
    iteratee = function(value, key) {
      return !Object(_contains_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, key);
    };
  }
  return Object(_pick_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj, iteratee, context);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/once.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/once.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");
/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./before.js */ "./node_modules/underscore/modules/before.js");



// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
/* harmony default export */ __webpack_exports__["default"] = (Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_before_js__WEBPACK_IMPORTED_MODULE_1__["default"], 2));


/***/ }),

/***/ "./node_modules/underscore/modules/pairs.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pairs.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pairs; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}


/***/ }),

/***/ "./node_modules/underscore/modules/partial.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/partial.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _executeBound_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_executeBound.js */ "./node_modules/underscore/modules/_executeBound.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");




// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return Object(_executeBound_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _underscore_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ __webpack_exports__["default"] = (partial);


/***/ }),

/***/ "./node_modules/underscore/modules/partition.js":
/*!******************************************************!*\
  !*** ./node_modules/underscore/modules/partition.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_group.js */ "./node_modules/underscore/modules/_group.js");


// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
/* harmony default export */ __webpack_exports__["default"] = (Object(_group_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true));


/***/ }),

/***/ "./node_modules/underscore/modules/pick.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/pick.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");
/* harmony import */ var _allKeys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./allKeys.js */ "./node_modules/underscore/modules/allKeys.js");
/* harmony import */ var _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_keyInObj.js */ "./node_modules/underscore/modules/_keyInObj.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");







// Return a copy of the object only containing the allowed properties.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if (Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
    if (keys.length > 1) iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee, keys[1]);
    keys = Object(_allKeys_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj);
  } else {
    iteratee = _keyInObj_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    keys = Object(_flatten_js__WEBPACK_IMPORTED_MODULE_5__["default"])(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
}));


/***/ }),

/***/ "./node_modules/underscore/modules/pluck.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/pluck.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pluck; });
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./property.js */ "./node_modules/underscore/modules/property.js");



// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return Object(_map_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_property_js__WEBPACK_IMPORTED_MODULE_1__["default"])(key));
}


/***/ }),

/***/ "./node_modules/underscore/modules/property.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/property.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return property; });
/* harmony import */ var _deepGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_deepGet.js */ "./node_modules/underscore/modules/_deepGet.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = Object(_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  return function(obj) {
    return Object(_deepGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/propertyOf.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/propertyOf.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return propertyOf; });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/underscore/modules/noop.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get.js */ "./node_modules/underscore/modules/get.js");



// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  return function(path) {
    return Object(_get_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj, path);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/random.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/random.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return random; });
// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}


/***/ }),

/***/ "./node_modules/underscore/modules/range.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/range.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return range; });
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/underscore/modules/reduce.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reduce.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1));


/***/ }),

/***/ "./node_modules/underscore/modules/reduceRight.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/reduceRight.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createReduce.js */ "./node_modules/underscore/modules/_createReduce.js");


// The right-associative version of reduce, also known as `foldr`.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-1));


/***/ }),

/***/ "./node_modules/underscore/modules/reject.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/reject.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return reject; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./negate.js */ "./node_modules/underscore/modules/negate.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");




// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_negate_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_cb_js__WEBPACK_IMPORTED_MODULE_2__["default"])(predicate)), context);
}


/***/ }),

/***/ "./node_modules/underscore/modules/rest.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/rest.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rest; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return _setup_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(array, n == null || guard ? 1 : n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/restArguments.js":
/*!**********************************************************!*\
  !*** ./node_modules/underscore/modules/restArguments.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return restArguments; });
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}


/***/ }),

/***/ "./node_modules/underscore/modules/result.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/result.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return result; });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/underscore/modules/isFunction.js");
/* harmony import */ var _toPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toPath.js */ "./node_modules/underscore/modules/_toPath.js");



// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  path = Object(_toPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path);
  var length = path.length;
  if (!length) {
    return Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prop) ? prop.call(obj) : prop;
  }
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sample.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sample.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sample; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random.js */ "./node_modules/underscore/modules/random.js");
/* harmony import */ var _toArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toArray.js */ "./node_modules/underscore/modules/toArray.js");






// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) obj = Object(_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj);
    return obj[Object(_random_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj.length - 1)];
  }
  var sample = Object(_toArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj);
  var length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = Object(_random_js__WEBPACK_IMPORTED_MODULE_3__["default"])(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}


/***/ }),

/***/ "./node_modules/underscore/modules/shuffle.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/shuffle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shuffle; });
/* harmony import */ var _sample_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sample.js */ "./node_modules/underscore/modules/sample.js");


// Shuffle a collection.
function shuffle(obj) {
  return Object(_sample_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Infinity);
}


/***/ }),

/***/ "./node_modules/underscore/modules/size.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/size.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return size; });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");



// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj) ? obj.length : Object(_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj).length;
}


/***/ }),

/***/ "./node_modules/underscore/modules/some.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/some.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return some; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");




// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(predicate, context);
  var _keys = !Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(obj) && Object(_keys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortBy.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/sortBy.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sortBy; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");




// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context);
  return Object(_pluck_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_map_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}


/***/ }),

/***/ "./node_modules/underscore/modules/sortedIndex.js":
/*!********************************************************!*\
  !*** ./node_modules/underscore/modules/sortedIndex.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sortedIndex; });
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");



// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}


/***/ }),

/***/ "./node_modules/underscore/modules/tap.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/tap.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return tap; });
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}


/***/ }),

/***/ "./node_modules/underscore/modules/template.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/template.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return template; });
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/underscore/modules/defaults.js");
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templateSettings.js */ "./node_modules/underscore/modules/templateSettings.js");




// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = Object(_defaults_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, settings, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"].templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error(
      'variable is not a bare identifier: ' + argument
    );
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _underscore_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}


/***/ }),

/***/ "./node_modules/underscore/modules/templateSettings.js":
/*!*************************************************************!*\
  !*** ./node_modules/underscore/modules/templateSettings.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");


// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
/* harmony default export */ __webpack_exports__["default"] = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
});


/***/ }),

/***/ "./node_modules/underscore/modules/throttle.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/throttle.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttle; });
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./now.js */ "./node_modules/underscore/modules/now.js");


// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = Object(_now_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}


/***/ }),

/***/ "./node_modules/underscore/modules/times.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/times.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return times; });
/* harmony import */ var _optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_optimizeCb.js */ "./node_modules/underscore/modules/_optimizeCb.js");


// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = Object(_optimizeCb_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}


/***/ }),

/***/ "./node_modules/underscore/modules/toArray.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/toArray.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toArray; });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isString.js */ "./node_modules/underscore/modules/isString.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isArrayLike.js */ "./node_modules/underscore/modules/_isArrayLike.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map.js */ "./node_modules/underscore/modules/map.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./identity.js */ "./node_modules/underscore/modules/identity.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./values.js */ "./node_modules/underscore/modules/values.js");








// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) return _setup_js__WEBPACK_IMPORTED_MODULE_1__["slice"].call(obj);
  if (Object(_isString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_3__["default"])(obj)) return Object(_map_js__WEBPACK_IMPORTED_MODULE_4__["default"])(obj, _identity_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
  return Object(_values_js__WEBPACK_IMPORTED_MODULE_6__["default"])(obj);
}


/***/ }),

/***/ "./node_modules/underscore/modules/toPath.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/toPath.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toPath; });
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/underscore/modules/isArray.js");



// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath(path) {
  return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path) ? path : [path];
}
_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].toPath = toPath;


/***/ }),

/***/ "./node_modules/underscore/modules/underscore-array-methods.js":
/*!*********************************************************************!*\
  !*** ./node_modules/underscore/modules/underscore-array-methods.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _underscore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./underscore.js */ "./node_modules/underscore/modules/underscore.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/underscore/modules/each.js");
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");
/* harmony import */ var _chainResult_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chainResult.js */ "./node_modules/underscore/modules/_chainResult.js");





// Add all mutator `Array` functions to the wrapper.
Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__["ArrayProto"][name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
Object(_each_js__WEBPACK_IMPORTED_MODULE_1__["default"])(['concat', 'join', 'slice'], function(name) {
  var method = _setup_js__WEBPACK_IMPORTED_MODULE_2__["ArrayProto"][name];
  _underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return Object(_chainResult_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this, obj);
  };
});

/* harmony default export */ __webpack_exports__["default"] = (_underscore_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/underscore/modules/underscore.js":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/modules/underscore.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _; });
/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setup.js */ "./node_modules/underscore/modules/_setup.js");


// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}

_.VERSION = _setup_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"];

// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

_.prototype.toString = function() {
  return String(this._wrapped);
};


/***/ }),

/***/ "./node_modules/underscore/modules/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/unescape.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createEscaper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createEscaper.js */ "./node_modules/underscore/modules/_createEscaper.js");
/* harmony import */ var _unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unescapeMap.js */ "./node_modules/underscore/modules/_unescapeMap.js");



// Function for unescaping strings from HTML interpolation.
/* harmony default export */ __webpack_exports__["default"] = (Object(_createEscaper_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unescapeMap_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/underscore/modules/union.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/union.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _uniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniq.js */ "./node_modules/underscore/modules/uniq.js");
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_flatten.js */ "./node_modules/underscore/modules/_flatten.js");




// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(arrays) {
  return Object(_uniq_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_flatten_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arrays, true, true));
}));


/***/ }),

/***/ "./node_modules/underscore/modules/uniq.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/uniq.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniq; });
/* harmony import */ var _isBoolean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isBoolean.js */ "./node_modules/underscore/modules/isBoolean.js");
/* harmony import */ var _cb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cb.js */ "./node_modules/underscore/modules/_cb.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "./node_modules/underscore/modules/contains.js");





// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!Object(_isBoolean_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = Object(_cb_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = Object(_getLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!Object(_contains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(result, value)) {
      result.push(value);
    }
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/uniqueId.js":
/*!*****************************************************!*\
  !*** ./node_modules/underscore/modules/uniqueId.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueId; });
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}


/***/ }),

/***/ "./node_modules/underscore/modules/unzip.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/unzip.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return unzip; });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ "./node_modules/underscore/modules/max.js");
/* harmony import */ var _getLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getLength.js */ "./node_modules/underscore/modules/_getLength.js");
/* harmony import */ var _pluck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pluck.js */ "./node_modules/underscore/modules/pluck.js");




// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = (array && Object(_max_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, _getLength_js__WEBPACK_IMPORTED_MODULE_1__["default"]).length) || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = Object(_pluck_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, index);
  }
  return result;
}


/***/ }),

/***/ "./node_modules/underscore/modules/values.js":
/*!***************************************************!*\
  !*** ./node_modules/underscore/modules/values.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return values; });
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/underscore/modules/keys.js");


// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = Object(_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}


/***/ }),

/***/ "./node_modules/underscore/modules/where.js":
/*!**************************************************!*\
  !*** ./node_modules/underscore/modules/where.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return where; });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./node_modules/underscore/modules/filter.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matcher.js */ "./node_modules/underscore/modules/matcher.js");



// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return Object(_filter_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, Object(_matcher_js__WEBPACK_IMPORTED_MODULE_1__["default"])(attrs));
}


/***/ }),

/***/ "./node_modules/underscore/modules/without.js":
/*!****************************************************!*\
  !*** ./node_modules/underscore/modules/without.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _difference_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./difference.js */ "./node_modules/underscore/modules/difference.js");



// Return a version of the array that does not contain the specified value(s).
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, otherArrays) {
  return Object(_difference_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, otherArrays);
}));


/***/ }),

/***/ "./node_modules/underscore/modules/wrap.js":
/*!*************************************************!*\
  !*** ./node_modules/underscore/modules/wrap.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return wrap; });
/* harmony import */ var _partial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./partial.js */ "./node_modules/underscore/modules/partial.js");


// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return Object(_partial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wrapper, func);
}


/***/ }),

/***/ "./node_modules/underscore/modules/zip.js":
/*!************************************************!*\
  !*** ./node_modules/underscore/modules/zip.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _restArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./restArguments.js */ "./node_modules/underscore/modules/restArguments.js");
/* harmony import */ var _unzip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unzip.js */ "./node_modules/underscore/modules/unzip.js");



// Zip together multiple lists into a single array -- elements that share
// an index go together.
/* harmony default export */ __webpack_exports__["default"] = (Object(_restArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_unzip_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/backend/background.ls":
/*!***********************************!*\
  !*** ./src/backend/background.ls ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hso_server_url, default_nudge_time, default_night_time, default_location, disable_icon_changes, disable_icon_timer, out$ =  true && exports || this, slice$ = [].slice;
window.addEventListener("unhandledrejection", function(evt){
  throw new Error(evt.reason);
});
hso_server_url = '';
default_nudge_time = "3";
default_night_time = "8";
default_location = "work";
disable_icon_changes = true;
disable_icon_timer = true;
localStorage.setItem('icon_nudge_active', 'false');
localStorage.setItem('icon_notif_active', false);
localStorage.setItem('browser_session_start', new Date());
localStorage.setItem('last_intervention_time', new Date());
localStorage.setItem("intervention_timed_out", false);
localStorage.setItem("click_rate_buffer", "[]");
localStorage.setItem("typing_rate_buffer", "[]");
localStorage.setItem("scroll_rate_buffer", "[]");
localStorage.setItem("scroll_rate_dates", "[]");
localStorage.setItem("panel_timer", "");
localStorage.setItem("nudge_time", default_nudge_time);
localStorage.setItem("survey_data", "{}");
localStorage.setItem("nudge_level", "0");
localStorage.setItem("nudge_set_time", "null");
localStorage.setItem("nudge_seconds_since", "null");
localStorage.setItem("intervention_count", '0');
localStorage.setItem("bandit_active", false);
localStorage.setItem("productivity_active", true);
localStorage.setItem("stress_active", true);
localStorage.setItem("stressful_sites", "[]");
localStorage.setItem("accepted_sites", "[]");
localStorage.setItem("hso_condition", "null");
localStorage.setItem("last_survey_notif_time", "null");
localStorage.setItem("curr_notifs_start_time", "null");
localStorage.setItem("notif_loops_count", '0');
localStorage.setItem("survey_loop_active", "false");
localStorage.setItem("first_survey_sent", "false");
localStorage.setItem("night_time", default_night_time);
localStorage.setItem("current_location", default_location);
localStorage.setItem("notif_survey_button_clicked", "false");
chrome.browserAction.onClicked.addListener(function(tab){
  var extension_url;
  extension_url = chrome.extension.getURL('popup.html');
  return chrome.tabs.query({}, function(tabs){
    var existing_tab;
    chrome.tabs.query({
      active: true,
      lastFocusedWindow: true
    }, function(last_tab){
      var last_active_tab;
      last_active_tab = last_tab[0].url;
      return chrome.storage.local.set({
        lastActiveTab: last_active_tab
      });
    });
    existing_tab = tabs.find(function(t){
      return t.url === extension_url;
    });
    if (existing_tab != null) {
      return chrome.windows.update(existing_tab.windowId, {
        focused: true
      }, function(){
        return chrome.tabs.update(existing_tab.id, {
          active: true
        });
      });
    } else if (existing_tab !== extension_url) {
      return chrome.tabs.create({
        url: extension_url
      });
    }
  });
});
(async function(){
  var ref$, get_json, post_json, set_json, put_json, get_user_id, userid, profile_info, survey_data, dlog, addtokey_dictdict, getkey_dictdict, getkey_dict, setkey_dictdict, getDb, chrome_manifest, habitlab_version, developer_mode, unofficial_version, need_to_clear_cache, version_cached, localforage, store, storesystemjs, moment, get_goals, get_goal_info, get_enabled_goals, get_goal_target, get_goal_intervention_info, set_goals_enabled, set_default_goals_enabled, get_random_positive_goal, site_has_enabled_spend_less_time_goal, get_have_suggested_domain_as_goal, is_domain_unproductive, list_goals_for_location, list_nonpositive_goals_for_location, get_interventions, get_intervention_info, list_enabled_nonconflicting_interventions_for_location, list_all_enabled_interventions_for_location, list_available_interventions_for_location, get_intervention_parameters, is_it_outside_work_hours, set_default_generic_interventions_enabled, get_suggested_intervention_if_needed_for_url, enabledisable_interventions_based_on_difficulty, get_intensity_level_for_intervention, is_video_domain, choose_intervention_for_difficulty_level_and_goal, send_message_to_active_tab, send_message_to_tabid, get_active_tab_info, get_install_id, get_user_secret, list_currently_loaded_interventions_for_tabid, send_logging_enabled, get_basic_client_data, send_feature_disabled, setup_abtest_newuser, setup_abtest_olduser, make_tab_focused, focus_tab_by_pattern_if_available, num_times_notification_already_shown, num_times_to_pause_before_next_notification, show_finish_configuring_notification_if_needed, get_last_visit_to_website_timestamp, get_last_visit_to_chrome_store_timestamp, get_all_message_handlers, localget, remoteget, systemjsget, start_syncing_all_data, make_wait_token, wait_for_token, finished_waiting, get_days_since_epoch, get_new_session_id_for_domain, url_to_domain, add_tab_navigation_event, run_every_timeperiod, as_array, as_dictset, localstorage_getjson, localstorage_setjson, localstorage_getbool, localstorage_setbool, baseline_time_per_session_for_domain, promiseDebounce, gexport, gexport_module, set_active_interventions_for_domain_and_session, get_progress_on_enabled_goals_today, get_progress_on_goal_this_week, is_habitlab_enabled_sync, ensure_history_utils_data_cached, log_impression_internal, log_goal_suggestion, add_log_history, log_feedback_internal, sleep, printable_time_spent_short, one_random_intervention_per_enabled_goal, execute_content_script, insert_css, running_background_scripts, load_background_script, cached_systemjs_code, cached_bundle_code, execute_content_scripts_for_intervention, find_webpack_chunks, load_intervention_for_session_id, load_intervention_list, list_loaded_interventions, get_session_id_for_tab_id_and_domain, tab_id_to_loaded_interventions, domain_to_prev_enabled_interventions, page_was_just_refreshed, load_intervention_for_location, getLocation, split_list_by_length, iframed_domain_to_track, tabs_to_listen_for_focus, css_packages, css_files_cached, message_handlers, prev_domain, domain_changed, tab_id_to_domain_to_session_id, tab_id_to_url, list_domain_to_session_ids, get_last_duolingo_progress_update_time, update_duolingo_progress, navigation_occurred, reward_display_base_code_cached, message_handlers_requiring_tab, current_idlestate, ref1$, prev_browser_focused, updates_to_sync, mobile_server, goal_suggestion_threshold, suggest_goal_base_code, domain_to_time_last_suggested_goal, get_habitlab_uninstall_url, decode_habitlab_uninstall_url_data, set_habitlab_uninstall_url, open_habitlab_uninstall_url, num_times_restart_failed_due_to_loaded_interventions, num_times_restart_failed_due_to_loaded_interventions_active, num_times_restart_failed_due_to_habitlab_tab_open, num_times_restart_failed_due_to_habitlab_tab_open_active, restart_failed_priority_to_counts, record_restart_failed, try_to_restart_habitlab_now, habitlab_restarter_running, start_trying_to_restart_habitlab, semver, check_if_update_available_and_run_update, update_available_version, url_to_open_on_next_start;
  ref$ = __webpack_require__(/*! libs_backend/ajax_utils */ "./src/libs_backend/ajax_utils.js"), get_json = ref$.get_json, post_json = ref$.post_json, set_json = ref$.set_json, put_json = ref$.put_json;
  get_user_id = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls").get_user_id;
  userid = (await get_user_id());
  profile_info = {};
  profile_info = (await get_json("/profiles/getProfileInfo", "userid=" + userid));
  'async function getProfile:\n  data = await get_json("/profiles/getProfileInfo", "userid=" + userid)\n  console.log(data)\n  return JSON.parse(data)\n\nprofile_info = getProfile()';
  if (Object.keys(profile_info).length > 0) {
    if (profile_info.install_time) {
      localStorage.setItem("install_time", profile_info.install_time);
    }
    if (profile_info.nudge_time) {
      localStorage.setItem("nudge_time", profile_info.nudge_time);
    }
    if (profile_info.night_time) {
      localStorage.setItem("night_time", profile_info.night_time);
    }
    if (profile_info.location) {
      localStorage.setItem("location", profile_info.location);
    }
    if (!profile_info.intervention_count) {
      localStorage.setItem("intervention_count", '0');
    } else {
      localStorage.setItem("intervention_count", profile_info.intervention_count);
    }
    if (!profile_info.bandit_active) {
      localStorage.setItem("bandit_active", false);
    } else {
      localStorage.setItem("bandit_active", profile_info.bandit_active);
    }
    if (!profile_info.productivity_active) {
      localStorage.setItem("productivity_active", true);
    } else {
      localStorage.setItem("productivity_active", profile_info.productivity_active);
    }
    if (!profile_info.stress_active) {
      localStorage.setItem("stress_active", true);
    } else {
      localStorage.setItem("stress_active", profile_info.stress_active);
    }
    if (!profile_info.ticket_count) {
      localStorage.setItem("ticket_count", "-");
    } else {
      localStorage.setItem("ticket_count", profile_info.ticket_count);
    }
    if (!profile_info.hso_condition) {
      localStorage.setItem("hso_condition", "null");
    } else {
      localStorage.setItem("hso_condition", profile_info.hso_condition);
    }
  }
  survey_data = "{}";
  survey_data = JSON.parse(survey_data);
  if (Object.keys(survey_data).length > 0) {
    localStorage.setItem("survey_data", JSON.stringify(survey_data));
    localStorage.setItem("icon_notif_active", "true");
  } else {
    localStorage.setItem("survey_data", "{}");
    localStorage.setItem("icon_notif_active", "false");
  }
  localStorage.removeItem('cached_list_all_goals');
  localStorage.removeItem('cached_list_all_interventions');
  localStorage.removeItem('cached_list_generic_interventions');
  localStorage.removeItem('cached_list_generic_positive_interventions');
  localStorage.removeItem('cached_list_video_interventions');
  localStorage.removeItem('cached_get_goals');
  localStorage.removeItem('cached_get_interventions');
  localStorage.removeItem('baseline_session_time_on_domains');
  localStorage.removeItem('baseline_time_on_domains');
  window.global_exports = {};
  dlog = window.dlog = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    if (localStorage.getItem('display_dlog') === 'true') {
      return console.log.apply(console, args);
    }
  };
  ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), addtokey_dictdict = ref$.addtokey_dictdict, getkey_dictdict = ref$.getkey_dictdict, getkey_dict = ref$.getkey_dict, setkey_dictdict = ref$.setkey_dictdict, getDb = ref$.getDb;
  (await getDb());
  chrome_manifest = chrome.runtime.getManifest();
  habitlab_version = chrome_manifest.version;
  developer_mode = chrome_manifest.update_url == null;
  unofficial_version = chrome.runtime.id !== 'obghclocpdgcekcognpkblghkedcpdgd';
  if (!developer_mode || localStorage.getItem('devmode_use_cache') === 'true') {
    need_to_clear_cache = localStorage.getItem('devmode_clear_cache_on_reload') === 'true';
    if (need_to_clear_cache || !developer_mode) {
      if (!need_to_clear_cache) {
        if (!developer_mode) {
          version_cached = localStorage.getItem('habitlab_version');
          if (version_cached !== habitlab_version) {
            need_to_clear_cache = true;
          }
        }
      }
      if (need_to_clear_cache) {
        localforage = __webpack_require__(/*! localforage */ "./node_modules/localforage/dist/localforage.js");
        store = localforage.createInstance({
          name: 'localget'
        });
        storesystemjs = localforage.createInstance({
          name: 'systemjsget'
        });
        (await store.clear());
        (await storesystemjs.clear());
        localStorage.setItem('habitlab_version', habitlab_version);
      }
    }
  }
  __webpack_require__(/*! libs_backend/systemjs */ "./src/libs_backend/systemjs.js");
  moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  ref$ = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls"), get_goals = ref$.get_goals, get_goal_info = ref$.get_goal_info, get_enabled_goals = ref$.get_enabled_goals, get_goal_target = ref$.get_goal_target, get_goal_intervention_info = ref$.get_goal_intervention_info, set_goals_enabled = ref$.set_goals_enabled, set_default_goals_enabled = ref$.set_default_goals_enabled, get_random_positive_goal = ref$.get_random_positive_goal, site_has_enabled_spend_less_time_goal = ref$.site_has_enabled_spend_less_time_goal, get_have_suggested_domain_as_goal = ref$.get_have_suggested_domain_as_goal, is_domain_unproductive = ref$.is_domain_unproductive, list_goals_for_location = ref$.list_goals_for_location, list_nonpositive_goals_for_location = ref$.list_nonpositive_goals_for_location;
  ref$ = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls"), get_interventions = ref$.get_interventions, get_intervention_info = ref$.get_intervention_info, list_enabled_nonconflicting_interventions_for_location = ref$.list_enabled_nonconflicting_interventions_for_location, list_all_enabled_interventions_for_location = ref$.list_all_enabled_interventions_for_location, list_available_interventions_for_location = ref$.list_available_interventions_for_location, get_intervention_parameters = ref$.get_intervention_parameters, is_it_outside_work_hours = ref$.is_it_outside_work_hours, set_default_generic_interventions_enabled = ref$.set_default_generic_interventions_enabled, get_suggested_intervention_if_needed_for_url = ref$.get_suggested_intervention_if_needed_for_url, enabledisable_interventions_based_on_difficulty = ref$.enabledisable_interventions_based_on_difficulty, get_intensity_level_for_intervention = ref$.get_intensity_level_for_intervention, is_video_domain = ref$.is_video_domain, choose_intervention_for_difficulty_level_and_goal = ref$.choose_intervention_for_difficulty_level_and_goal;
  ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), send_message_to_active_tab = ref$.send_message_to_active_tab, send_message_to_tabid = ref$.send_message_to_tabid, get_active_tab_info = ref$.get_active_tab_info, get_user_id = ref$.get_user_id, get_install_id = ref$.get_install_id, get_user_secret = ref$.get_user_secret, list_currently_loaded_interventions_for_tabid = ref$.list_currently_loaded_interventions_for_tabid;
  ref$ = __webpack_require__(/*! libs_backend/logging_enabled_utils */ "./src/libs_backend/logging_enabled_utils.ls"), send_logging_enabled = ref$.send_logging_enabled, get_basic_client_data = ref$.get_basic_client_data, send_feature_disabled = ref$.send_feature_disabled;
  ref$ = __webpack_require__(/*! libs_backend/abtest_utils */ "./src/libs_backend/abtest_utils.ls"), setup_abtest_newuser = ref$.setup_abtest_newuser, setup_abtest_olduser = ref$.setup_abtest_olduser;
  out$.make_tab_focused = make_tab_focused = async function(tab_id, window_id){
    (await new Promise(function(it){
      return chrome.windows.update(window_id, {
        focused: true
      }, it);
    }));
    return (await new Promise(function(it){
      return chrome.tabs.update(tab_id, {
        active: true
      }, it);
    }));
  };
  out$.focus_tab_by_pattern_if_available = focus_tab_by_pattern_if_available = async function(url_pattern){
    var all_tab_list, candidate_list, tab_info, this$ = this;
    all_tab_list = (await new Promise(function(it){
      return chrome.tabs.query({
        url: url_pattern
      }, it);
    }));
    if (all_tab_list.length === 0) {
      return false;
    }
    candidate_list = all_tab_list.filter(function(it){
      return it.currentWindow;
    });
    if (candidate_list.length > 0) {
      all_tab_list = candidate_list;
    }
    candidate_list = all_tab_list.filter(function(it){
      return it.active;
    });
    if (candidate_list.length > 0) {
      all_tab_list = candidate_list;
    }
    tab_info = all_tab_list[0];
    (await make_tab_focused(tab_info.id, tab_info.windowId));
    return true;
  };
  num_times_notification_already_shown = 0;
  num_times_to_pause_before_next_notification = 0;
  out$.show_finish_configuring_notification_if_needed = show_finish_configuring_notification_if_needed = async function(){
    var tabs_list, notification, close_notification;
    if (localStorage.getItem('allow_logging') != null) {
      return;
    }
    tabs_list = (await new Promise(function(it){
      return chrome.tabs.query({
        url: chrome.extension.getURL('options.html')
      }, it);
    }));
    if (tabs_list.length > 0) {
      return;
    }
    if (num_times_to_pause_before_next_notification > 0) {
      num_times_to_pause_before_next_notification = num_times_to_pause_before_next_notification - 1;
      if (num_times_to_pause_before_next_notification > 0) {
        return;
      }
    }
    num_times_notification_already_shown = num_times_notification_already_shown + 1;
    num_times_to_pause_before_next_notification = Math.pow(2, num_times_notification_already_shown + 1);
    notification = new Notification('Finish setting up Unstuck', {
      icon: chrome.extension.getURL('icons/icon_128.png'),
      body: 'Click here to finish setting up Unstuck',
      requireInteraction: true
    });
    close_notification = notification.close.bind(notification);
    return notification.onclick = function(){
      chrome.tabs.create({
        url: chrome.extension.getURL('options.html#onboarding')
      });
      return close_notification();
    };
  };
  out$.get_last_visit_to_website_timestamp = get_last_visit_to_website_timestamp = async function(){
    var last_visit_timestamp;
    last_visit_timestamp = -1;
    return last_visit_timestamp;
  };
  out$.get_last_visit_to_chrome_store_timestamp = get_last_visit_to_chrome_store_timestamp = async function(){
    var history_search_results, last_visit_timestamp, i$, len$, search_result;
    history_search_results = (await new Promise(function(it){
      return chrome.history.search({
        text: 'https://chrome.google.com/webstore/detail/habitlab/obghclocpdgcekcognpkblghkedcpdgd',
        startTime: 0
      }, it);
    }));
    last_visit_timestamp = -1;
    for (i$ = 0, len$ = history_search_results.length; i$ < len$; ++i$) {
      search_result = history_search_results[i$];
      if (search_result.url.startsWith('https://chrome.google.com/webstore/detail/habitlab/obghclocpdgcekcognpkblghkedcpdgd')) {
        if (search_result.lastVisitTime > last_visit_timestamp) {
          last_visit_timestamp = search_result.lastVisitTime;
        }
      }
    }
    return last_visit_timestamp;
  };
  (async function(){
    var initial_profile_data, user_id, tab_info, last_visit_to_website_timestamp, last_visit_to_chrome_store_timestamp, need_to_create_new_tab, install_source, install_data;
    if (localStorage.getItem('notfirstrun')) {
      return;
    }
    localStorage.setItem('notfirstrun', true);
    localStorage.setItem('positive_goals_disabled', true);
    initial_profile_data = {
      userid: get_user_id(),
      install_time: new Date(),
      night_time: localStorage.getItem('night_time'),
      current_location: localStorage.getItem('current_location'),
      nudge_time: localStorage.getItem('nudge_time')
    };
    put_json("/profiles/addUserProfile", initial_profile_data);
    (await set_default_goals_enabled());
    (await set_default_generic_interventions_enabled());
    (await setup_abtest_newuser());
    user_id = (await get_user_id());
    tab_info = (await get_active_tab_info());
    last_visit_to_website_timestamp = (await get_last_visit_to_website_timestamp());
    last_visit_to_chrome_store_timestamp = (await get_last_visit_to_chrome_store_timestamp());
    need_to_create_new_tab = true;
    install_source = 'unknown';
    if (need_to_create_new_tab) {
      if (install_source === 'unknown') {
        if (developer_mode) {
          install_source = 'sideload';
        } else {
          install_source = 'webstore';
        }
      }
      chrome.tabs.create({
        url: 'options.html#onboarding'
      });
    }
    install_data = (await get_basic_client_data());
    install_data.install_source = install_source;
    install_data.last_visit_to_website = last_visit_to_website_timestamp;
    install_data.last_visit_to_chrome_store = last_visit_to_chrome_store_timestamp;
    if (!deepEq$(Object.keys(survey_data).length, 0, '===')) {
      localstorage_setjson("survey_data", survey_data);
      localstorage_setbool("icon_notif_active", true);
    }
  })();
  get_all_message_handlers = __webpack_require__(/*! libs_backend/expose_lib */ "./src/libs_backend/expose_lib.ls").get_all_message_handlers;
  __webpack_require__(/*! libs_backend/expose_backend_libs */ "./src/generated_libs/libs_backend/expose_backend_libs.js");
  ref$ = __webpack_require__(/*! libs_common/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls"), localget = ref$.localget, remoteget = ref$.remoteget, systemjsget = ref$.systemjsget;
  start_syncing_all_data = __webpack_require__(/*! libs_backend/log_sync_utils */ "./src/libs_backend/log_sync_utils.ls").start_syncing_all_data;
  ref$ = __webpack_require__(/*! libs_common/wait_utils */ "./src/libs_common/wait_utils.ls"), make_wait_token = ref$.make_wait_token, wait_for_token = ref$.wait_for_token, finished_waiting = ref$.finished_waiting;
  get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
  get_new_session_id_for_domain = __webpack_require__(/*! libs_common/time_spent_utils */ "./src/libs_common/time_spent_utils.ls").get_new_session_id_for_domain;
  url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
  add_tab_navigation_event = __webpack_require__(/*! libs_backend/session_utils */ "./src/libs_backend/session_utils.ls").add_tab_navigation_event;
  run_every_timeperiod = __webpack_require__(/*! libs_common/common_libs */ "./src/libs_common/common_libs.ls").run_every_timeperiod;
  ref$ = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls"), as_array = ref$.as_array, as_dictset = ref$.as_dictset;
  ref$ = __webpack_require__(/*! libs_common/localstorage_utils */ "./src/libs_common/localstorage_utils.ls"), localstorage_getjson = ref$.localstorage_getjson, localstorage_setjson = ref$.localstorage_setjson, localstorage_getbool = ref$.localstorage_getbool, localstorage_setbool = ref$.localstorage_setbool;
  baseline_time_per_session_for_domain = __webpack_require__(/*! libs_common/gamification_utils */ "./src/libs_backend/gamification_utils.ls").baseline_time_per_session_for_domain;
  moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
  promiseDebounce = __webpack_require__(/*! promise-debounce */ "./node_modules/promise-debounce/index.js");
  ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
  set_active_interventions_for_domain_and_session = __webpack_require__(/*! libs_backend/intervention_manager */ "./src/libs_backend/intervention_manager.ls").set_active_interventions_for_domain_and_session;
  ref$ = __webpack_require__(/*! libs_backend/goal_progress */ "./src/libs_backend/goal_progress.ls"), get_progress_on_enabled_goals_today = ref$.get_progress_on_enabled_goals_today, get_progress_on_goal_this_week = ref$.get_progress_on_goal_this_week;
  is_habitlab_enabled_sync = __webpack_require__(/*! libs_backend/disable_habitlab_utils */ "./src/libs_backend/disable_habitlab_utils.ls").is_habitlab_enabled_sync;
  ensure_history_utils_data_cached = __webpack_require__(/*! libs_common/history_utils */ "./src/libs_backend/history_utils.ls").ensure_history_utils_data_cached;
  ref$ = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls"), log_impression_internal = ref$.log_impression_internal, log_goal_suggestion = ref$.log_goal_suggestion, add_log_history = ref$.add_log_history, log_feedback_internal = ref$.log_feedback_internal;
  sleep = __webpack_require__(/*! libs_common/common_libs */ "./src/libs_common/common_libs.ls").sleep;
  printable_time_spent_short = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").printable_time_spent_short;
  one_random_intervention_per_enabled_goal = __webpack_require__(/*! libs_backend/intervention_selection_algorithms */ "./src/libs_backend/intervention_selection_algorithms.ls").one_random_intervention_per_enabled_goal;
  execute_content_script = function(tabid, options, callback){
    if (tabid == null) {
      if (callback != null) {
        callback();
      }
      return;
    }
    return chrome.tabs.executeScript(tabid, {
      file: options.path,
      allFrames: options.all_frames,
      runAt: options.run_at
    }, function(){
      if (callback != null) {
        return callback();
      }
    });
  };
  insert_css = async function(css_path){};
  running_background_scripts = {};
  load_background_script = async function(options, intervention_info){
    var background_script_text, background_script_function, env;
    if (running_background_scripts[options.path] != null) {
      return;
    }
    if (options.code != null) {
      background_script_text = options.code;
    } else {
      background_script_text = (await localget(options.path));
    }
    background_script_function = new Function('env', background_script_text);
    env = {
      intervention_info: intervention_info
    };
    background_script_function(env);
    running_background_scripts[options.path] = env;
  };
  cached_systemjs_code = null;
  cached_bundle_code = {};
  execute_content_scripts_for_intervention = async function(intervention_info, tabId, intervention_list, is_new_session, session_id, is_preview_mode, is_suggestion_mode, extra_parameter_values){
    var content_script_options, name, is_suggestion_mode_optout, content_script_codes_promises, i$, len$, content_script_option, systemjs_content_script_code_promise, ref$, goal_info, parameter_values, systemjs_content_script_code, content_script_codes, is_previously_seen, seen_interventions_cache, intervention_info_copy, i, parameter, k, v, debug_content_script_code, debug_content_script_code_with_hlog, open_debug_page_if_needed, idx, options, content_script_code, content_script_code_prequel, content_script_debugging_code, promises, chunks, j$, len1$, chunknum, chunkname, bundle_code, fn$ = async function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = intervention_info_copy.parameters.length; i$ < to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }, this$ = this;
    content_script_options = intervention_info.content_script_options, name = intervention_info.name;
    if (localStorage.test_suggestion_mode === 'true') {
      is_suggestion_mode = true;
    }
    is_suggestion_mode_optout = localStorage.getItem('suggestion_mode_optout') === 'true';
    content_script_codes_promises = [];
    for (i$ = 0, len$ = content_script_options.length; i$ < len$; ++i$) {
      content_script_option = content_script_options[i$];
      if (content_script_option.fetch_from_db != null) {
        content_script_codes_promises.push(getkey_dict('custom_intervention_code', content_script_option.fetch_from_db));
      } else if (content_script_option.code != null) {
        content_script_codes_promises.push(Promise.resolve(content_script_option.code));
      } else {
        content_script_codes_promises.push(localget(content_script_option.path));
      }
    }
    if (cached_systemjs_code !== null) {
      systemjs_content_script_code_promise = Promise.resolve(cached_systemjs_code);
    } else {
      systemjs_content_script_code_promise = localget('/intervention_utils/systemjs.js');
    }
    ref$ = (await Promise.all([get_goal_info(intervention_info.goals[0]), get_intervention_parameters(intervention_info.name), systemjs_content_script_code_promise].concat(slice$.call(content_script_codes_promises)))), goal_info = ref$[0], parameter_values = ref$[1], systemjs_content_script_code = ref$[2], content_script_codes = slice$.call(ref$, 3);
    is_previously_seen = false;
    seen_interventions_cache = localStorage.getItem('seen_interventions_cache');
    if (seen_interventions_cache != null) {
      seen_interventions_cache = JSON.parse(seen_interventions_cache);
      if (seen_interventions_cache[name]) {
        is_previously_seen = true;
      }
    }
    if (cached_systemjs_code == null) {
      cached_systemjs_code = systemjs_content_script_code;
    }
    intervention_info_copy = JSON.parse(JSON.stringify(intervention_info));
    for (i$ = 0, len$ = (ref$ = (await (fn$()))).length; i$ < len$; ++i$) {
      i = ref$[i$];
      parameter = intervention_info_copy.parameters[i];
      parameter.value = parameter_values[parameter.name];
      intervention_info_copy.params[parameter.name].value = parameter_values[parameter.name];
    }
    if (extra_parameter_values != null) {
      for (k in extra_parameter_values) {
        v = extra_parameter_values[k];
        intervention_info_copy.params[k] = {
          name: k,
          description: k,
          'default': v,
          value: v,
          type: 'string'
        };
        parameter_values[k] = v;
      }
    }
    debug_content_script_code = "content_script_debug.listen_for_eval(function(command_to_evaluate) {\n  if (window.customeval) {\n    return window.customeval(command_to_evaluate);\n  } else if (window.debugeval) {\n    return window.debugeval(command_to_evaluate);\n  } else {\n    return window.eval(command_to_evaluate);\n    //return eval.bind(this)(command_to_evaluate);\n  }\n});";
    if (intervention_info_copy.params.debug != null && intervention_info_copy.params.debug.value) {
      debug_content_script_code = "content_script_debug.listen_for_eval((x) => { return eval(x); });\ncontent_script_debug.insert_console((x) => { return eval(x); }, {lang: 'livescript'});";
    }
    debug_content_script_code_with_hlog = "SystemJS.import_multi(['prettyprintjs', 'libs_frontend/content_script_debug'], function(prettyprintjs, content_script_debug) {\n  var console_log_orig = window.console.log;\n  var hlog = function(...args) {\n    console_log_orig(...args);\n    var data_string;\n    var err_to_throw = null;\n    try {\n      if (args.length == 1) {\n        data_string = prettyprintjs(args[0]);\n      } else {\n        data_string = prettyprintjs(args);\n      }\n    } catch (err) {\n      data_string = 'Error was thrown. Check Javascript console (Command+Option+J or Ctrl+Shift+J)\\n' + err.message;\n      err_to_throw = err;\n    }\n    " + chrome + ".runtime.sendMessage({type: 'send_to_debug_terminal', data: {tab: tab_id, text: data_string}});\n    if (err_to_throw) {\n      throw err_to_throw;\n    }\n  }\n  var uselib = function(libname, callback) {\n    if (typeof(callback) == 'function') {\n      SystemJS.import(libname).then(callback);\n    } else if (typeof(callback) == 'string') {\n      SystemJS.import(libname).then(function(imported_lib) {\n        window[callback] = imported_lib;\n        hlog('imported as window.' + callback);\n      }, function(err) {\n        console.log(err.message);\n        throw err;\n      });\n    } else if (typeof(libname) == 'string') {\n      callback = libname.toLowerCase().split('').filter((x) => 'abcdefghijklmnopqrstuvwxyz0123456789'.indexOf(x) != -1).join('');\n      SystemJS.import(libname).then(function(imported_lib) {\n        window[callback] = imported_lib;\n        hlog('imported as window.' + callback);\n      }, function(err) {\n        console.log(err.message);\n        throw err;\n      });\n    } else {\n      hlog([\n        'Use uselib() to import jspm libraries.',\n        'The first argument is the library name (under SystemJS, see jspm)',\n        'The second argument is the name it should be given (in the \\'this\\' object)',\n        'Example of using moment:',\n        '    uselib(\\'moment\\', \\'moment\\')',\n        '    window.moment().format()',\n        'Example of using jquery:',\n        '    uselib(\\'jquery\\', \\'$\\')',\n        '    window.$(\\'body\\').css(\\'background-color\\', \\'black\\')',\n        'Example of using sweetalert2:',\n        '    uselib(\\'libs_common/content_script_utils\\', \\'content_script_utils\\')',\n        '    content_script_utils.load_css_file(\\'bower_components/sweetalert2/dist/sweetalert2.css\\')',\n        '    uselib(\\'sweetalert2\\', \\'swal\\')',\n        '    swal(\\'hello world\\')'\n      ].join('\\n'))\n    }\n  }\n  window.hlog = hlog;\n  window.uselib = uselib;\n  window.localeval = function(command_to_evaluate) {\n    return eval(command_to_evaluate);\n  };\n  " + debug_content_script_code + "\n  return;\n});";
    open_debug_page_if_needed = '';
    if (localstorage_getbool('open_debug_console_on_load')) {
      open_debug_page_if_needed = "SystemJS.import('libs_frontend/intervention_debug_console').then(function(intervention_debug_console) {\n  intervention_debug_console.open_debug_page()\n});";
    }
    for (i$ = 0, len$ = content_script_options.length; i$ < len$; ++i$) {
      idx = i$;
      options = content_script_options[i$];
      content_script_code = content_script_codes[idx];
      if (options.jspm_require) {
        content_script_code_prequel = "const intervention = " + JSON.stringify(intervention_info_copy) + ";\nconst parameters = " + JSON.stringify(parameter_values) + ";\nconst tab_id = " + tabId + ";\nconst session_id = " + session_id + ";\nconst is_new_session = " + is_new_session + ";\nconst dlog = function(...args) { console.log(...args); };\nconst set_default_parameters = function(parameter_object) {\n  for (let parameter_name of Object.keys(parameter_object)) {\n    if (parameters[parameter_name] == null) {\n      parameters[parameter_name] = parameter_object[parameter_name];\n    }\n  }\n};\n";
        if (options.debug_code != null && localStorage.getItem('insert_debugging_code') != null) {
          localStorage.removeItem('insert_debugging_code');
          content_script_debugging_code = options.debug_code;
        } else {
          content_script_debugging_code = '';
        }
        content_script_code = "window.Polymer = window.Polymer || {}\nwindow.Polymer.dom = 'shadow'\nSystemJS.import('libs_common/intervention_info').then(function(intervention_info_setter_lib) {\n  intervention_info_setter_lib.set_intervention(" + JSON.stringify(intervention_info_copy) + ");\n  intervention_info_setter_lib.set_goal_info(" + JSON.stringify(goal_info) + ");\n  intervention_info_setter_lib.set_tab_id(" + tabId + ");\n  intervention_info_setter_lib.set_session_id(" + session_id + ");\n  intervention_info_setter_lib.set_is_new_session(" + is_new_session + ");\n  intervention_info_setter_lib.set_is_suggestion_mode(" + is_suggestion_mode + ");\n  intervention_info_setter_lib.set_is_suggestion_mode_optout(" + is_suggestion_mode_optout + ");\n  intervention_info_setter_lib.set_is_previously_seen(" + is_previously_seen + ");\n  SystemJS.import('data:text/javascript;base64," + btoa(unescape(encodeURIComponent(content_script_code_prequel + content_script_debugging_code + content_script_code))) + "');\n});";
        /*
        SystemJS.import('libs_common/intervention_info').then(function(intervention_info_setter_lib) {
          intervention_info_setter_lib.set_intervention(#{JSON.stringify(intervention_info_copy)})
          #{content_script_code}
        })
        */
        /*
        SystemJS.import('libs_common/intervention_info').then(function(intervention_info_setter_lib) {
          intervention_info_setter_lib.set_intervention(#{JSON.stringify(intervention_info_copy)});
          SystemJS.import('data:text/javascript;base64,#{btoa(content_script_code)}');
        })
        */
        /*
        SystemJS.import('libs_common/intervention_info').then(function(intervention_info_setter_lib) {
          intervention_info_panel_timert_intervention(#{JSON.stringify(intervention_info_copy)})
          SystemJS.import('libs_common/systemjs_require').then(function(systemjs_require) {
            systemjs_require.make_require(#{JSON.stringify(options.jspm_deps)}).then(function(require) {
              #{content_script_code}
            })
          })
        })
        */
      }
      content_script_code = "var replacing_current_intervention = false\nif ('" + intervention_info_copy.name + "' != 'internal/choose_difficulty') {\n  if (window.allowed_interventions != null) {\n    var allowed_interventions_list = Object.keys(window.allowed_interventions)\n    if (allowed_interventions_list.length == 1 && allowed_interventions_list[0] == 'internal/choose_difficulty') {\n      replacing_current_intervention = true\n    }\n  }\n}\n\nif (replacing_current_intervention) {\n  for (var intervention_name of " + JSON.stringify(intervention_list) + ") {\n    window.allowed_interventions[intervention_name] = true\n  }\n} else if (!window.allowed_interventions) {\n//if (!window.loaded_interventions) {\n  window.allowed_interventions = " + JSON.stringify(as_dictset(intervention_list)) + ";\n\n  window.onunhandledrejection = function(evt) {\n    throw evt.reason;\n  };\n\n  window.loaded_interventions = {};\n  window.loaded_content_scripts = {};\n}\n\ndocument.addEventListener('pointerdown', (event) => {\n  click_start = new Date();\n  console.log(click_start);\n});\n\nif (replacing_current_intervention || (window.allowed_interventions['" + intervention_info_copy.name + "'] && !window.loaded_interventions['" + intervention_info_copy.name + "'])) {\n  window.loaded_interventions['" + intervention_info_copy.name + "'] = true;\n\n  if (!window.loaded_content_scripts['" + options.path + "']) {\n  //if (true) {\n    window.loaded_content_scripts['" + options.path + "'] = true;\n    const intervention = " + JSON.stringify(intervention_info_copy) + ";\n    const goal_info = " + JSON.stringify(goal_info) + ";\n    const parameters = " + JSON.stringify(parameter_values) + ";\n    const tab_id = " + tabId + ";\n    const session_id = " + session_id + ";\n    const is_new_session = " + is_new_session + ";\n    const is_preview_mode = " + is_preview_mode + ";\n    const is_suggestion_mode = " + is_suggestion_mode + ";\n    const is_suggestion_mode_optout = " + is_suggestion_mode_optout + ";\n    const is_previously_seen = " + is_previously_seen + ";\n    const dlog = function(...args) { console.log(...args); };\n    const set_default_parameters = function(parameter_object) {\n      for (let parameter_name of Object.keys(parameter_object)) {\n        if (parameters[parameter_name] == null) {\n          parameters[parameter_name] = parameter_object[parameter_name];\n        }\n      }\n    };\n    window.intervention_disabled = false;\n\n    if (!window.SystemJS) {\n      " + systemjs_content_script_code + "\n    }\n    " + content_script_code + "\n    " + debug_content_script_code_with_hlog + "\n\n    (async function() {\n      while (document.body == null) {\n        await new Promise(function(cb) {\n          setTimeout(cb, 30);\n        });\n      }\n      document.body.addEventListener('disable_intervention', function() {\n        window.intervention_disabled = true;\n        if (typeof(window.on_intervention_disabled) == 'function') {\n          window.on_intervention_disabled();\n        } else {\n          SystemJS.import_multi(['libs_frontend/content_script_utils', 'sweetalert2'], function(content_script_utils, sweetalert) {\n            content_script_utils.load_css_file('sweetalert2').then(function() {\n              sweetalert({\n                title: 'Reload page to turn off intervention',\n                text: 'This intervention has not implemented support for disabling itself. Reload the page to disable it.'\n              });\n            });\n          });\n        }\n        SystemJS.import('libs_frontend/intervention_log_utils').then(function(log_utils) {\n          log_utils.log_disable();\n        });\n      });\n    })();\n\n    SystemJS.import_multi(['libs_common/intervention_info', 'libs_frontend/intervention_log_utils'], function(intervention_info_setter_lib, log_utils) {\n      intervention_info_setter_lib.set_intervention(intervention);\n      intervention_info_setter_lib.set_goal_info(goal_info);\n      intervention_info_setter_lib.set_tab_id(tab_id);\n      intervention_info_setter_lib.set_session_id(session_id);\n      intervention_info_setter_lib.set_is_new_session(is_new_session);\n      intervention_info_setter_lib.set_is_preview_mode(is_preview_mode);\n      intervention_info_setter_lib.set_is_suggestion_mode(is_suggestion_mode);\n      intervention_info_setter_lib.set_is_suggestion_mode_optout(is_suggestion_mode_optout);\n      if (is_suggestion_mode) {\n        if (is_suggestion_mode_optout) {\n          log_utils.log_intervention_suggested({optout: true});\n          log_utils.log_intervention_suggestion_action({action: 'accepted', 'accepted': 'true', 'optout': 'true', 'accepted_default': 'true'})\n        } else {\n          log_utils.log_intervention_suggested();\n        }\n      } else {\n        log_utils.log_impression();\n      }\n      " + open_debug_page_if_needed + "\n    });\n  }\n}";
      promises = [];
      chunks = find_webpack_chunks(content_script_code);
      for (j$ = 0, len1$ = chunks.length; j$ < len1$; ++j$) {
        chunknum = chunks[j$];
        chunkname = chunknum + '.js';
        if (cached_bundle_code[chunkname] != null) {
          bundle_code = cached_bundle_code[chunkname];
        } else {
          bundle_code = (await fetch(chunkname).then(fn1$));
          cached_bundle_code[chunkname] = bundle_code;
        }
        promises.push(new Promise(fn2$));
      }
      (await Promise.all(promises));
      (await new Promise(fn3$));
    }
    function fn1$(it){
      return it.text();
    }
    function fn2$(it){
      return chrome.tabs.executeScript(tabId, {
        code: bundle_code,
        allFrames: options.all_frames,
        runAt: options.run_at
      }, it);
    }
    function fn3$(it){
      return chrome.tabs.executeScript(tabId, {
        code: content_script_code,
        allFrames: options.all_frames,
        runAt: options.run_at
      }, it);
    }
  };
  find_webpack_chunks = function(code){
    var chunks, index, end1, end2, end, cutCode, innerIndex, numberEnd, numberLength, number, number_parsed;
    chunks = [];
    index = code.indexOf('async function habitlab_intervention_main_function(){');
    if (index === -1) {
      return [];
    }
    index += 'async function habitlab_intervention_main_function(){'.length;
    end1 = code.indexOf("]).then((async function(", index);
    end2 = code.indexOf("]).then(async function(", index);
    if (end1 === -1) {
      end = end2;
    } else if (end2 === -1) {
      end = end1;
    } else {
      end = Math.min(end1, end2);
    }
    cutCode = code.substring(index, end);
    index = 0;
    end = cutCode.length;
    if (index < 0) {
      return;
    }
    while (index < end) {
      innerIndex = cutCode.indexOf(".e(", index) + 3;
      numberEnd = cutCode.indexOf(")", innerIndex);
      if (innerIndex < index || innerIndex === -1 || numberEnd === -1) {
        return chunks;
      }
      numberLength = numberEnd - innerIndex;
      number = cutCode.substring(innerIndex, numberEnd);
      number_parsed = parseInt(number, 10);
      if (isFinite(number_parsed)) {
        chunks.push(number_parsed);
      }
      index = numberEnd;
    }
    return chunks;
  };
  load_intervention_for_session_id = async function(intervention_name, tabId, session_id, is_new_session){
    var is_preview_mode, is_suggestion_mode, intervention_list;
    is_preview_mode = false;
    is_suggestion_mode = false;
    intervention_list = [intervention_name];
    load_intervention_list(intervention_list, tabId, is_new_session, session_id, is_preview_mode, is_suggestion_mode);
  };
  load_intervention_list = async function(intervention_list, tabId, is_new_session, session_id, is_preview_mode, is_suggestion_mode){
    var all_interventions, intervention_info_list, res$, i$, len$, intervention_name, intervention_info, j$, ref$, len1$, options, css_file, css_code;
    if (intervention_list.length === 0) {
      return;
    }
    all_interventions = (await get_interventions());
    res$ = [];
    for (i$ = 0, len$ = intervention_list.length; i$ < len$; ++i$) {
      intervention_name = intervention_list[i$];
      res$.push(all_interventions[intervention_name]);
    }
    intervention_info_list = res$;
    for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
      intervention_info = intervention_info_list[i$];
      for (j$ = 0, len1$ = (ref$ = intervention_info.background_script_options).length; j$ < len1$; ++j$) {
        options = ref$[j$];
        (await load_background_script(options, intervention_info));
      }
    }
    for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
      intervention_info = intervention_info_list[i$];
      if (intervention_info.css_files != null) {
        for (j$ = 0, len1$ = (ref$ = intervention_info.css_files).length; j$ < len1$; ++j$) {
          css_file = ref$[j$];
          (await new Promise(fn$));
        }
      }
      if (intervention_info.styles != null) {
        for (j$ = 0, len1$ = (ref$ = intervention_info.styles).length; j$ < len1$; ++j$) {
          css_code = ref$[j$];
          (await new Promise(fn1$));
        }
      }
    }
    for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
      intervention_info = intervention_info_list[i$];
      (await execute_content_scripts_for_intervention(intervention_info, tabId, intervention_list, is_new_session, session_id, is_preview_mode, is_suggestion_mode, {
        'difficulty_selector_screen': ''
      }));
    }
    function fn$(it){
      return chrome.tabs.insertCSS(tabId, {
        file: css_file
      }, it);
    }
    function fn1$(it){
      return chrome.tabs.insertCSS(tabId, {
        code: css_code
      }, it);
    }
  };
  list_loaded_interventions = async function(){
    return (await send_message_to_active_tab('list_loaded_interventions', {}));
  };
  get_session_id_for_tab_id_and_domain = async function(tabId, domain){
    var session_id;
    if (tab_id_to_domain_to_session_id[tabId] == null) {
      tab_id_to_domain_to_session_id[tabId] = {};
    }
    session_id = tab_id_to_domain_to_session_id[tabId][domain];
    if (session_id != null) {
      return [session_id, false];
    }
    session_id = (await get_new_session_id_for_domain(domain));
    tab_id_to_domain_to_session_id[tabId][domain] = session_id;
    return [session_id, true];
  };
  tab_id_to_loaded_interventions = {};
  domain_to_prev_enabled_interventions = {};
  page_was_just_refreshed = false;
  load_intervention_for_location = promiseDebounce(async function(location, tabId){
    var is_suggestion_mode, domain, ref$, session_id, is_new_session, override_enabled_interventions, has_enabled_spend_less_time_goal, prev_enabled_interventions, all_enabled_interventions, enabled_intervention_set_changed, active_interventions, should_set_active_interventions, possible_interventions, intervention, intervention_suggestion, intervention_no_longer_enabled, need_new_session_id, interventions_to_load, is_preview_mode, choose_difficulty_interface, frequency_of_choose_difficulty, choose_by_temporary_difficulty, asknext_time, all_interventions, goals_list, temporary_difficulty, chosen_intervention_name, intervention_info_new, intervention_info, k, v, permanently_enabled_interventions, all_available_interventions, i$, len$, permanently_enabled_intervention;
    if (is_it_outside_work_hours() && localStorage.getItem('override_enabled_interventions_once') == null) {
      if (!disable_icon_changes) {
        chrome.browserAction.setIcon({
          tabId: tabId,
          path: chrome.extension.getURL('icons/icon_disabled.svg')
        });
      }
      return;
    }
    if (!is_habitlab_enabled_sync()) {
      if (!disable_icon_changes) {
        chrome.browserAction.setIcon({
          tabId: tabId,
          path: chrome.extension.getURL('icons/icon_disabled.svg')
        });
      }
      return;
    }
    is_suggestion_mode = false;
    domain = url_to_domain(location);
    ref$ = (await get_session_id_for_tab_id_and_domain(tabId, domain)), session_id = ref$[0], is_new_session = ref$[1];
    dlog('session_id is:');
    dlog(session_id);
    dlog('is_new_session is:');
    dlog(is_new_session);
    override_enabled_interventions = localStorage.getItem('override_enabled_interventions_once');
    has_enabled_spend_less_time_goal = (await site_has_enabled_spend_less_time_goal(domain));
    if (!has_enabled_spend_less_time_goal && override_enabled_interventions == null) {
      return;
    }
    if (domain_to_prev_enabled_interventions[domain] == null) {
      domain_to_prev_enabled_interventions[domain] = [];
    }
    prev_enabled_interventions = domain_to_prev_enabled_interventions[domain];
    all_enabled_interventions = (await list_all_enabled_interventions_for_location(domain));
    if (all_enabled_interventions.length === 0 && override_enabled_interventions == null) {
      return;
    }
    domain_to_prev_enabled_interventions[domain] = all_enabled_interventions;
    enabled_intervention_set_changed = JSON.stringify(all_enabled_interventions) !== JSON.stringify(prev_enabled_interventions);
    active_interventions = (await getkey_dictdict('interventions_active_for_domain_and_session', domain, session_id));
    dlog('active_interventions is');
    dlog(active_interventions);
    dlog('override_enabled_interventions is');
    dlog(override_enabled_interventions);
    should_set_active_interventions = false;
    if (active_interventions == null) {
      if (override_enabled_interventions != null) {
        possible_interventions = as_array(JSON.parse(override_enabled_interventions));
      } else {
        possible_interventions = (await list_enabled_nonconflicting_interventions_for_location(domain));
      }
      intervention = possible_interventions[Math.floor(Math.random() * possible_interventions.length)];
      intervention_suggestion = (await get_suggested_intervention_if_needed_for_url(location));
      if (intervention_suggestion != null) {
        intervention = intervention_suggestion;
        is_suggestion_mode = true;
      }
      should_set_active_interventions = true;
      localStorage.removeItem('override_enabled_interventions_once');
    } else {
      active_interventions = JSON.parse(active_interventions);
      intervention = active_interventions[Math.floor(Math.random() * active_interventions.length)];
      intervention_no_longer_enabled = false;
      need_new_session_id = false;
      if (intervention != null) {
        intervention_no_longer_enabled = all_enabled_interventions.length > 0 && all_enabled_interventions.indexOf(intervention) === -1;
        if (intervention_no_longer_enabled) {
          need_new_session_id = true;
        }
      }
      if (enabled_intervention_set_changed) {
        need_new_session_id = true;
      }
      if (need_new_session_id && is_new_session) {
        dlog('intervention is no longer enabled. choosing new session id');
        dlog('tabid is ' + tabId);
        dlog('domain is ' + domain);
        dlog('old session_id is ' + session_id);
        dlog('active_interventions');
        dlog(active_interventions);
        dlog('all_enabled_interventions');
        dlog(all_enabled_interventions);
        session_id = (await get_new_session_id_for_domain(domain));
        tab_id_to_domain_to_session_id[tabId][domain] = session_id;
        if (override_enabled_interventions != null) {
          possible_interventions = as_array(JSON.parse(override_enabled_interventions));
        } else {
          possible_interventions = (await list_enabled_nonconflicting_interventions_for_location(location));
        }
        intervention = possible_interventions[0];
        intervention_suggestion = (await get_suggested_intervention_if_needed_for_url(location));
        if (intervention_suggestion != null) {
          intervention = intervention_suggestion;
          is_suggestion_mode = true;
        }
        should_set_active_interventions = true;
        localStorage.removeItem('override_enabled_interventions_once');
      }
    }
    page_was_just_refreshed = false;
    interventions_to_load = [];
    if (intervention != null) {
      interventions_to_load.push(intervention);
    }
    is_preview_mode = override_enabled_interventions != null;
    if (is_new_session && intervention != null && !is_preview_mode && !is_suggestion_mode && localStorage.frequency_of_choose_difficulty != null) {
      choose_difficulty_interface = localStorage.choose_difficulty_interface;
      frequency_of_choose_difficulty = localStorage.frequency_of_choose_difficulty;
      choose_by_temporary_difficulty = false;
      if (frequency_of_choose_difficulty === 'nextvisit' || frequency_of_choose_difficulty === 'day' || frequency_of_choose_difficulty === 'survey') {
        asknext_time = localStorage.asknext_time;
        if (!isFinite(parseInt(asknext_time))) {
          choose_by_temporary_difficulty = false;
        } else {
          asknext_time = parseInt(asknext_time);
          if (Date.now() < asknext_time) {
            choose_by_temporary_difficulty = true;
          } else {
            choose_by_temporary_difficulty = false;
          }
        }
      } else if (isFinite(parseFloat(frequency_of_choose_difficulty))) {
        frequency_of_choose_difficulty = parseFloat(frequency_of_choose_difficulty);
        choose_by_temporary_difficulty = !(Math.random() < frequency_of_choose_difficulty);
      }
      all_interventions = (await get_interventions());
      goals_list = (await list_nonpositive_goals_for_location(location));
      temporary_difficulty = localStorage.getItem('temporary_difficulty');
      if (temporary_difficulty == null) {
        temporary_difficulty = localStorage.user_chosen_difficulty_survey;
      }
      if (temporary_difficulty == null) {
        temporary_difficulty = localStorage.user_chosen_difficulty;
      }
      if (temporary_difficulty == null) {
        choose_by_temporary_difficulty = false;
      }
      if (choose_by_temporary_difficulty) {
        if (goals_list.length === 0 || ['easy', 'medium', 'hard'].indexOf(temporary_difficulty) === -1) {
          (await set_active_interventions_for_domain_and_session(domain, session_id, []));
          if (!disable_icon_changes) {
            chrome.browserAction.setIcon({
              tabId: tabId,
              path: chrome.extension.getURL('icons/icon_disabled.svg')
            });
          }
          return;
        }
        chosen_intervention_name = (await choose_intervention_for_difficulty_level_and_goal(temporary_difficulty, goals_list[0]));
        interventions_to_load = [chosen_intervention_name];
        intervention_info_new = all_interventions[chosen_intervention_name];
        (await set_active_interventions_for_domain_and_session(domain, session_id, interventions_to_load));
        (await execute_content_scripts_for_intervention(intervention_info_new, tabId, interventions_to_load, is_new_session, session_id, override_enabled_interventions != null, is_suggestion_mode, {
          'choose_difficulty_screen': choose_difficulty_interface,
          'frequency_of_choose_difficulty': frequency_of_choose_difficulty
        }));
        if (!disable_icon_changes) {
          chrome.browserAction.setIcon({
            tabId: tabId,
            path: chrome.extension.getURL('icons/icon_active.svg')
          });
        }
        return;
      } else {
        interventions_to_load = ['internal/choose_difficulty'];
        intervention_info = all_interventions['internal/choose_difficulty'];
        intervention_info_new = {};
        for (k in intervention_info) {
          v = intervention_info[k];
          if (k === 'goals') {
            v = goals_list;
          }
          intervention_info_new[k] = v;
        }
        (await set_active_interventions_for_domain_and_session(domain, session_id, interventions_to_load));
        choose_difficulty_interface = 'this_intervention';
        if (localStorage.choose_difficulty_interface != null) {
          choose_difficulty_interface = localStorage.choose_difficulty_interface;
        }
        (await execute_content_scripts_for_intervention(intervention_info_new, tabId, interventions_to_load, is_new_session, session_id, override_enabled_interventions != null, is_suggestion_mode, {
          'choose_difficulty_interface': choose_difficulty_interface,
          'frequency_of_choose_difficulty': frequency_of_choose_difficulty
        }));
        if (!disable_icon_changes) {
          chrome.browserAction.setIcon({
            tabId: tabId,
            path: chrome.extension.getURL('icons/icon_active.svg')
          });
        }
        return;
      }
    }
    if (should_set_active_interventions) {
      if (intervention != null) {
        (await set_active_interventions_for_domain_and_session(domain, session_id, [intervention]));
      } else {
        (await set_active_interventions_for_domain_and_session(domain, session_id, []));
      }
    }
    if (override_enabled_interventions == null) {
      permanently_enabled_interventions = localStorage.getItem('permanently_enabled_interventions');
      if (permanently_enabled_interventions != null) {
        permanently_enabled_interventions = as_array(JSON.parse(permanently_enabled_interventions));
        all_available_interventions = (await list_available_interventions_for_location(location));
        all_available_interventions = as_dictset(all_available_interventions);
        permanently_enabled_interventions = permanently_enabled_interventions.filter(function(x){
          return all_available_interventions[x];
        });
        for (i$ = 0, len$ = permanently_enabled_interventions.length; i$ < len$; ++i$) {
          permanently_enabled_intervention = permanently_enabled_interventions[i$];
          if (permanently_enabled_intervention !== intervention) {
            interventions_to_load.push(permanently_enabled_intervention);
          }
        }
      }
    }
    tab_id_to_loaded_interventions[tabId] = interventions_to_load;
    dlog('interventions to load is:');
    dlog(interventions_to_load);
    (await load_intervention_list(interventions_to_load, tabId, is_new_session, session_id, override_enabled_interventions != null, is_suggestion_mode));
    if (interventions_to_load.length > 0) {
      if (!disable_icon_changes) {
        chrome.browserAction.setIcon({
          tabId: tabId,
          path: chrome.extension.getURL('icons/icon_active.svg')
        });
      }
    } else {
      if (!disable_icon_changes) {
        chrome.browserAction.setIcon({
          tabId: tabId,
          path: chrome.extension.getURL('icons/icon_disabled.svg')
        });
      }
    }
  });
  /*
  load_intervention_for_location = (location, tabId) ->>
    {work_hours_only ? 'false', start_mins_since_midnight ? '0', end_mins_since_midnight ? '1440'} = localStorage
    work_hours_only = work_hours_only == 'true'
    start_mins_since_midnight = parseInt start_mins_since_midnight
    end_mins_since_midnight = parseInt end_mins_since_midnight
    mins_since_midnight = moment().hours()*60 + moment().minutes()
    if work_hours_only and not (start_mins_since_midnight <= mins_since_midnight <= end_mins_since_midnight)
      return
    possible_interventions = await list_enabled_nonconflicting_interventions_for_location(location)
    for intervention in possible_interventions
      await load_intervention intervention, tabId
    localStorage.removeItem('override_enabled_interventions_once')
    return
  */
  getLocation = async function(){
    var tabinfo;
    tabinfo = (await get_active_tab_info());
    return tabinfo.url;
  };
  split_list_by_length = function(list, len){
    var output, curlist, i$, len$, x;
    output = [];
    curlist = [];
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      x = list[i$];
      curlist.push(x);
      if (curlist.length === len) {
        output.push(curlist);
        curlist = [];
      }
    }
    if (curlist.length > 0) {
      output.push(curlist);
    }
    return output;
  };
  iframed_domain_to_track = null;
  tabs_to_listen_for_focus = new Set();
  css_packages = __webpack_require__(/*! libs_common/css_packages */ "./src/libs_common/css_packages.ls");
  css_files_cached = __webpack_require__(/*! libs_common/css_files_cached */ "./src/libs_common/css_files_cached.js");
  message_handlers = get_all_message_handlers();
  message_handlers['print_message'] = async function(data){
    console.log(data);
  };
  message_handlers['getLocation'] = async function(data){
    var location;
    location = (await getLocation());
    return location;
  };
  message_handlers['load_intervention'] = async function(data){
    var domain, intervention_name, tabId, session_id, is_new_session;
    domain = data.domain, intervention_name = data.intervention_name, tabId = data.tabId, session_id = data.session_id, is_new_session = data.is_new_session;
    (await load_intervention_for_session_id(intervention_name, tabId, session_id, is_new_session));
    (await setkey_dictdict('interventions_active_for_domain_and_session', domain, session_id, JSON.stringify([intervention_name])));
  };
  message_handlers['load_intervention_for_location'] = async function(data){
    var location, tabId;
    location = data.location, tabId = data.tabId;
    (await load_intervention_for_location(location, tabId));
  };
  message_handlers['load_css_file'] = async function(data){
    var css_file, tab, tabid, css_code;
    css_file = data.css_file, tab = data.tab;
    tabid = tab.id;
    if (css_packages[css_file] != null) {
      css_file = css_packages[css_file];
    }
    if (css_file.startsWith('http://') || css_file.startsWith('https://')) {
      css_code = (await remoteget(css_file));
      (await new Promise(function(it){
        return chrome.tabs.insertCSS(tabid, {
          code: css_code
        }, it);
      }));
    } else {
      if (css_files_cached[css_file] != null) {
        css_code = css_files_cached[css_file];
      } else {
        css_code = (await systemjsget(css_file));
      }
      (await new Promise(function(it){
        return chrome.tabs.insertCSS(tabid, {
          code: css_code
        }, it);
      }));
    }
  };
  message_handlers['load_css_code'] = async function(data){
    var css_code, tab, tabid;
    css_code = data.css_code, tab = data.tab;
    tabid = tab.id;
    (await new Promise(function(it){
      return chrome.tabs.insertCSS(tabid, {
        code: css_code
      }, it);
    }));
  };
  message_handlers['send_to_debug_terminal'] = async function(data){
    var existing_messages;
    existing_messages = localstorage_getjson('debug_terminal_messages');
    if (existing_messages == null) {
      existing_messages = [];
    }
    existing_messages.push(data);
    localstorage_setjson('debug_terminal_messages', existing_messages);
  };
  message_handlers['set_alternative_url_to_track'] = async function(data){
    var url;
    url = data.url;
    if (url != null) {
      iframed_domain_to_track = url_to_domain(url);
    } else {
      iframed_domain_to_track = null;
    }
  };
  message_handlers['register_listener_for_tab_focus'] = async function(data, sender){
    var tab;
    tab = data.tab;
    tabs_to_listen_for_focus.add(tab.id);
  };
  message_handlers['remove_listener_for_tab_focus'] = async function(data, sender){
    var tab;
    tab = data.tab;
    if (tabs_to_listen_for_focus.has(tab.id)) {
      tabs_to_listen_for_focus['delete'](tab.id);
    }
  };
  message_handlers['log_clicks'] = async function(click_data){
    var click_buffer;
    click_buffer = JSON.parse(localStorage.getItem("click_rate_buffer"));
    if (click_buffer.length >= 10000) {
      click_buffer = click_buffer.slice(1, 10001);
    }
    click_buffer.push(click_data);
    localStorage.setItem("click_rate_buffer", JSON.stringify(click_buffer));
  };
  message_handlers['log_typing_rate'] = async function(typing_rate_msg){
    var buffer;
    buffer = JSON.parse(localStorage.getItem("typing_rate_buffer"));
    if (buffer.length >= 10000) {
      buffer = buffer.slice(1, 10001);
    }
    buffer.push(typing_rate_msg);
    localStorage.setItem("typing_rate_buffer", JSON.stringify(buffer));
  };
  message_handlers['log_scrolls'] = async function(scroll_msg){
    var buffer;
    buffer = JSON.parse(localStorage.getItem("scroll_rate_buffer"));
    if (buffer.length >= 100000) {
      buffer = buffer.slice(1, 100001);
    }
    buffer.push(scroll_msg);
    localStorage.setItem("scroll_rate_buffer", JSON.stringify(buffer));
    /*
    buffer.push(scroll_msg);
    scroll_dates = "date"#scroll_msg["data"]["scroll_dates"]
    buffer_data = "scrolls"#scroll_msg["data"]["scroll_buffer"]
    # data is a list
    curr_dates = JSON.parse(localStorage.getItem("scroll_rate_dates"))
    curr_buffer = JSON.parse(localStorage.getItem("scroll_rate_buffer"))
    if buffer.length >= 1000
      buffer = buffer.slice(1,1001)
    console.log(buffer)
    dates_update = curr_dates.concat(scroll_dates)
    buffer_update = curr_buffer.concat(buffer_data)
    #console.log(dates_update)
    #console.log(buffer_update)
    localStorage.setItem("scroll_rate_buffer", JSON.stringify(buffer_update))
    localStorage.setItem("scroll_rate_dates", JSON.stringify(dates_update))
    #buffer.push(data)
    console.log(buffer)
    */
  };
  prev_domain = '';
  domain_changed = function(new_domain){
    var current_day;
    prev_domain = new_domain;
    current_day = get_days_since_epoch();
    return addtokey_dictdict('visits_to_domain_per_day', new_domain, current_day, 1, function(total_visits){});
  };
  tab_id_to_domain_to_session_id = {};
  tab_id_to_url = {};
  out$.list_domain_to_session_ids = list_domain_to_session_ids = function(){
    var tab_id, ref$, domain_to_session_id, results$ = [];
    for (tab_id in ref$ = tab_id_to_domain_to_session_id) {
      domain_to_session_id = ref$[tab_id];
      results$.push(dlog(domain_to_session_id));
    }
    return results$;
  };
  ref$ = __webpack_require__(/*! libs_backend/duolingo_utils */ "./src/libs_backend/duolingo_utils.js"), get_last_duolingo_progress_update_time = ref$.get_last_duolingo_progress_update_time, update_duolingo_progress = ref$.update_duolingo_progress;
  setInterval(async function(){
    var enabled_goals, last_duolingo_progress_check;
    enabled_goals = (await get_enabled_goals());
    if (enabled_goals['duolingo/complete_lesson_each_day']) {
      last_duolingo_progress_check = get_last_duolingo_progress_update_time();
      if (moment().diff(last_duolingo_progress_check, 'hours') > 1) {
        return update_duolingo_progress();
      }
    }
  }, 5 * 60 * 1000);
  navigation_occurred = function(url, tabId, is_from_history, changeInfo){
    var new_domain;
    new_domain = url_to_domain(url);
    if (prev_domain === "www.duolingo.com") {
      update_duolingo_progress();
    }
    if (new_domain !== prev_domain) {
      domain_changed(new_domain);
      iframed_domain_to_track = null;
    }
    if (!(url.startsWith('http://') || url.startsWith('https://'))) {
      if (!disable_icon_changes) {
        chrome.browserAction.setIcon({
          tabId: tabId,
          path: chrome.extension.getURL('icons/HSO_icons/logo.svg')
        });
      }
      return;
    }
    if (!is_from_history && changeInfo != null && changeInfo.status === 'loading') {
      return load_intervention_for_location(url, tabId).then(function(){
        var loaded_interventions;
        loaded_interventions = tab_id_to_loaded_interventions[tabId];
        if (loaded_interventions != null && loaded_interventions.length > 0) {
          if (!disable_icon_changes) {
            return chrome.browserAction.setIcon({
              tabId: tabId,
              path: chrome.extension.getURL('icons/icon_active.svg')
            });
          }
        } else {
          if (is_habitlab_enabled_sync() && !is_it_outside_work_hours()) {
            if (!disable_icon_changes) {
              return chrome.browserAction.setIcon({
                tabId: tabId,
                path: chrome.extension.getURL('icons/icon.svg')
              });
            }
          } else {
            if (!disable_icon_changes) {
              return chrome.browserAction.setIcon({
                tabId: tabId,
                path: chrome.extension.getURL('icons/icon_disabled.svg')
              });
            }
          }
        }
      });
    }
  };
  chrome.windows.onFocusChanged.addListener(function(windowId){
    return iframed_domain_to_track = null;
  });
  chrome.windows.onRemoved.addListener(function(windowId){
    return iframed_domain_to_track = null;
  });
  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab){
    if (changeInfo.status === 'loading' && changeInfo.url == null) {
      page_was_just_refreshed = true;
      iframed_domain_to_track = null;
    }
    if (tab.url) {
      tab_id_to_url[tabId] = tab.url;
      if (changeInfo.status === 'loading') {
        add_tab_navigation_event(tabId, tab.url);
      }
      send_message_to_tabid(tabId, 'navigation_occurred', {
        url: tab.url,
        tabId: tabId,
        is_from_history: false
      });
      return navigation_occurred(tab.url, tabId, false, changeInfo);
    }
  });
  reward_display_base_code_cached = null;
  chrome.tabs.onActivated.addListener(async function(activeInfo){
    var tabId;
    tabId = activeInfo.tabId;
    if (tabs_to_listen_for_focus.has(tabId)) {
      return send_message_to_tabid(tabId, 'tab_activated', {});
    }
  });
  chrome.tabs.onRemoved.addListener(async function(tabId, info){
    var url, domain, session_id, interventions_active, baseline_seconds_spent, seconds_spent, seconds_saved, current_tab_info, intervention_info, intervention_name, generic_name, ref$, existing_rating, reward_display_code, this$ = this;
    iframed_domain_to_track = null;
    if (tabs_to_listen_for_focus.has(tabId)) {
      tabs_to_listen_for_focus['delete'](tabId);
    }
    url = tab_id_to_url[tabId];
    if (url == null) {
      return;
    }
    domain = url_to_domain(url);
    if (tab_id_to_domain_to_session_id[tabId] == null) {
      return;
    }
    session_id = tab_id_to_domain_to_session_id[tabId][domain];
    if (session_id == null) {
      return;
    }
    delete tab_id_to_domain_to_session_id[tabId];
    delete tab_id_to_url[tabId];
    delete tab_id_to_loaded_interventions[tabId];
    interventions_active = (await getkey_dictdict('interventions_active_for_domain_and_session', domain, session_id));
    if (interventions_active == null || interventions_active.length === 0 || interventions_active === '[]') {
      return;
    }
    if (reward_display_base_code_cached === null) {
      reward_display_base_code_cached = (await fetch('frontend_utils/close_tab_message.js').then(function(it){
        return it.text();
      }));
    }
    baseline_seconds_spent = (await baseline_time_per_session_for_domain(domain));
    seconds_spent = (await getkey_dictdict('seconds_on_domain_per_session', domain, session_id));
    if (seconds_spent > baseline_seconds_spent) {
      return;
    }
    if (isNaN(seconds_spent)) {
      seconds_spent = 0;
    }
    seconds_saved = baseline_seconds_spent - seconds_spent;
    current_tab_info = (await get_active_tab_info());
    if (current_tab_info == null || current_tab_info.url == null) {
      return;
    }
    if (!(current_tab_info.url.startsWith('http://') || current_tab_info.url.startsWith('https://'))) {
      return;
    }
    if (localStorage.getItem('intervention_intensity_polling') === 'true') {
      interventions_active = JSON.parse(interventions_active);
      if (interventions_active[0] == null) {
        return;
      }
      intervention_info = (await get_intervention_info(interventions_active[0]));
      if (intervention_info == null) {
        return;
      }
      if (intervention_info.custom) {
        return;
      }
      intervention_name = intervention_info.name;
      if (intervention_name.startsWith('internal/')) {
        return;
      }
      generic_name = (ref$ = intervention_info.generic_intervention) != null ? ref$ : intervention_name;
      existing_rating = (await get_intensity_level_for_intervention(generic_name));
      if (existing_rating != null) {
        return;
      }
      reward_display_code = ['window.reward_display_intervention_info = ' + JSON.stringify(intervention_info), reward_display_base_code_cached].join('\n\n;\n\n');
      chrome.tabs.executeScript(current_tab_info.id, {
        code: reward_display_code
      });
      return (await log_feedback_internal(intervention_name, {
        feedback_type: 'intensity_prompt_shown',
        generic_name: generic_name,
        intervention_name: intervention_name
      }));
    }
  });
  /*
  setInterval ->>
    base_code = await fetch('frontend_utils/close_tab_message.js').then (.text!)
    reward_display_code = "window.reward_display_seconds_saved = 6;\n\n" + base_code
    current_tab_info = await get_active_tab_info()
    chrome.tabs.executeScript current_tab_info.id, {code: reward_display_code}
  , 5000
  */
  chrome.history.onVisited.addListener(function(info){
    return add_log_history(info);
  });
  chrome.webNavigation.onHistoryStateUpdated.addListener(function(info){
    send_message_to_tabid(info.tabId, 'navigation_occurred', {
      url: info.url,
      tabId: info.tabId,
      is_from_history: true
    });
    return navigation_occurred(info.url, info.tabId, true, {});
  });
  message_handlers_requiring_tab = {
    'load_css_file': true,
    'load_css_code': true,
    'register_listener_for_tab_focus': true,
    'remove_listener_for_tab_focus': true
  };
  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){
    var type, data, message_handler;
    type = request.type, data = request.data;
    message_handler = message_handlers[type];
    if (message_handler == null) {
      return;
    }
    if (message_handlers_requiring_tab[type]) {
      if (typeof data === 'object' && data !== null && sender.tab != null && data.tab == null) {
        data = import$({}, data);
        data.tab = sender.tab;
      }
    }
    message_handler(data).then(function(response){
      if (sendResponse != null) {
        return sendResponse(response);
      }
    });
    if (sendResponse != null) {
      return true;
    } else {
      return false;
    }
  });
  current_idlestate = 'active';
  if ((ref$ = chrome.idle) != null) {
    if ((ref1$ = ref$.onStateChanged) != null) {
      if (typeof ref1$.addListener == 'function') {
        ref1$.addListener(function(idlestate){
          current_idlestate = idlestate;
          return dlog("idle state changed: " + idlestate);
        });
      }
    }
  }
  prev_browser_focused = false;
  setInterval(function(){
    return chrome.windows.getCurrent(function(browser){
      var focused;
      focused = browser.focused;
      if (focused !== prev_browser_focused) {
        return prev_browser_focused = focused;
      }
    });
  }, 500);
  /*
  export list_current_tab_ids = ->
    chrome.tabs.query {}, (tabs) ->
      output = {}
      for tab in tabs
        output[tab.url] = tab.id
      dlog output
  */
  updates_to_sync = [];
  mobile_server = '';
  /*setInterval (->>
    if localStorage.sync_with_mobile != 'true'
      return
    user_id = await get_user_id();
    timestamp = Date.now()
  
    if updates_to_sync.length == 0
      return
    domain_to_num_seconds_to_increment = {}
    for {domain, seconds} in updates_to_sync
      if not domain_to_num_seconds_to_increment[domain]?
        domain_to_num_seconds_to_increment[domain] = 0
      domain_to_num_seconds_to_increment[domain] += seconds
    updates_to_sync.length = 0
    post_json(mobile_server + '/addsessiontototal', {
      userid: user_id
      timestamp: timestamp
      domains_time: domain_to_num_seconds_to_increment
      utcOffset: moment().utcOffset()
    })
    #if updates_to_sync.length > 0
    #  data = updates_to_sync.shift()
    #  console.log(data)
    #  #post_json(mobile_server '/addsessiontototal', data)
  ), 30000 */
  goal_suggestion_threshold = parseInt(localStorage.goal_suggestion_threshold);
  suggest_goal_base_code = null;
  domain_to_time_last_suggested_goal = {};
  setInterval(async function(){
    var active_tab, current_domain, current_day, has_enabled_goal, domain_to_session_id, session_id, seconds_spent_this_session;
    if (!prev_browser_focused) {
      return;
    }
    active_tab = (await get_active_tab_info());
    if (active_tab == null) {
      return;
    }
    if (!(active_tab.url.startsWith('http://') || active_tab.url.startsWith('https://'))) {
      return;
    }
    if (iframed_domain_to_track != null) {
      current_domain = iframed_domain_to_track;
    } else {
      current_domain = url_to_domain(active_tab.url);
    }
    if (current_idlestate !== 'active' && !is_video_domain(current_domain)) {
      return;
    }
    current_day = get_days_since_epoch();
    has_enabled_goal = (await site_has_enabled_spend_less_time_goal(current_domain));
    if (!has_enabled_goal && localStorage.allow_nongoal_timer === 'false') {
      if (!disable_icon_timer) {
        chrome.browserAction.setBadgeText({
          text: '',
          tabId: active_tab.id
        });
      }
    }
    domain_to_session_id = tab_id_to_domain_to_session_id[active_tab.id];
    if (domain_to_session_id == null) {
      if (!disable_icon_timer) {
        chrome.browserAction.setBadgeText({
          text: '',
          tabId: active_tab.id
        });
      }
      return;
    }
    session_id = domain_to_session_id[current_domain];
    if (session_id == null) {
      if (!disable_icon_timer) {
        chrome.browserAction.setBadgeText({
          text: '',
          tabId: active_tab.id
        });
      }
      return;
    }
    seconds_spent_this_session = (await addtokey_dictdict('seconds_on_domain_per_session', current_domain, session_id, 1));
    updates_to_sync.push({
      domain: current_domain,
      seconds: 1
    });
    return addtokey_dictdict('seconds_on_domain_per_day', current_domain, current_day, 1).then(async function(total_seconds){
      var last_time_suggested_goal, have_suggested, is_unproductive, this$ = this;
      if (has_enabled_goal || localStorage.allow_nongoal_timer !== 'false') {
        if (!disable_icon_timer) {
          chrome.browserAction.setBadgeText({
            text: printable_time_spent_short(total_seconds),
            tabId: active_tab.id
          });
        }
      }
      if (goal_suggestion_threshold == null || goal_suggestion_threshold <= 0 || !isFinite(goal_suggestion_threshold)) {
        return;
      }
      if (!has_enabled_goal && total_seconds > goal_suggestion_threshold) {
        last_time_suggested_goal = domain_to_time_last_suggested_goal[current_domain];
        if (last_time_suggested_goal != null && Date.now() - last_time_suggested_goal <= goal_suggestion_threshold * 1000) {
          return;
        }
        domain_to_time_last_suggested_goal[current_domain] = Date.now();
        have_suggested = (await get_have_suggested_domain_as_goal(current_domain));
        if (!have_suggested) {
          is_unproductive = (await is_domain_unproductive(current_domain));
          if (!is_unproductive) {
            return;
          }
          if (suggest_goal_base_code === null) {
            suggest_goal_base_code = (await fetch('frontend_utils/suggest_goal_prompt.js').then(function(it){
              return it.text();
            }));
          }
          log_goal_suggestion({
            'action': 'suggested',
            'goal_type': 'spend_less_time',
            'domain': current_domain
          });
          return chrome.tabs.executeScript(active_tab.id, {
            code: suggest_goal_base_code
          });
        }
      }
    });
  }, 1000);
  /*
  setInterval (->>
    if !prev_browser_focused
      return
    if current_idlestate != 'active'
      return
    active_tab = await get_active_tab_info()
    if not active_tab?
      return
    if active_tab.url.startsWith('chrome://') or active_tab.url.startsWith('chrome-extension://') # ignore time spent on extension pages
      return
    current_domain = url_to_domain(active_tab.url)
    dlog "current domain is #{current_domain}"
    dlog "current tab id is #{active_tab.id}"
    [session_id, is_new_session] = await get_session_id_for_tab_id_and_domain(active_tab.id, current_domain)
    dlog "session_id: #{session_id}"
    seconds_spent = await get_seconds_spent_on_domain_in_session(current_domain, session_id)
    dlog "seconds spent: #{seconds_spent}"
  ), 1000
  */
  gexport_module('background', function(it){
    return eval(it);
  });
  window.uselib = function(libname, callback){
    if (typeof callback === 'function') {
      return SystemJS['import'](libname).then(callback);
    } else if (typeof callback === 'string') {
      return SystemJS['import'](libname).then(function(imported_lib){
        window[callback] = imported_lib;
        return console.log('imported as window.' + callback);
      });
    } else if (typeof libname === 'string') {
      callback = libname.toLowerCase().split('').filter(function(x){
        return 'abcdefghijklmnopqrstuvwxyz0123456789'.indexOf(x) !== -1;
      }).join('');
      return SystemJS['import'](libname).then(function(imported_lib){
        window[callback] = imported_lib;
        return console.log('imported as window.' + callback);
      });
    } else {
      return console.log(['Use uselib() to import jspm libraries.', 'The first argument is the library name (under SystemJS, see jspm)', 'The second argument is the name it should be given (in the \'window\' object)', 'Example of using moment:', '    uselib(\'moment\', \'moment\')', '    window.moment().format()', 'Example of using jquery:', '    uselib(\'jquery\', \'$\')', '    window.$(\'body\').css(\'background-color\', \'black\')', 'Example of using sweetalert2:', '    uselib(\'libs_common/content_script_utils\', \'content_script_utils\')', '    content_script_utils.load_css_file(\'bower_components/sweetalert2/dist/sweetalert2.css\')', '    uselib(\'sweetalert2\', \'swal\')', '    swal(\'hello world\')'].join('\n'));
    }
  };
  ensure_history_utils_data_cached();
  __webpack_require__(/*! libs_backend/require_remote_utils */ "./src/libs_backend/require_remote_utils.ls");
  __webpack_require__(/*! libs_backend/notification_timer */ "./src/libs_backend/notification_timer.js");
  (await get_goal_intervention_info());
  (await get_goals());
  (await get_enabled_goals());
  get_habitlab_uninstall_url = async function(){
    var base64_js, msgpack_lite, compress_and_encode, uninstall_url_base, uninstall_url, uninstall_url_data, set_uninstall_url_if_valid, list_enabled_goals_short;
    base64_js = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
    msgpack_lite = __webpack_require__(/*! msgpack-lite */ "./node_modules/msgpack-lite/lib/browser.js");
    compress_and_encode = function(data){
      return base64_js.fromByteArray(msgpack_lite.encode(data));
    };
    uninstall_url_base = "";
    uninstall_url = uninstall_url_base;
    uninstall_url_data = {};
    uninstall_url_data.v = habitlab_version;
    if (chrome.runtime.id === 'obghclocpdgcekcognpkblghkedcpdgd') {
      uninstall_url_data.r = 0;
    } else if (chrome.runtime.id === 'bleifeoekkfhicamkpadfoclfhfmmina') {
      uninstall_url_data.r = 1;
    } else if (developer_mode) {
      uninstall_url_data.r = 2;
    } else {
      uninstall_url_data.r = 3;
      uninstall_url_data.ri = chrome.runtime.id;
    }
    set_uninstall_url_if_valid = function(){
      var uninstall_url_next;
      uninstall_url_next = uninstall_url_base + compress_and_encode(uninstall_url_data);
      if (uninstall_url_next.length <= 255) {
        uninstall_url = uninstall_url_next;
        return true;
      }
      return false;
    };
    uninstall_url_data.u = (await get_user_id());
    uninstall_url_data.l = localStorage.getItem('allow_logging') === 'true' ? 1 : 0;
    uninstall_url_data.i = (await get_install_id());
    if (!set_uninstall_url_if_valid()) {
      return uninstall_url;
    }
    list_enabled_goals_short = async function(){
      var output, goals, all_goals, k, v, goal_info;
      output = [];
      goals = (await get_enabled_goals());
      all_goals = (await get_goals());
      for (k in goals) {
        v = goals[k];
        if (!v) {
          continue;
        }
        goal_info = all_goals[k];
        output.push(goal_info.sitename_printable);
      }
      return output;
    };
    uninstall_url_data.g = (await list_enabled_goals_short());
    if (!set_uninstall_url_if_valid()) {
      return uninstall_url;
    }
    return uninstall_url;
  };
  decode_habitlab_uninstall_url_data = async function(url){
    var data, base64_js, msgpack_lite, decompress_and_decode;
    data = url.substr(url.indexOf('/bye#') + 5);
    base64_js = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
    msgpack_lite = __webpack_require__(/*! msgpack-lite */ "./node_modules/msgpack-lite/lib/browser.js");
    decompress_and_decode = function(str){
      return msgpack_lite.decode(base64_js.toByteArray(str));
    };
    return decompress_and_decode(data);
  };
  set_habitlab_uninstall_url = async function(){
    var habitlab_uninstall_url;
    habitlab_uninstall_url = (await get_habitlab_uninstall_url());
    return chrome.runtime.setUninstallURL(habitlab_uninstall_url);
  };
  out$.open_habitlab_uninstall_url = open_habitlab_uninstall_url = async function(){
    var uninstall_url;
    return uninstall_url = (await get_habitlab_uninstall_url());
  };
  if (!developer_mode) {
    (await set_habitlab_uninstall_url());
  }
  num_times_restart_failed_due_to_loaded_interventions = 0;
  num_times_restart_failed_due_to_loaded_interventions_active = 0;
  num_times_restart_failed_due_to_habitlab_tab_open = 0;
  num_times_restart_failed_due_to_habitlab_tab_open_active = 0;
  restart_failed_priority_to_counts = [0, 0, 0, 0];
  record_restart_failed = function(priority){
    var restart_habitlab;
    restart_failed_priority_to_counts[priority] += 1;
    restart_habitlab = function(){
      chrome.runtime.reload();
      return chrome.runtime.restart();
    };
    if (priority === 0 && restart_failed_priority_to_counts[0] >= 5000) {
      restart_habitlab();
    }
    if (priority === 1 && restart_failed_priority_to_counts[0] + restart_failed_priority_to_counts[1] >= 1000) {
      restart_habitlab();
    }
    if (priority === 2 && restart_failed_priority_to_counts[0] + restart_failed_priority_to_counts[1] + restart_failed_priority_to_counts[2] >= 250) {
      restart_habitlab();
    }
    if (priority === 3 && restart_failed_priority_to_counts[0] + restart_failed_priority_to_counts[1] + restart_failed_priority_to_counts[2] + restart_failed_priority_to_counts[3] >= 50) {
      restart_habitlab();
    }
  };
  out$.try_to_restart_habitlab_now = try_to_restart_habitlab_now = async function(){
    var open_tabs, active_tabs, i$, len$, tab_info, tab_ids_with_no_interventions, loaded_interventions, this$ = this;
    open_tabs = (await new Promise(function(it){
      return chrome.tabs.query({}, it);
    }));
    active_tabs = open_tabs.filter(function(it){
      return it.active;
    });
    for (i$ = 0, len$ = active_tabs.length; i$ < len$; ++i$) {
      tab_info = active_tabs[i$];
      if (tab_info.url != null && tab_info.url.startsWith(chrome.extension.getURL(''))) {
        return record_restart_failed(0);
      }
    }
    tab_ids_with_no_interventions = {};
    for (i$ = 0, len$ = active_tabs.length; i$ < len$; ++i$) {
      tab_info = active_tabs[i$];
      loaded_interventions = (await list_currently_loaded_interventions_for_tabid(tab_info.id));
      if (loaded_interventions.length > 0) {
        return record_restart_failed(1);
      } else {
        tab_ids_with_no_interventions[tab_info.id] = true;
      }
    }
    for (i$ = 0, len$ = open_tabs.length; i$ < len$; ++i$) {
      tab_info = open_tabs[i$];
      if (tab_ids_with_no_interventions[tab_info.id] != null) {
        continue;
      }
      loaded_interventions = (await list_currently_loaded_interventions_for_tabid(tab_info.id));
      if (loaded_interventions.length > 0) {
        return record_restart_failed(2);
      }
    }
    for (i$ = 0, len$ = open_tabs.length; i$ < len$; ++i$) {
      tab_info = open_tabs[i$];
      if (tab_info.url != null && tab_info.url.startsWith(chrome.extension.getURL(''))) {
        return record_restart_failed(3);
      }
    }
    chrome.runtime.reload();
    chrome.runtime.restart();
  };
  habitlab_restarter_running = false;
  out$.start_trying_to_restart_habitlab = start_trying_to_restart_habitlab = async function(){
    if (habitlab_restarter_running) {
      return;
    }
    habitlab_restarter_running = true;
    for (;;) {
      (await try_to_restart_habitlab_now());
      (await sleep(60000));
    }
  };
  semver = __webpack_require__(/*! semver */ "./node_modules/semver/semver.js");
  check_if_update_available_and_run_update = __webpack_require__(/*! libs_backend/habitlab_update_utils */ "./src/libs_backend/habitlab_update_utils.ls").check_if_update_available_and_run_update;
  __webpack_require__(/*! libs_common/global_exports_post */ "./src/libs_common/global_exports_post.js");
  update_available_version = localStorage.getItem('extension_update_available_version');
  if (update_available_version != null) {
    if (!semver.valid(update_available_version)) {
      localStorage.removeItem('extension_update_available_version');
    }
    if (semver.gte(habitlab_version, update_available_version)) {
      localStorage.removeItem('extension_update_available_version');
    }
  }
  chrome.runtime.onUpdateAvailable.addListener(function(update_details){
    if (semver.valid(update_details.version)) {
      localStorage.setItem('extension_update_available_version', update_details.version);
      return start_trying_to_restart_habitlab();
    }
  });
  if (!developer_mode || localStorage.getItem('check_for_updates_devmode') === 'true') {
    if (localStorage.getItem('allow_logging') !== 'false') {
      run_every_timeperiod(check_if_update_available_and_run_update, 600000);
    }
  }
  url_to_open_on_next_start = localStorage.getItem('habitlab_open_url_on_next_start');
  if (url_to_open_on_next_start != null) {
    localStorage.removeItem('habitlab_open_url_on_next_start');
    chrome.tabs.create({
      url: url_to_open_on_next_start
    });
  }
  setInterval(async function(){
    var d, time_interval;
    if (localStorage.getItem('icon_nudge_active') === 'true') {
      d = new Date();
      time_interval = d.getTime();
      time_interval = time_interval % 10000;
      time_interval = Math.round(time_interval / 100.00);
      time_interval = time_interval % 50;
      if (time_interval < 4) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge9.svg')
        });
      } else if (time_interval === 4) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge8.svg')
        });
      } else if (time_interval === 5) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge7.svg')
        });
      } else if (time_interval === 6) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge6.svg')
        });
      } else if (time_interval === 7) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge5.svg')
        });
      } else if (time_interval === 8) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge4.svg')
        });
      } else if (time_interval === 9) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge3.svg')
        });
      } else if (time_interval === 10) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge2.svg')
        });
      } else if (time_interval === 11) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge1.svg')
        });
      } else if (time_interval <= 15) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge0.svg')
        });
      } else if (time_interval === 16) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge1.svg')
        });
      } else if (time_interval === 17) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge2.svg')
        });
      } else if (time_interval === 18) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge3.svg')
        });
      } else if (time_interval === 19) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge4.svg')
        });
      } else if (time_interval === 20) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge5.svg')
        });
      } else if (time_interval === 21) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge6.svg')
        });
      } else if (time_interval === 22) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge7.svg')
        });
      } else if (time_interval === 23) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge8.svg')
        });
      } else if (time_interval <= 27) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge9.svg')
        });
      } else if (time_interval === 28) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge8.svg')
        });
      } else if (time_interval === 29) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge7.svg')
        });
      } else if (time_interval === 30) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge6.svg')
        });
      } else if (time_interval === 31) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge5.svg')
        });
      } else if (time_interval === 32) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge4.svg')
        });
      } else if (time_interval === 33) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge3.svg')
        });
      } else if (time_interval === 34) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge2.svg')
        });
      } else if (time_interval === 36) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge1.svg')
        });
      } else if (time_interval <= 40) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge0.svg')
        });
      } else if (time_interval === 41) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge1.svg')
        });
      } else if (time_interval === 42) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge2.svg')
        });
      } else if (time_interval === 43) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge3.svg')
        });
      } else if (time_interval === 44) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge4.svg')
        });
      } else if (time_interval === 45) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge5.svg')
        });
      } else if (time_interval === 46) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge6.svg')
        });
      } else if (time_interval === 47) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge7.svg')
        });
      } else if (time_interval === 48) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge8.svg')
        });
      } else if (time_interval >= 49) {
        return chrome.browserAction.setIcon({
          path: chrome.extension.getURL('icons/HSO_icons/icon_nudge9.svg')
        });
      }
    } else if (localStorage.getItem('icon_notif_active') === "true") {
      return chrome.browserAction.setIcon({
        path: chrome.extension.getURL('icons/HSO_icons/icon_notif.svg')
      });
    } else {
      return chrome.browserAction.setIcon({
        path: chrome.extension.getURL('icons/HSO_icons/icon_blue.svg')
      });
    }
  }, 100);
  setInterval(async function(){
    var click_buffer, scroll_buffer, typing_rate_buffer, userid, click_data, scroll_data, typing_data;
    click_buffer = localStorage.getItem("click_rate_buffer");
    scroll_buffer = localStorage.getItem("scroll_rate_buffer");
    typing_rate_buffer = localStorage.getItem("typing_rate_buffer");
    userid = (await get_user_id());
    if (!deepEq$(click_buffer, "[]", '===')) {
      click_data = {};
      click_data["userid"] = userid;
      click_data["click_buffer_start"] = JSON.parse(click_buffer)[0]["click_start"];
      click_data["click_buffer"] = click_buffer;
      post_json("/contextualData/postClickData", click_data);
    }
    if (!deepEq$(scroll_buffer, "[]", '===')) {
      scroll_data = {};
      scroll_data["userid"] = userid;
      scroll_data["scroll_buffer"] = scroll_buffer;
      scroll_data["scroll_buffer_start"] = JSON.parse(scroll_buffer)[0]["scroll_time"];
      post_json("/contextualData/postScrollData", scroll_data);
    }
    if (!deepEq$(typing_rate_buffer, "[]", '===')) {
      typing_data = {};
      typing_data["userid"] = userid;
      typing_data["typing_buffer_start"] = JSON.parse(typing_rate_buffer)[0]["type_start"];
      typing_data["typing_rate_buffer"] = typing_rate_buffer;
      post_json("/contextualData/postTypingData", typing_data);
    }
    localStorage.setItem("click_rate_buffer", "[]");
    localStorage.setItem("scroll_rate_buffer", "[]");
    localStorage.setItem("scroll_rate_dates", "[]");
    return localStorage.setItem("typing_rate_buffer", "[]");
  }, 30 * 60 * 1000);
  setInterval(async function(){
    var random_number, last_notif_time, last_survey_time, hours_since_notif;
    if (localStorage.getItem("first_survey_sent") === "false") {
      random_number = Math.random();
      if (random_number < 0.25) {
        localStorage.setItem("survey_loop_active", "true");
        return localStorage.setItem("first_survey_sent", "true");
      }
    } else if (localStorage.getItem("survey_loop_active") === "false") {
      last_notif_time = localStorage.getItem("last_survey_notif_time");
      last_survey_time = new Date(last_notif_time);
      hours_since_notif = (new Date().getTime() - last_survey_time.getTime()) / (1000 * 60 * 60);
      if (hours_since_notif > 3) {
        localStorage.setItem("survey_loop_active", "true");
        return localStorage.setItem("curr_notifs_start_time", new Date());
      }
    }
  }, 15 * 60 * 1000);
  setInterval(async function(){
    var notif_loops_count, survey_data, notification, close_notification;
    if (localStorage.getItem("survey_loop_active") === "true") {
      localStorage.setItem("last_survey_notif_time", new Date());
      notif_loops_count = localStorage.getItem("notif_loops_count");
      localStorage.setItem("notif_loops_count", parseInt(notif_loops_count) + 1);
      survey_data = {
        "button_text": "Click here to submit survey",
        "url": "notification_questions.html"
      };
      localStorage.setItem("survey_data", JSON.stringify(survey_data));
      localStorage.setItem("icon_notif_active", "true");
      notification = new Notification('Survey Questions Available', {
        icon: chrome.extension.getURL('icons/HSO_icons/icon_blue32.svg'),
        body: "Click here to open survey in browser",
        tag: "surveyNotifID"
      });
      close_notification = notification.close.bind(notification);
      return notification.onclick = function(){
        window.focus();
        chrome.windows.create({
          url: chrome.runtime.getURL('notification_questions.html')
        });
        return close_notification();
      };
    }
  }, 5 * 60 * 1000);
  setInterval(async function(){
    var nudge_length, curr_time, baseline, hours_in_day, random_num;
    nudge_length = (await localStorage.getItem('nudge_time'));
    /* Testing 
    nudge_active = 'true'
    localStorage.setItem('nudge_level', nudge_length)
    */
    curr_time = new Date().getTime();
    baseline = (await localStorage.getItem('last_intervention_time'));
    hours_in_day = 16;
    random_num = Math.floor(Math.random() * hours_in_day) + 1;
    if (random_num <= nudge_length) {
      localStorage.setItem('icon_nudge_active', 'true');
      localStorage.setItem('nudge_level', nudge_length);
      return localStorage.setItem("nudge_set_time", new Date().getTime());
    } else {
      return localStorage.setItem('icon_nudge_active', 'false');
    }
  }, 60 * 60 * 1000);
  setInterval(async function(){
    var curr_time, baseline, timeout_threshold, curr_panel, target_time, nudge_back_time, to_send;
    curr_time = new Date().getTime();
    baseline = (await localStorage.getItem('panel_timer'));
    timeout_threshold = 10;
    curr_panel = localStorage.getItem("current_panel");
    if (deepEq$(curr_panel, "home", '===')) {
      timeout_threshold = 100000;
    } else if (deepEq$(curr_panel, "stress_before", '===')) {
      timeout_threshold = 10;
    } else if (deepEq$(curr_panel, "intervention_loading", '===')) {
      timeout_threshold = 10;
    } else if (deepEq$(curr_panel, "intervention_display", '===')) {
      timeout_threshold = 10;
    } else if (deepEq$(curr_panel, "ask_intervention_done", '===')) {
      timeout_threshold = 10;
    } else if (deepEq$(curr_panel, "stress_after", '===')) {
      timeout_threshold = 10;
    } else if (deepEq$(curr_panel, "intervention_end", '===')) {
      timeout_threshold = 10;
    } else {
      timeout_threshold = 10;
    }
    target_time = parseInt(baseline) + 60000 * timeout_threshold;
    nudge_back_time = parseInt(baseline) + 60000 * (timeout_threshold * 0.5);
    if (curr_time > nudge_back_time && deepEq$(localStorage.getItem('intervention_timed_out'), "false", '===')) {
      chrome.tabs.query({
        active: true,
        lastFocusedWindow: true
      }, function(last_tab){
        var last_active_tab;
        last_active_tab = last_tab[0].url;
        if (last_active_tab !== chrome.extension.getURL('popup.html')) {
          return localStorage.setItem('icon_nudge_active', 'true');
        }
      });
    }
    if (curr_time > target_time && deepEq$(localStorage.getItem('intervention_timed_out'), "false", '===')) {
      localStorage.setItem('intervention_timed_out', 'true');
      to_send = JSON.parse(localStorage.getItem("intervention_data_tosend"));
      to_send["intervention_completed"] = 0;
      to_send["intervention_cancelled"] = 0;
      to_send["intervention_timed_out"] = 1;
      to_send["creative_after"] = -0.1;
      to_send["intervention_cancelled_stage"] = localStorage.getItem("current_panel");
      localStorage.setItem("intervention_data_tosend", JSON.stringify(to_send));
      localStorage.setItem("current_panel", "home");
      post_json("/results/postInterventionResult", JSON.parse((await localStorage.getItem("intervention_data_tosend"))));
      localStorage.setItem("intervention_data_tosend", "{}");
      return localStorage.setItem('icon_nudge_active', 'false');
    }
  }, 60 * 1000);
})();
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) {
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
//# sourceMappingURL=background.ls.map


/***/ }),

/***/ "./src/generated_libs/libs_backend/expose_backend_libs.js":
/*!****************************************************************!*\
  !*** ./src/generated_libs/libs_backend/expose_backend_libs.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {expose_lib} = __webpack_require__(/*! libs_backend/expose_lib */ "./src/libs_backend/expose_lib.ls");
expose_lib('ajax_utils', __webpack_require__(/*! libs_backend/ajax_utils */ "./src/libs_backend/ajax_utils.js"));
expose_lib('cacheget_utils', __webpack_require__(/*! libs_backend/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls"));
expose_lib('db_utils', __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"));
expose_lib('debug_console_utils', __webpack_require__(/*! libs_backend/debug_console_utils */ "./src/libs_backend/debug_console_utils.ls"));
expose_lib('disable_habitlab_utils', __webpack_require__(/*! libs_backend/disable_habitlab_utils */ "./src/libs_backend/disable_habitlab_utils.ls"));
expose_lib('duolingo_utils', __webpack_require__(/*! libs_backend/duolingo_utils */ "./src/libs_backend/duolingo_utils.js"));
expose_lib('favicon_utils', __webpack_require__(/*! libs_backend/favicon_utils */ "./src/libs_backend/favicon_utils.ls"));
expose_lib('fetch_page_utils', __webpack_require__(/*! libs_backend/fetch_page_utils */ "./src/libs_backend/fetch_page_utils.ls"));
expose_lib('gamification_utils', __webpack_require__(/*! libs_backend/gamification_utils */ "./src/libs_backend/gamification_utils.ls"));
expose_lib('goal_progress', __webpack_require__(/*! libs_backend/goal_progress */ "./src/libs_backend/goal_progress.ls"));
expose_lib('goal_utils', __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls"));
expose_lib('goal_vars_backend', __webpack_require__(/*! libs_backend/goal_vars_backend */ "./src/libs_backend/goal_vars_backend.js"));
expose_lib('history_utils', __webpack_require__(/*! libs_backend/history_utils */ "./src/libs_backend/history_utils.ls"));
expose_lib('intervention_feedback_utils', __webpack_require__(/*! libs_backend/intervention_feedback_utils */ "./src/libs_backend/intervention_feedback_utils.js"));
expose_lib('intervention_first_impression_utils_backend', __webpack_require__(/*! libs_backend/intervention_first_impression_utils_backend */ "./src/libs_backend/intervention_first_impression_utils_backend.js"));
expose_lib('intervention_session_vars_backend', __webpack_require__(/*! libs_backend/intervention_session_vars_backend */ "./src/libs_backend/intervention_session_vars_backend.js"));
expose_lib('intervention_utils', __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls"));
expose_lib('intervention_vars_backend', __webpack_require__(/*! libs_backend/intervention_vars_backend */ "./src/libs_backend/intervention_vars_backend.js"));
expose_lib('localization_utils_backend', __webpack_require__(/*! libs_backend/localization_utils_backend */ "./src/libs_backend/localization_utils_backend.js"));
expose_lib('log_utils', __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls"));
expose_lib('notification_utils_backend', __webpack_require__(/*! libs_backend/notification_utils_backend */ "./src/libs_backend/notification_utils_backend.js"));
expose_lib('persistent_storage_utils', __webpack_require__(/*! libs_backend/persistent_storage_utils */ "./src/libs_backend/persistent_storage_utils.js"));
expose_lib('screenshot_utils', __webpack_require__(/*! libs_backend/screenshot_utils */ "./src/libs_backend/screenshot_utils.ls"));
expose_lib('session_utils', __webpack_require__(/*! libs_backend/session_utils */ "./src/libs_backend/session_utils.ls"));
expose_lib('streak_utils', __webpack_require__(/*! libs_backend/streak_utils */ "./src/libs_backend/streak_utils.ls"));
expose_lib('tab_utils', __webpack_require__(/*! libs_backend/tab_utils */ "./src/libs_backend/tab_utils.js"));


/***/ }),

/***/ "./src/goals/duolingo/complete_lesson_each_day/measurement.ls":
/*!********************************************************************!*\
  !*** ./src/goals/duolingo/complete_lesson_each_day/measurement.ls ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var get_measurement_for_days_before_today, ref$, get_duolingo_is_logged_in, get_duolingo_info;
get_measurement_for_days_before_today = __webpack_require__(/*! libs_common/measurement_utils */ "./src/libs_common/measurement_utils.ls").get_measurement_for_days_before_today;
ref$ = __webpack_require__(/*! libs_backend/duolingo_utils */ "./src/libs_backend/duolingo_utils.js"), get_duolingo_is_logged_in = ref$.get_duolingo_is_logged_in, get_duolingo_info = ref$.get_duolingo_info;
module.exports = function(goal_info){
  return async function(days_before_today){
    var lessons_completed, progress, units, message, reward;
    lessons_completed = (await get_measurement_for_days_before_today('duolingo_lessons_completed', days_before_today));
    progress = lessons_completed;
    units = "lessons";
    message = progress + " " + units;
    reward = Math.tanh(lessons_completed);
    return {
      progress: progress,
      units: units,
      message: message,
      reward: reward
    };
  };
};
//# sourceMappingURL=measurement.ls.map


/***/ }),

/***/ "./src/goals/progress_measurement.ls":
/*!*******************************************!*\
  !*** ./src/goals/progress_measurement.ls ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, get_seconds_spent_on_domain_days_before_today, get_visits_to_domain_days_before_today, printable_time_spent, time_spent_on_domain, visits_to_domain, whether_visited_domain, always_zero_progress, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/time_spent_utils */ "./src/libs_common/time_spent_utils.ls"), get_seconds_spent_on_domain_days_before_today = ref$.get_seconds_spent_on_domain_days_before_today, get_visits_to_domain_days_before_today = ref$.get_visits_to_domain_days_before_today;
printable_time_spent = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").printable_time_spent;
out$.time_spent_on_domain = time_spent_on_domain = function(goal_info){
  var domain, is_positive;
  domain = goal_info.domain, is_positive = goal_info.is_positive;
  return async function(days_before_today){
    var seconds_spent, progress, units, message, reward;
    seconds_spent = (await get_seconds_spent_on_domain_days_before_today(domain, days_before_today));
    progress = seconds_spent / 60;
    units = "minutes";
    message = printable_time_spent(seconds_spent);
    if (is_positive) {
      reward = Math.tanh(seconds_spent / 3600);
    } else {
      reward = 1.0 - Math.tanh(seconds_spent / 3600);
    }
    return {
      progress: progress,
      units: units,
      message: message,
      reward: reward
    };
  };
};
out$.visits_to_domain = visits_to_domain = function(goal_info){
  var domain, is_positive;
  domain = goal_info.domain, is_positive = goal_info.is_positive;
  return async function(days_before_today){
    var visits, progress, units, message, reward;
    visits = (await get_visits_to_domain_days_before_today(domain, days_before_today));
    progress = visits;
    units = "visits";
    message = visits + " visits";
    if (is_positive) {
      reward = Math.tanh(visits);
    } else {
      reward = 1 - Math.tanh(visits);
    }
    return {
      progress: progress,
      units: units,
      message: message,
      reward: reward
    };
  };
};
out$.whether_visited_domain = whether_visited_domain = function(goal_info){
  var domain, is_positive;
  domain = goal_info.domain, is_positive = goal_info.is_positive;
  return async function(days_before_today){
    var visits, progress, units, message, reward;
    visits = (await get_visits_to_domain_days_before_today(domain, days_before_today));
    progress = visits > 0 ? 1 : 0;
    units = "visits";
    message = visits > 0 ? "visited" : "not yet visited";
    if (is_positive) {
      reward = progress;
    } else {
      reward = 1 - progress;
    }
    return {
      progress: progress,
      units: units,
      message: message,
      reward: reward
    };
  };
};
out$.always_zero_progress = always_zero_progress = function(goal_info){
  return async function(days_before_today){
    var progress, units, message, reward;
    progress = 0;
    units = "minutes";
    message = "0 seconds";
    reward = 0;
    return {
      progress: progress,
      units: units,
      message: message,
      reward: reward
    };
  };
};
//# sourceMappingURL=progress_measurement.ls.map


/***/ }),

/***/ "./src/goals/progress_measurement_generated.ls":
/*!*****************************************************!*\
  !*** ./src/goals/progress_measurement_generated.ls ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  'duolingo/complete_lesson_each_day': __webpack_require__(/*! goals/duolingo/complete_lesson_each_day/measurement */ "./src/goals/duolingo/complete_lesson_each_day/measurement.ls")
};
//# sourceMappingURL=progress_measurement_generated.ls.map


/***/ }),

/***/ "./src/libs_backend/abtest_utils.ls":
/*!******************************************!*\
  !*** ./src/libs_backend/abtest_utils.ls ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, setvar_experiment, getvar_experiment, enabledisable_interventions_based_on_difficulty, send_feature_disabled, abtest_list, abtest_funcs, abtest_conditions, nondefault_abtest_list, blocking_abtest_list, blocking_abtest_set, nondefault_abtest_set, is_blocking_abtest, is_nondefault_abtest, get_available_abtest_conditions, get_abtest_list, get_abtest_set, get_assigned_abtest_conditions, add_abtest, set_abtest, run_abtest, setup_abtest_newuser, setup_abtest_olduser, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), setvar_experiment = ref$.setvar_experiment, getvar_experiment = ref$.getvar_experiment;
enabledisable_interventions_based_on_difficulty = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls").enabledisable_interventions_based_on_difficulty;
send_feature_disabled = __webpack_require__(/*! libs_backend/logging_enabled_utils */ "./src/libs_backend/logging_enabled_utils.ls").send_feature_disabled;
abtest_list = [];
abtest_funcs = {};
abtest_conditions = {};
nondefault_abtest_list = ['internal_special_user', 'difficulty_selection_screen', 'frequency_of_choose_difficulty'];
blocking_abtest_list = ['difficulty_selection_screen_and_choose_difficulty_frequency', 'difficulty_selection_screen'];
blocking_abtest_set = new Set(blocking_abtest_list);
nondefault_abtest_set = new Set(nondefault_abtest_list);
is_blocking_abtest = function(name){
  return blocking_abtest_set.has(name);
};
is_nondefault_abtest = function(name){
  return nondefault_abtest_set.has(name);
};
out$.get_available_abtest_conditions = get_available_abtest_conditions = function(name){
  return abtest_conditions[name];
};
out$.get_abtest_list = get_abtest_list = function(){
  return abtest_list;
};
out$.get_abtest_set = get_abtest_set = function(){
  return new Set(abtest_list);
};
out$.get_assigned_abtest_conditions = get_assigned_abtest_conditions = async function(){
  var output, abtest_list, i$, len$, abtest, experiment_val;
  output = {};
  abtest_list = get_abtest_list();
  for (i$ = 0, len$ = abtest_list.length; i$ < len$; ++i$) {
    abtest = abtest_list[i$];
    experiment_val = (await getvar_experiment(abtest));
    if (experiment_val == null) {
      continue;
    }
    output[abtest] = experiment_val;
  }
  return output;
};
out$.add_abtest = add_abtest = function(name, conditions, func){
  abtest_list.push(name);
  abtest_funcs[name] = func;
  abtest_conditions[name] = conditions;
};
out$.set_abtest = set_abtest = async function(name, condition, conditions){
  var abtest_func;
  abtest_func = abtest_funcs[name];
  if (is_blocking_abtest(name)) {
    (await abtest_func(condition));
    if (conditions != null) {
      (await setvar_experiment(name, condition, conditions));
    } else {
      (await setvar_experiment(name, condition));
    }
  } else {
    abtest_func(condition);
    if (conditions != null) {
      setvar_experiment(name, condition, conditions);
    } else {
      setvar_experiment(name, condition);
    }
  }
};
out$.run_abtest = run_abtest = async function(name){
  var conditions, condition;
  conditions = abtest_conditions[name];
  condition = conditions[Math.floor(Math.random() * conditions.length)];
  (await set_abtest(name, condition, conditions));
};
add_abtest('internal_special_user', ['off'], async function(chosen_algorithm){
  localStorage.setItem('internal_special_user', chosen_algorithm);
});
add_abtest('selection_algorithm_for_visit', ['one_random_intervention_per_enabled_goal'], async function(chosen_algorithm){
  localStorage.setItem('selection_algorithm_for_visit', chosen_algorithm);
});
add_abtest('intervention_firstimpression_notice', ['power'], async function(chosen_algorithm){
  localStorage.setItem('intervention_firstimpression_notice', chosen_algorithm);
});
add_abtest('choose_difficulty_interface', ['this_intervention_toast_v5'], async function(chosen_algorithm){
  localStorage.setItem('choose_difficulty_interface', chosen_algorithm);
});
add_abtest('difficulty_selection_screen_and_choose_difficulty_frequency', ['survey', 'nodefault_forcedchoice_userchoice', 'survey_nochoice_nothing', 'survey_nochoice_easy', 'survey_nochoice_medium', 'survey_nochoice_hard'], async function(chosen_algorithm){
  var conditions;
  localStorage.setItem('difficulty_selection_screen_and_choose_difficulty_frequency', chosen_algorithm);
  conditions = ['nodefault_forcedchoice', 'nodefault_forcedchoice_userchoice', 'survey_nochoice_nothing', 'survey_nochoice_easy', 'survey_nochoice_medium', 'survey_nochoice_hard'];
  if (chosen_algorithm === 'survey') {
    (await set_abtest('frequency_of_choose_difficulty', '0.0', ['0.0', 'survey']));
    (await set_abtest('difficulty_selection_screen', 'nodefault_forcedchoice', conditions));
  } else {
    (await set_abtest('frequency_of_choose_difficulty', '0.0', ['0.0', 'survey']));
    (await set_abtest('difficulty_selection_screen', chosen_algorithm, conditions));
  }
});
add_abtest('frequency_of_choose_difficulty', ['0.0', 'survey'], async function(chosen_algorithm){
  localStorage.setItem('frequency_of_choose_difficulty', chosen_algorithm);
});
add_abtest('difficulty_selection_screen', ['nodefault_forcedchoice', 'nodefault_forcedchoice_userchoice', 'survey_nochoice_nothing', 'survey_nochoice_easy', 'survey_nochoice_medium', 'survey_nochoice_hard'], async function(chosen_algorithm){
  if (chosen_algorithm === 'survey_nochoice_nothing') {
    localStorage.setItem('difficulty_selector_survey', true);
    setvar_experiment('user_chosen_difficulty', 'nothing');
    (await enabledisable_interventions_based_on_difficulty('nothing'));
  }
  if (chosen_algorithm === 'survey_nochoice_easy') {
    localStorage.setItem('difficulty_selector_survey', true);
    setvar_experiment('user_chosen_difficulty', 'easy');
    (await enabledisable_interventions_based_on_difficulty('easy'));
  }
  if (chosen_algorithm === 'survey_nochoice_medium') {
    localStorage.setItem('difficulty_selector_survey', true);
    setvar_experiment('user_chosen_difficulty', 'medium');
    (await enabledisable_interventions_based_on_difficulty('medium'));
  }
  if (chosen_algorithm === 'survey_nochoice_hard') {
    localStorage.setItem('difficulty_selector_survey', true);
    setvar_experiment('user_chosen_difficulty', 'hard');
    (await enabledisable_interventions_based_on_difficulty('hard'));
  }
  if (chosen_algorithm === 'nochoice_nothing') {
    localStorage.setItem('difficulty_selector_disabled', true);
    localStorage.setItem('difficulty_selector_survey', false);
    localStorage.user_chosen_difficulty = 'nothing';
    setvar_experiment('user_chosen_difficulty', 'nothing');
    (await enabledisable_interventions_based_on_difficulty('nothing'));
  }
  if (chosen_algorithm === 'nochoice_easy') {
    localStorage.setItem('difficulty_selector_disabled', true);
    localStorage.setItem('difficulty_selector_survey', false);
    localStorage.user_chosen_difficulty = 'easy';
    setvar_experiment('user_chosen_difficulty', 'easy');
    (await enabledisable_interventions_based_on_difficulty('easy'));
  }
  if (chosen_algorithm === 'nochoice_medium') {
    localStorage.setItem('difficulty_selector_disabled', true);
    localStorage.setItem('difficulty_selector_survey', false);
    localStorage.user_chosen_difficulty = 'medium';
    setvar_experiment('user_chosen_difficulty', 'medium');
    (await enabledisable_interventions_based_on_difficulty('medium'));
  }
  if (chosen_algorithm === 'nochoice_hard') {
    localStorage.setItem('difficulty_selector_disabled', true);
    localStorage.setItem('difficulty_selector_survey', false);
    localStorage.user_chosen_difficulty = 'hard';
    setvar_experiment('user_chosen_difficulty', 'hard');
    (await enabledisable_interventions_based_on_difficulty('hard'));
  }
  if (chosen_algorithm === 'nodefault_optional') {
    localStorage.setItem('difficulty_selector_survey', false);
  }
  if (chosen_algorithm === 'none') {
    localStorage.setItem('difficulty_selector_disabled', true);
    localStorage.setItem('difficulty_selector_survey', false);
  }
  if (chosen_algorithm === 'nodefault_forcedchoice') {
    localStorage.setItem('difficulty_selector_forcedchoice', true);
    localStorage.setItem('difficulty_selector_survey', false);
  }
  if (chosen_algorithm === 'nodefault_forcedchoice_userchoice') {
    localStorage.setItem('difficulty_selector_forcedchoice', true);
    localStorage.setItem('difficulty_selector_survey', false);
    localStorage.setItem('difficulty_selector_userchoice', true);
  }
  localStorage.setItem('difficulty_selection_screen', chosen_algorithm);
});
add_abtest('intervention_suggestion_optout', ['off'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('suggestion_mode_optout', false);
  } else {
    localStorage.setItem('suggestion_mode_optout', true);
  }
});
add_abtest('intervention_suggestion_algorithm', ['off'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('suggest_interventions', false);
  } else {
    localStorage.setItem('suggest_interventions', true);
  }
  localStorage.setItem('intervention_suggestion_algorithm', chosen_algorithm);
});
add_abtest('goal_suggestion_threshold', [0], async function(chosen_algorithm){
  localStorage.setItem('goal_suggestion_threshold', chosen_algorithm);
});
add_abtest('onboarding_ideavoting_abtest', ['on'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('idea_voting_disabled', true);
  } else {
    localStorage.setItem('idea_voting_disabled', false);
  }
  localStorage.setItem('onboarding_ideavoting_abtest', chosen_algorithm);
});
add_abtest('daily_goal_reminders_abtest', ['off'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('allow_daily_goal_notifications', false);
    send_feature_disabled({
      page: 'background',
      feature: 'allow_daily_goal_notifications',
      manual: false,
      reason: 'daily_goal_reminders_abtest'
    });
  }
});
add_abtest('reward_gifs_abtest', ['off'], async function(chosen_algorithm){
  var algorithms;
  if (chosen_algorithm == null) {
    algorithms = ['off'];
    chosen_algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
  }
  if (chosen_algorithm === 'off') {
    localStorage.setItem('allow_reward_gifs', false);
    send_feature_disabled({
      page: 'background',
      feature: 'allow_reward_gifs',
      manual: false,
      reason: 'reward_gifs_abtest'
    });
  }
});
add_abtest('intervention_intensity_polling_abtest', ['off'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('intervention_intensity_polling', false);
    send_feature_disabled({
      page: 'background',
      feature: 'intervention_intensity_polling',
      manual: false,
      reason: 'intervention_intensity_polling_abtest'
    });
  } else {
    localStorage.setItem('intervention_intensity_polling', true);
  }
  setvar_experiment('intervention_intensity_polling_abtest', chosen_algorithm);
});
add_abtest('allow_nongoal_timer', ['off'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('allow_nongoal_timer', false);
    send_feature_disabled({
      page: 'background',
      feature: 'allow_nongoal_timer',
      manual: false,
      reason: 'nongoal_timer_abtest'
    });
  }
});
add_abtest('idea_contribution_money', ['on'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('idea_contribution_money', false);
  } else {
    localStorage.setItem('idea_contribution_money', true);
  }
});
add_abtest('ideavoting_submit_prompt', ['on'], async function(chosen_algorithm){
  if (chosen_algorithm === 'off') {
    localStorage.setItem('ideavoting_submit_prompt', true);
  } else {
    localStorage.setItem('ideavoting_submit_prompt', false);
  }
});
out$.setup_abtest_newuser = setup_abtest_newuser = async function(){
  var i$, ref$, len$, abtest_name;
  for (i$ = 0, len$ = (ref$ = abtest_list).length; i$ < len$; ++i$) {
    abtest_name = ref$[i$];
    if (is_nondefault_abtest(abtest_name)) {
      continue;
    }
    (await run_abtest(abtest_name));
  }
};
out$.setup_abtest_olduser = setup_abtest_olduser = async function(){
  if (localStorage.intervention_suggestion_algorithm == null) {
    (await run_abtest('intervention_suggestion_algorithm'));
  }
  if (localStorage.goal_suggestion_threshold == null) {
    (await run_abtest('goal_suggestion_threshold'));
  }
};
gexport_module('abtest_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=abtest_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/ajax_utils.js":
/*!****************************************!*\
  !*** ./src/libs_backend/ajax_utils.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
$.ajax {
  type: 'POST'
  url: 'https://habitlab.herokuapp.com/add_install'
  dataType: 'json'
  contentType: 'application/json'
  data: JSON.stringify(install_data)
}
*/


// Select either staging or macdev
var unstuck_server_url = 'https://ldad31f131.execute-api.us-east-1.amazonaws.com/prod';
var unstuck_server_api_key = 'T6xCnpXzJB4i7KEe75OJO4ZPMD6hgxHL2WJ1wngG'; //prod key

//var unstuck_server_url = 'https://b3mu8xjlq0.execute-api.us-east-1.amazonaws.com/staging';
//var unstuck_server_api_key = 'bmK1tngfcP4YCHOKQT6PfajJPzPT9hDm2Qn6WFRk'; //staging key

//var unstuck_server_url = 'https://9ti4a14evc.execute-api.us-east-1.amazonaws.com/mac-dev';
//var unstuck_server_api_key = 'yIix53CeIP3VugNdV8YnXaHFTA0f3Ylx8ve63eKd'; //mac-dev key

function post_json(path, data) {
  return new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest()
    xhr.open('POST', unstuck_server_url + path)
    xhr.setRequestHeader('Content-Type', 'application/json')
    xhr.setRequestHeader("x-api-key", unstuck_server_api_key)
    // if (api_key) {
    //   xhr.setRequestHeader('x-api-key', api_key)
    // } else {
    //   console.error('Fatal Error: API key is missing.');
    //   process.exit(1); // Exit the process with an error code
    // }
    xhr.onload = function() {
      if (xhr.status == 200) {
        resolve(JSON.parse(xhr.responseText))
      } else {
        reject('error in post_json: ' + xhr.status)
      }
    }
    xhr.onerror = function() {
      reject(xhr)
    }
    xhr.send(JSON.stringify(data))
  })
}

function put_json(path, data) {
  return new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest()
    xhr.open('PUT', unstuck_server_url + path)
    xhr.setRequestHeader('Content-Type', 'application/json')
    xhr.setRequestHeader("x-api-key", unstuck_server_api_key)
    // if (api_key) {
    //   xhr.setRequestHeader('x-api-key', api_key)
    // } else {
    //   console.error('Fatal Error: API key is missing.');
    //   process.exit(1); // Exit the process with an error code
    // }
    xhr.onload = function() {
      if (xhr.status == 200) {
        resolve(JSON.parse(xhr.responseText))
      } else {
        reject('error in put_json: ' + xhr.status)
      }
    }
    xhr.onerror = function() {
      reject(xhr)
    }
    xhr.send(JSON.stringify(data))
  })
}

function get_json(path, params) {
  return new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest()
    xhr.open('GET', unstuck_server_url + path +"?"+params, true)
    xhr.setRequestHeader("x-api-key", unstuck_server_api_key)
    // if (api_key) {
    //   xhr.setRequestHeader('x-api-key', api_key)
    // } else {
    //   console.error('Fatal Error: API key is missing.');
    //   process.exit(1); // Exit the process with an error code
    // }
    xhr.onload = function() {
      if (xhr.status == 200) {
        resolve(xhr.responseText)
      } else {
        reject('error in get_json: ' + xhr.status)
      }
    }
    xhr.onerror = function() {
      reject(xhr)
    }
    xhr.send(null)
  })
}

function get_json_using_post(path, params_json) {
  return new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest()

    xhr.open('POST', unstuck_server_url + path, true)
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.setRequestHeader("x-api-key", unstuck_server_api_key)
    // if (api_key) {
    //   xhr.setRequestHeader('x-api-key', api_key)
    // } else {
    //   console.error('Fatal Error: API key is missing.');
    //   process.exit(1); // Exit the process with an error code
    // }
    xhr.onload = function() {
      if (xhr.status == 200) {
        resolve(xhr.responseText)
      } else {
        reject('error in get_json_using_post: ' + xhr.status)
      }
    }
    xhr.onerror = function() {
      reject(xhr)
    }
    xhr.send(JSON.stringify(params_json))
  })
}


module.exports = {
  post_json,
  get_json,
  get_json_using_post,
  put_json
}


/***/ }),

/***/ "./src/libs_backend/background_common.ls":
/*!***********************************************!*\
  !*** ./src/libs_backend/background_common.ls ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, as_array, memoizeSingleAsync, generate_random_id, chrome_tabs_sendmessage, chrome_storage_sync, ref1$, cached_user_id, get_user_id, cached_install_id, get_install_id, get_user_id_from_history, clear_user_id_from_history, set_user_id_in_history, get_user_id_real, cached_user_secret, get_user_secret, get_user_secret_real, send_message_to_active_tab, send_message_to_all_active_tabs, eval_content_script, eval_content_script_for_active_tab, eval_content_script_debug_for_active_tab, eval_content_script_debug_for_tabid, eval_content_script_for_tabid, list_currently_loaded_interventions, list_currently_loaded_interventions_for_tabid, is_tab_still_open, open_debug_page_for_tab_id, send_message_to_tabid, disable_interventions_for_tabid, disable_interventions_in_active_tab, disable_interventions_in_all_tabs, get_active_tab_info, get_all_tabs_info, get_active_tab_url, get_all_tabs_urls, get_active_tab_id, remote_file_exists, extension_url_exists, fetch_remote_json_cache, fetch_remote_json, list_files_in_path_for_github_repo, list_files_in_libs_common, list_files_in_libs_backend, list_files_in_libs_frontend, list_jspm_packages, list_jspm_libraries_as_markdown, chrome_get_token, printcb, printcb_json, jspm_eval, printfunc, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
as_array = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls").as_array;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
generate_random_id = __webpack_require__(/*! libs_common/generate_random_id */ "./src/libs_common/generate_random_id.ls").generate_random_id;
chrome_tabs_sendmessage = function(tab_id, data, options){
  if (options == null) {
    options = {};
  }
  return new Promise(function(resolve, reject){
    return chrome.tabs.sendMessage(tab_id, data, options, function(result){
      resolve(result);
      return true;
    });
  });
};
chrome_storage_sync = (ref$ = (ref1$ = chrome.storage) != null ? ref1$.sync : void 8) != null
  ? ref$
  : (ref$ = chrome.storage) != null ? ref$.local : void 8;
cached_user_id = null;
out$.get_user_id = get_user_id = memoizeSingleAsync(async function(){
  var user_id;
  user_id = (await get_user_id_real());
  if (user_id.length === 24) {
    return user_id;
  } else {
    cached_user_id = null;
    localStorage.removeItem('userid');
    (await new Promise(function(it){
      return chrome_storage_sync.remove('userid', it);
    }));
    return (await get_user_id_real());
  }
});
cached_install_id = null;
out$.get_install_id = get_install_id = memoizeSingleAsync(async function(){
  var install_id;
  if (cached_install_id != null) {
    return cached_install_id;
  }
  install_id = localStorage.getItem('install_id');
  if (install_id != null) {
    cached_install_id = install_id;
    return install_id;
  }
  install_id = generate_random_id();
  cached_install_id = install_id;
  localStorage.setItem('install_id', install_id);
  return install_id;
});
out$.get_user_id_from_history = get_user_id_from_history = async function(){
  var history_search_results, i$, len$, search_result, data_text, j$, ref$, len1$, data_line, data_line_entries, key, value;
  history_search_results = (await new Promise(function(it){
    return chrome.history.search({
      text: 'https://habitlab.stanford.edu',
      startTime: 0
    }, it);
  }));
  for (i$ = 0, len$ = history_search_results.length; i$ < len$; ++i$) {
    search_result = history_search_results[i$];
    if (search_result.url.startsWith('https://habitlab.stanford.edu/#hashdata|')) {
      data_text = search_result.url.replace('https://habitlab.stanford.edu/#hashdata|', '');
      for (j$ = 0, len1$ = (ref$ = data_text.split('|')).length; j$ < len1$; ++j$) {
        data_line = ref$[j$];
        if (data_line.includes('=')) {
          data_line_entries = data_line.split('=');
          key = data_line_entries[0];
          value = data_line_entries[1];
          if (key === 'userid') {
            return value;
          }
        }
      }
    }
  }
  return null;
};
out$.clear_user_id_from_history = clear_user_id_from_history = async function(){
  var history_search_results, i$, len$, search_result, results$ = [];
  history_search_results = (await new Promise(function(it){
    return chrome.history.search({
      text: 'https://habitlab.stanford.edu',
      startTime: 0
    }, it);
  }));
  for (i$ = 0, len$ = history_search_results.length; i$ < len$; ++i$) {
    search_result = history_search_results[i$];
    if (search_result.url.startsWith('https://habitlab.stanford.edu/#hashdata|')) {
      results$.push((await new Promise(fn$)));
    }
  }
  return results$;
  function fn$(it){
    return chrome.history.deleteUrl({
      url: search_result.url
    }, it);
  }
};
out$.set_user_id_in_history = set_user_id_in_history = async function(userid){
  return (await new Promise(function(it){
    return chrome.history.addUrl({
      url: 'https://habitlab.stanford.edu/#hashdata|source=extension|userid=' + userid
    }, it);
  }));
};
get_user_id_real = async function(){
  var userid, items;
  if (cached_user_id != null) {
    return cached_user_id;
  }
  userid = localStorage.getItem('userid');
  if (userid != null) {
    cached_user_id = userid;
    return userid;
  }
  items = (await new Promise(function(it){
    return chrome_storage_sync.get('userid', it);
  }));
  userid = items != null ? items.userid : void 8;
  if (userid != null) {
    cached_user_id = userid;
    localStorage.setItem('userid', userid);
    return userid;
  }
  userid = (await get_user_id_from_history());
  if (userid == null) {
    userid = generate_random_id();
    (await set_user_id_in_history(userid));
  }
  cached_user_id = userid;
  localStorage.setItem('userid', userid);
  (await new Promise(function(it){
    return chrome_storage_sync.set({
      userid: userid
    }, it);
  }));
  return userid;
};
cached_user_secret = null;
out$.get_user_secret = get_user_secret = memoizeSingleAsync(async function(){
  var user_secret;
  user_secret = (await get_user_secret_real());
  if (user_secret.length === 24) {
    return user_secret;
  } else {
    cached_user_secret = null;
    localStorage.removeItem('user_secret');
    (await new Promise(function(it){
      return chrome_storage_sync.remove('user_secret', it);
    }));
    return (await get_user_secret_real());
  }
});
get_user_secret_real = async function(){
  var user_secret, items;
  if (cached_user_secret != null) {
    return cached_user_secret;
  }
  user_secret = localStorage.getItem('user_secret');
  if (user_secret != null) {
    cached_user_secret = user_secret;
    return user_secret;
  }
  items = (await new Promise(function(it){
    return chrome_storage_sync.get('user_secret', it);
  }));
  user_secret = items.user_secret;
  if (user_secret != null) {
    cached_user_secret = user_secret;
    localStorage.setItem('user_secret', user_secret);
    return user_secret;
  }
  user_secret = generate_random_id();
  cached_user_secret = user_secret;
  localStorage.setItem('user_secret', user_secret);
  (await new Promise(function(it){
    return chrome_storage_sync.set({
      user_secret: user_secret
    }, it);
  }));
  return user_secret;
};
out$.send_message_to_active_tab = send_message_to_active_tab = async function(type, data){
  var tabs;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      active: true,
      lastFocusedWindow: true
    }, it);
  }));
  if (tabs.length === 0) {
    return;
  }
  return (await chrome_tabs_sendmessage(tabs[0].id, {
    type: type,
    data: data
  }));
};
send_message_to_all_active_tabs = async function(type, data){
  var tabs, outputs, i$, len$, tab, result;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      active: true
    }, it);
  }));
  if (tabs.length === 0) {
    return;
  }
  outputs = [];
  for (i$ = 0, len$ = tabs.length; i$ < len$; ++i$) {
    tab = tabs[i$];
    result = (await chrome_tabs_sendmessage(tab.id, {
      type: type,
      data: data
    }));
    outputs.push(result);
  }
  return outputs;
};
out$.eval_content_script = eval_content_script = async function(script){
  var results, i$, len$, result;
  results = (await send_message_to_all_active_tabs('eval_content_script', script));
  for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
    result = results[i$];
    console.log(result);
  }
  return result;
};
out$.eval_content_script_for_active_tab = eval_content_script_for_active_tab = async function(script){
  return (await send_message_to_active_tab('eval_content_script', script));
};
out$.eval_content_script_debug_for_active_tab = eval_content_script_debug_for_active_tab = async function(script){
  return (await send_message_to_active_tab('eval_content_script_debug', script));
};
out$.eval_content_script_debug_for_tabid = eval_content_script_debug_for_tabid = async function(tabid, script){
  return (await chrome_tabs_sendmessage(tabid, {
    type: 'eval_content_script_debug',
    data: script
  }));
};
out$.eval_content_script_for_tabid = eval_content_script_for_tabid = async function(tabid, script){
  return (await chrome_tabs_sendmessage(tabid, {
    type: 'eval_content_script',
    data: script
  }));
};
out$.list_currently_loaded_interventions = list_currently_loaded_interventions = async function(){
  var tab, loaded_interventions;
  tab = (await get_active_tab_info());
  loaded_interventions = (await eval_content_script_for_tabid(tab.id, 'window.loaded_interventions'));
  return as_array(loaded_interventions);
};
out$.list_currently_loaded_interventions_for_tabid = list_currently_loaded_interventions_for_tabid = async function(tab_id){
  var loaded_interventions;
  loaded_interventions = (await eval_content_script_for_tabid(tab_id, 'window.loaded_interventions'));
  return as_array(loaded_interventions);
};
out$.is_tab_still_open = is_tab_still_open = async function(tab_id){
  var tabs, i$, len$, tab;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({}, it);
  }));
  for (i$ = 0, len$ = tabs.length; i$ < len$; ++i$) {
    tab = tabs[i$];
    if (tab.id === tab_id) {
      return true;
    }
  }
  return false;
};
out$.open_debug_page_for_tab_id = open_debug_page_for_tab_id = async function(tab_id){
  var debug_page_url, popup_windows, i$, len$, popup_window, window_info, j$, ref$, len1$, tab;
  debug_page_url = chrome.runtime.getURL('index.html?tag=terminal-view&autoload=true&ispopup=true&tabid=' + tab_id);
  popup_windows = (await new Promise(function(it){
    return chrome.windows.getAll({
      windowTypes: ['popup']
    }, it);
  }));
  for (i$ = 0, len$ = popup_windows.length; i$ < len$; ++i$) {
    popup_window = popup_windows[i$];
    window_info = (await new Promise(fn$));
    for (j$ = 0, len1$ = (ref$ = window_info.tabs).length; j$ < len1$; ++j$) {
      tab = ref$[j$];
      if (tab.url === debug_page_url) {
        (await new Promise(fn1$));
        return (await new Promise(fn2$));
      }
    }
  }
  return (await new Promise(function(it){
    return chrome.windows.create({
      url: debug_page_url,
      type: 'popup',
      width: 566,
      height: 422
    }, it);
  }));
  function fn$(it){
    return chrome.windows.get(popup_window.id, {
      populate: true
    }, it);
  }
  function fn1$(it){
    return chrome.tabs.update(tab.id, {
      active: true
    }, it);
  }
  function fn2$(it){
    return chrome.windows.update(popup_window.id, {
      focused: true
    }, it);
  }
};
out$.send_message_to_tabid = send_message_to_tabid = async function(tabid, type, data){
  return chrome_tabs_sendmessage(tabid, {
    type: type,
    data: data
  });
};
out$.disable_interventions_for_tabid = disable_interventions_for_tabid = async function(tabid){
  return (await eval_content_script_for_tabid(tabid, "document.body.dispatchEvent(new CustomEvent('disable_intervention'))"));
};
out$.disable_interventions_in_active_tab = disable_interventions_in_active_tab = async function(){
  var tab;
  tab = (await get_active_tab_info());
  return (await disable_interventions_for_tabid(tab.id));
};
out$.disable_interventions_in_all_tabs = disable_interventions_in_all_tabs = async function(){
  var tabs, tab;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({}, it);
  }));
  (await Promise.all((await (async function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = tabs).length; i$ < len$; ++i$) {
      tab = ref$[i$];
      results$.push(disable_interventions_for_tabid(tab.id));
    }
    return results$;
  }()))));
};
out$.get_active_tab_info = get_active_tab_info = async function(){
  var tabs, last_focused_window_info;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      active: true,
      lastFocusedWindow: true
    }, it);
  }));
  if (tabs.length > 0) {
    return tabs[0];
  }
  last_focused_window_info = (await new Promise(function(it){
    return chrome.windows.getLastFocused(it);
  }));
  if ((last_focused_window_info != null ? last_focused_window_info.id : void 8) == null) {
    return;
  }
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      active: true,
      windowId: last_focused_window_info.id
    }, it);
  }));
  if (tabs.length > 0) {
    return tabs[0];
  }
};
out$.get_all_tabs_info = get_all_tabs_info = async function(){
  var tabs;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      currentWindow: true
    }, it);
  }));
  return tabs;
};
out$.get_active_tab_url = get_active_tab_url = async function(){
  var active_tab_info;
  active_tab_info = (await get_active_tab_info());
  return active_tab_info.url;
};
out$.get_all_tabs_urls = get_all_tabs_urls = async function(){
  var tabs, tabs_urls, i$, len$, tab;
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({
      currentWindow: true
    }, it);
  }));
  tabs_urls = [];
  for (i$ = 0, len$ = tabs.length; i$ < len$; ++i$) {
    tab = tabs[i$];
    tabs_urls.push(tab.url);
  }
  return tabs_urls;
};
out$.get_active_tab_id = get_active_tab_id = async function(){
  var active_tab_info;
  active_tab_info = (await get_active_tab_info());
  return active_tab_info.id;
};
remote_file_exists = async function(remote_file_path){
  var request, contents, e;
  try {
    request = (await fetch(remote_file_path));
    contents = (await request.text());
    return true;
  } catch (e$) {
    e = e$;
    return false;
  }
};
extension_url_exists = async function(extension_file_path){
  return (await remote_file_exists(chrome.extension.getURL(extension_file_path)));
};
fetch_remote_json_cache = {};
fetch_remote_json = async function(path){
  var request, tree_text, tree_contents;
  if (fetch_remote_json_cache[path] != null) {
    return fetch_remote_json_cache[path];
  }
  request = (await fetch(path));
  tree_text = (await request.text());
  tree_contents = JSON.parse(tree_text);
  fetch_remote_json_cache[path] = tree_contents;
  return tree_contents;
};
list_files_in_path_for_github_repo = async function(path){
  var path_parts, res$, i$, ref$, len$, x, current_path, path_part, tree_contents, matching_parts, j$, len1$;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = path.split('/')).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x != null && x.length > 0) {
      res$.push(x);
    }
  }
  path_parts = res$;
  current_path = 'https://api.github.com/repos/habitlab/habitlab/git/trees/master';
  for (i$ = 0, len$ = path_parts.length; i$ < len$; ++i$) {
    path_part = path_parts[i$];
    tree_contents = (await fetch_remote_json(current_path));
    res$ = [];
    for (j$ = 0, len1$ = (ref$ = tree_contents.tree).length; j$ < len1$; ++j$) {
      x = ref$[j$];
      if (x.path === path_part) {
        res$.push(x);
      }
    }
    matching_parts = res$;
    if (matching_parts.length === 0) {
      return [];
    }
    current_path = matching_parts[0].url;
  }
  tree_contents = (await fetch_remote_json(current_path));
  return (await (async function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = tree_contents.tree).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(x.path);
    }
    return results$;
  }()));
};
list_files_in_libs_common = async function(){
  return (await list_files_in_path_for_github_repo('src/libs_common'));
};
list_files_in_libs_backend = async function(){
  return (await list_files_in_path_for_github_repo('src/libs_backend'));
};
list_files_in_libs_frontend = async function(){
  return (await list_files_in_path_for_github_repo('src/libs_frontend'));
};
list_jspm_packages = function(){
  var libraries, library_names, output, i$, len$, libname;
  libraries = SystemJS.getConfig().map;
  library_names = Object.keys(libraries);
  library_names.sort();
  output = [];
  for (i$ = 0, len$ = library_names.length; i$ < len$; ++i$) {
    libname = library_names[i$];
    if (libname.indexOf('/') === -1) {
      output.push(libname);
    }
  }
  return output;
};
out$.list_jspm_libraries_as_markdown = list_jspm_libraries_as_markdown = async function(){
  var output, libs_common_files, libs_backend_files, libs_frontend_files, jspm_packages, i$, len$, libname, function_signatures, filename, ref$;
  output = [];
  libs_common_files = (await list_files_in_libs_common());
  libs_backend_files = (await list_files_in_libs_backend());
  libs_frontend_files = (await list_files_in_libs_frontend());
  jspm_packages = list_jspm_packages();
  output.push('### NPM Packages');
  for (i$ = 0, len$ = jspm_packages.length; i$ < len$; ++i$) {
    libname = jspm_packages[i$];
    output.push('* [' + libname + '](https://www.npmjs.com/package/' + libname + ')');
  }
  function_signatures = (await SystemJS['import']('libs_common/function_signatures'));
  output.push('');
  output.push('### HabitLab Frontend APIs');
  for (i$ = 0, len$ = libs_common_files.length; i$ < len$; ++i$) {
    filename = libs_common_files[i$];
    if (!(filename.endsWith('.ls') || filename.endsWith('.js'))) {
      continue;
    }
    libname = filename.replace(/.ls$/, '').replace(/.js$/, '');
    output.push('* [libs_common/' + libname + '](https://github.com/habitlab/habitlab/blob/master/src/libs_common/' + filename + ')');
  }
  output.push('');
  output.push('### HabitLab Common APIs');
  for (i$ = 0, len$ = libs_frontend_files.length; i$ < len$; ++i$) {
    filename = libs_frontend_files[i$];
    if (!(filename.endsWith('.ls') || filename.endsWith('.js'))) {
      continue;
    }
    libname = filename.replace(/.ls$/, '').replace(/.js$/, '');
    output.push('* [libs_frontend/' + libname + '](https://github.com/habitlab/habitlab/blob/master/src/libs_frontend/' + filename + ')');
  }
  output.push('');
  output.push('### HabitLab Backend APIs');
  for (i$ = 0, len$ = (ref$ = function_signatures.list_libs()).length; i$ < len$; ++i$) {
    libname = ref$[i$];
    filename = libname + '.ls';
    if (libs_backend_files.indexOf(filename) === -1) {
      filename = libname + '.js';
    }
    output.push('* [libs_common/' + libname + '](https://github.com/habitlab/habitlab/blob/master/src/libs_backend/' + filename + ')');
  }
  return output.join('\n');
};
out$.chrome_get_token = chrome_get_token = async function(){
  var manifest, clientId, scopes, redirectUri, url, result;
  manifest = chrome.runtime.getManifest();
  clientId = manifest.oauth2.client_id;
  scopes = encodeURIComponent(manifest.oauth2.scopes.join(' '));
  redirectUri = chrome.identity.getRedirectURL('oauth2');
  url = 'https://accounts.google.com/o/oauth2/auth' + '?response_type=id_token' + '&access_type=offline' + '&client_id=' + clientId + '&redirect_uri=' + redirectUri + '&scope=' + scopes;
  result = (await new Promise(function(resolve, reject){
    return chrome.identity.launchWebAuthFlow({
      'url': url,
      'interactive': true
    }, function(redirectedTo){
      var response;
      if (chrome.runtime.lastError) {
        console.log('have error');
        console.log(chrome.runtime.lastError.message);
        return reject('error');
      } else {
        response = redirectedTo.split('#', 2)[1];
        return resolve(response);
      }
    });
  }));
  result = result.split('&')[0];
  result = result.split('=')[1];
  return result;
};
out$.printcb = printcb = function(x){
  return console.log(x);
};
out$.printcb_json = printcb_json = function(x){
  return console.log(JSON.stringify(x, 0, 2));
};
out$.jspm_eval = jspm_eval = function(x){
  return SystemJS['import']('data:text/javascript;base64,' + btoa(unescape(encodeURIComponent(x))));
};
out$.printfunc = printfunc = function(func){
  var args, res$, i$, to$, nargs, len$, x;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  args = res$;
  res$ = [];
  for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
    x = args[i$];
    res$.push(x);
  }
  nargs = res$;
  nargs.push(printcb);
  return func.apply({}, nargs);
};
gexport_module('background_common', function(it){
  return eval(it);
});
//# sourceMappingURL=background_common.ls.map


/***/ }),

/***/ "./src/libs_backend/cacheget_utils.ls":
/*!********************************************!*\
  !*** ./src/libs_backend/cacheget_utils.ls ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var localforage, ref$, gexport, gexport_module, manifest, habitlab_version, is_production, localforage_store, get_store, localforage_store_remote, get_store_remote, localforage_store_systemjs, get_store_systemjs, clear_cache_localget, clear_cache_remoteget, clear_cache_systemjs, localget, localget_json, localget_base64, remoteget, remoteget_json, remoteget_base64, systemjsget, out$ =  true && exports || this;
localforage = __webpack_require__(/*! localforage */ "./node_modules/localforage/dist/localforage.js");
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
if ((typeof chrome != 'undefined' && chrome !== null ? (ref$ = chrome.runtime) != null ? ref$.getManifest : void 8 : void 8) != null) {
  manifest = chrome.runtime.getManifest();
  habitlab_version = manifest.version.split('.').join('-');
  is_production = manifest.update_url != null || localStorage.getItem('devmode_use_cache') === 'true';
} else {
  habitlab_version = 'test';
  is_production = false;
}
localforage_store = null;
get_store = function(){
  if (localforage_store == null) {
    if (is_production) {
      localforage_store = localforage.createInstance({
        name: 'localget'
      });
    } else {
      localforage_store = {
        setItem: async function(){},
        getItem: async function(){}
      };
    }
  }
  return localforage_store;
};
localforage_store_remote = null;
get_store_remote = function(){
  if (localforage_store_remote == null) {
    localforage_store_remote = localforage.createInstance({
      name: 'remoteget'
    });
  }
  return localforage_store_remote;
};
localforage_store_systemjs = null;
get_store_systemjs = function(){
  if (localforage_store_systemjs == null) {
    localforage_store_systemjs = localforage.createInstance({
      name: 'systemjsget'
    });
  }
  return localforage_store_systemjs;
};
/**
 * Clears the cache used by {@link #localget|localget} and {@link #localget_json|localget_json}
 */
out$.clear_cache_localget = clear_cache_localget = async function(){
  var store;
  store = get_store();
  return (await store.clear());
};
/**
 * Clears the cache used by {@link #remoteget|remoteget} and {@link #remoteget_json|remoteget_json}
 */
out$.clear_cache_remoteget = clear_cache_remoteget = async function(){
  var store;
  store = get_store_remote();
  return (await store.clear());
};
out$.clear_cache_systemjs = clear_cache_systemjs = async function(){
  var store;
  store = get_store_systemjs();
  return (await store.clear());
};
/**
 * Fetches a local URL and returns the content as text. This is for data that is local to the extension, ie chrome-extension URLs - for remote HTTP/HTTPS URLs, use {@link #remoteget|remoteget} instead. Result is cached - if you need to clear the cache, use {@link #clear_cache_localget|clear_cache_localget}.
 * @param {string} url - The URL that we should fetch
 * @return {Promise.<string>} Content of the remote URL, as text
 */
out$.localget = localget = async function(url){
  var store, res, request;
  store = get_store();
  res = (await store.getItem(url));
  if (res != null) {
    return res;
  }
  request = (await fetch(url));
  res = (await request.text());
  if (res != null) {
    (await store.setItem(url, res));
  }
  return res;
};
/**
 * Fetches a local URL and returns the content as JSON. This is for data that is local to the extension, ie chrome-extension URLs - for remote HTTP/HTTPS URLs, use {@link #remoteget_json|remoteget_json} instead. Result is cached - if you need to clear the cache, use {@link #clear_cache_localget|clear_cache_localget}.
 * @param {string} url - The URL that we should fetch
 * @return {Promise.<Object|Array>} Content of the remote URL, as parsed JSON (either an Object or Array)
 */
out$.localget_json = localget_json = async function(url){
  var text;
  text = (await localget(url));
  if (text != null) {
    return JSON.parse(text);
  }
  return null;
};
out$.localget_base64 = localget_base64 = async function(url){
  var text;
  text = (await localget(url));
  if (text != null) {
    return 'data:text/plain;base64,' + btoa(unescape(encodeURIComponent(text)));
  }
  return null;
};
/**
 * Fetches a remote URL and returns the content as text. This is for external HTTP/HTTPS URLs - for data that is local to the extension, use {@link #localget|localget} instead. Result is cached - if you need to clear the cache, use {@link #clear_cache_remoteget|clear_cache_remoteget}.
 * @param {string} url - The URL that we should fetch
 * @return {Promise.<string>} Content of the remote URL, as text
 */
out$.remoteget = remoteget = async function(url){
  var store, res, request;
  store = get_store_remote();
  res = (await store.getItem(url));
  if (res != null) {
    return res;
  }
  request = (await fetch(url));
  res = (await request.text());
  if (res != null) {
    (await store.setItem(url, res));
  }
  return res;
};
/**
 * Fetches a remote URL and returns the content as parsed JSON. This is for external HTTP/HTTPS URLs - for data that is local to the extension, use {@link #localget_json|localget_json} instead. Result is cached - if you need to clear the cache, use {@link #clear_cache_remoteget|clear_cache_remoteget}.
 * @param {string} url - The URL that we should fetch
 * @return {Promise.<Object|Array>} Content of the remote URL, as parsed JSON (either an Object or Array)
 */
out$.remoteget_json = remoteget_json = async function(url){
  var text;
  text = (await remoteget(url));
  if (text != null) {
    return JSON.parse(text);
  }
  return null;
};
out$.remoteget_base64 = remoteget_base64 = async function(url){
  var text;
  text = (await remoteget(url));
  if (text != null) {
    return 'data:text/plain;base64,' + btoa(unescape(encodeURIComponent(text)));
  }
  return null;
};
out$.systemjsget = systemjsget = async function(url){
  var store, res, request, this$ = this;
  if (!is_production) {
    url = url.replace(chrome.extension.getURL('/'), '');
    return (await fetch(chrome.extension.getURL('/' + url)).then(function(it){
      return it.text();
    }));
  }
  store = get_store_systemjs();
  url = url.replace(chrome.extension.getURL('/'), '');
  res = (await store.getItem(url));
  if (res != null) {
    return res;
  }
  request = (await fetch('https://habitlab-dist.github.io/' + habitlab_version + '/' + url));
  res = (await request.text());
  if (res != null) {
    (await store.setItem(url, res));
  }
  return res;
};
gexport_module('cacheget_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=cacheget_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/canonical_url_utils.ls":
/*!*************************************************!*\
  !*** ./src/libs_backend/canonical_url_utils.ls ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, url_to_domain, domain_to_url, get_canonical_url_cache, get_canonical_url, get_canonical_domain, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls"), url_to_domain = ref$.url_to_domain, domain_to_url = ref$.domain_to_url;
get_canonical_url_cache = {};
out$.get_canonical_url = get_canonical_url = async function(url){
  var response, output, e;
  if (get_canonical_url_cache[url] != null) {
    return get_canonical_url_cache[url];
  }
  try {
    response = (await fetch(url));
    output = response.url;
    if (output != null) {
      get_canonical_url_cache[url] = output;
    }
    return output;
  } catch (e$) {
    e = e$;
    return null;
  }
};
out$.get_canonical_domain = get_canonical_domain = async function(domain){
  var url, canonical_url;
  url = domain_to_url(domain);
  canonical_url = (await get_canonical_url(url));
  if (canonical_url != null) {
    return url_to_domain(canonical_url);
  }
  return null;
};
//# sourceMappingURL=canonical_url_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/codeacademy_utils.js":
/*!***********************************************!*\
  !*** ./src/libs_backend/codeacademy_utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  getvar,
  setvar,
} = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls")

const moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js")

const $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")

async function get_codeacademy_username_uncached() {
  let codeacademy_text = await fetch('https://www.codeacademy.com/learn', {credentials: 'include'}).then(x => x.text())
  let username_text_query = 'username":'
  let username_keyword_idx = codeacademy_text.indexOf(username_text_query)
  if (username_keyword_idx == -1) {
    console.log("couldn't find username keyword")
    return ''
  }
  let username_idx = username_keyword_idx + username_text_query.length + 1
  let username_end_idx = codeacademy_text.indexOf('"', username_idx)
  if (username_idx == -1 || username_end_idx == -1) {
    console.log("couldn't find username")
    return ''
  }
  return codeacademy_text.substring(username_idx, username_end_idx);
}

async function reset_cached_username() {
  await setvar('codeacademy_username', '')
}

async function get_codeacademy_username() {
  let cached_codeacademy_username = await getvar('codeacademy_username')
  if (cached_codeacademy_username != null && cached_codeacademy_username.length > 0) {
    return cached_codeacademy_username
  }
  let codeacademy_username = await get_codeacademy_username_uncached()
  if (codeacademy_username != null && codeacademy_username.length > 0) {
    await setvar('codeacademy_username', codeacademy_username)
  }
  console.log("username: " + codeacademy_username)
  return codeacademy_username
}

async function get_codeacademy_info_for_user(username) {
  if (username == null || username.length == 0) {
    return ''
  }
  return await fetch('https://www.codeacademy.com/' + username, {credentials: 'include'}).then(x => x.text())
}

async function get_codeacademy_info() {
  var codeacademy_username = await get_codeacademy_username()
  try {
    return await get_codeacademy_info_for_user(codeacademy_username)
  } catch (err) {
    console.log('resetting username cache and trying again...')
    await reset_cached_username()
    codeacademy_username = await get_codeacademy_username()
    return await get_codeacademy_info_for_user(codeacademy_username)
  }
}

async function get_codeacademy_is_logged_in() {
  let username = await get_codeacademy_username_uncached()
  return username != ''
}

async function get_codeacademy_streak() {
  let info = await get_codeacademy_info()
  let num_days = 0
  for (let elem of $(info).find('div').toArray()) {
    if (elem == null || elem.innerText == null) {
      continue
    }
    var text = elem.innerText.trim()
    if (text.endsWith('day streak')) {
      num_days = parseInt(text.replace('day streak', '').trim())
      break
    }
  }
  return num_days

  // // console.log(info)
  // let regex_query = /[0-9]+<\/h3>\n?[\n\t ]*<small>day streak/m
  // let streak_idx = info.search(regex_query)
  // let streak_end_idx = info.indexOf('<', streak_idx)
  // if (streak_idx == -1 || streak_end_idx == -1) {
  //   console.error('Could not find the Codeacademy streak.')
  //   return 0
  // }
  // let streak = parseInt(info.substring(streak_idx, streak_end_idx))
  // return streak
}

// async function get_codeacademy_did_submit_today() {
//   printcb('getting it...')
//   let profile_text = await get_codeacademy_info()
//   let keyword_query = '"time-ago" title="'
//   let keyword_idx = profile_text.indexOf(keyword_query)
//   console.log(profile_text)
//   if (keyword_idx == -1) {
//     console.log("couldn't find time-ago")
//     return false
//   }
//   let time_idx = keyword_idx + keyword_query.length
//   let time_end_idx = profile_text.indexOf('"', time_idx)
//   if (time_idx == -1 || time_end_idx == -1) {
//     console.log("couldn't find time")
//     return false
//   }

//   let time_text = profile_text.substr(time_idx, time_end_idx)
//   let sameDay = moment().isSame(time_text, 'day')
//   return sameDay
// }

module.exports = {
  get_codeacademy_username,
  get_codeacademy_username_uncached,
  get_codeacademy_info_for_user,
  get_codeacademy_info,
  get_codeacademy_is_logged_in,
  get_codeacademy_streak
}

/***/ }),

/***/ "./src/libs_backend/db_utils.ls":
/*!**************************************!*\
  !*** ./src/libs_backend/db_utils.ls ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, memoize, memoizeSingleAsync, dexie, gexport, gexport_module, get_db_major_version_db, get_db_minor_version_db, get_current_schema_db, get_current_dbver_db, delete_db_if_outdated_db, current_schema_for_collections, get_current_collections, list_collections_to_sync, is_collection_synced, sleep, local_cache_db, getdb_running, getDb, deleteDbCollection, deleteDb, getCollection, addtovar, setvar, getvar, clearvar, printvar, setvar_experiment, getvar_experiment, getvar_experiment_info, clearvar_experiment, printvar_experiment, setvar_history, getvar_history, clearvar_history, printvar_history, remove_key_from_var_dict, remove_item_from_var_list, addtolist, getlist, clearlist, addtolist_for_key, getlist_for_key, clearlist_for_key, setkey_dict, addtokey_dict, getkey_dict, delkey_dict, getdict, setdict, cleardict, getdictdict, getdict_for_key_dictdict, getdict_for_key2_dictdict, getkey_dictdict, setdict_for_key2_dictdict, setdict_for_key_dictdict, setkey_dictdict, addtokey_dictdict, clear_dictdict, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls"), memoize = ref$.memoize, memoizeSingleAsync = ref$.memoizeSingleAsync;
dexie = __webpack_require__(/*! dexie */ "./node_modules/dexie/dist/dexie.js");
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.get_db_major_version_db = get_db_major_version_db = function(){
  return '5';
};
out$.get_db_minor_version_db = get_db_minor_version_db = function(){
  return '1';
};
out$.get_current_schema_db = get_current_schema_db = function(){
  var result;
  result = localStorage.getItem('current_schema_db');
  if (result == null) {
    return {};
  }
  return JSON.parse(result);
};
out$.get_current_dbver_db = get_current_dbver_db = function(){
  var result;
  result = localStorage.getItem('current_dbver_db');
  if (result == null) {
    return 0;
  }
  return parseInt(result);
};
out$.delete_db_if_outdated_db = delete_db_if_outdated_db = async function(){
  if (localStorage.getItem('db_minor_version_db') !== get_db_minor_version_db()) {
    localStorage.setItem('db_minor_version_db', get_db_minor_version_db());
  }
  if (localStorage.getItem('db_major_version_db') !== get_db_major_version_db()) {
    (await deleteDb());
    localStorage.removeItem('current_schema_db');
    localStorage.setItem('db_major_version_db', get_db_major_version_db());
  }
};
current_schema_for_collections = {
  vars: 'key,synced',
  intervention_vars_synced: '[key+key2],key,key2,synced',
  intervention_vars_unsynced: '[key+key2],key,key2',
  goal_vars_synced: '[key+key2],key,key2,synced',
  goal_vars_unsynced: '[key+key2],key,key2',
  experiment_vars_for_goal: '[key+key2],key,key2,synced',
  experiment_vars: 'key,synced',
  history_vars: 'key,synced',
  interventions_enabled_each_day: '[key+key2],key,key2,synced',
  interventions_manually_managed_each_day: '[key+key2],key,key2,synced',
  seconds_on_domain_per_day: '[key+key2],key,key2,synced',
  visits_to_domain_per_day: '[key+key2],key,key2,synced',
  intervention_to_parameters: '[key+key2],key,key2,synced',
  custom_measurements_each_day: '[key+key2],key,key2,synced',
  seconds_on_domain_per_session: '[key+key2],key,key2,synced',
  interventions_active_for_domain_and_session: '[key+key2],key,key2,synced',
  domain_to_last_session_id: 'key,synced',
  domains_suggested_as_goals: 'key,synced',
  interventions_to_intensity_ratings: 'key,synced',
  custom_intervention_code: 'key',
  custom_intervention_code_original: 'key,synced',
  interventions_currently_disabled: 'key,synced',
  goal_targets: 'key,synced',
  goal_frequencies: 'key,synced',
  time_intervention_most_recently_seen: 'key,synced',
  seconds_saved_for_intervention: 'key,synced',
  seconds_saved_for_domain: 'key,synced',
  seconds_saved_for_intervention_on_domain: '[key+key2],key,key2,synced',
  baseline_session_time_on_domains: 'key,synced',
  baseline_time_on_domains: 'key,synced',
  times_intervention_used: 'key,synced',
  intervention_downvote_timestamps: '++,key,synced',
  intervention_upvote_timestamps: '++,key,synced',
  intervention_feedback: '++,key,synced',
  idea_pairs_voted: '++'
};
out$.get_current_collections = get_current_collections = function(){
  return current_schema_for_collections;
};
out$.list_collections_to_sync = list_collections_to_sync = function(){
  var output, k, ref$, v;
  output = [];
  for (k in ref$ = current_schema_for_collections) {
    v = ref$[k];
    if (v.endsWith(',synced')) {
      output.push(k);
    }
  }
  return output;
};
out$.is_collection_synced = is_collection_synced = function(collection_name){
  if (current_schema_for_collections[collection_name] != null && current_schema_for_collections[collection_name].endsWith(',synced')) {
    return true;
  }
  return false;
};
sleep = async function(time){
  return new Promise(function(it){
    return setTimeout(it, time);
  });
};
local_cache_db = null;
getdb_running = false;
out$.getDb = getDb = async function(){
  var db, dbver, prev_schema, stores_to_create, current_collections, k, v, new_schema, res$;
  if (local_cache_db != null && local_cache_db.isOpen()) {
    return local_cache_db;
  }
  if (getdb_running) {
    while (getdb_running) {
      (await sleep(1));
    }
    while (getdb_running || local_cache_db === null) {
      (await sleep(1));
    }
    return local_cache_db;
  }
  getdb_running = true;
  (await delete_db_if_outdated_db());
  db = new dexie('habitlab', {
    autoOpen: false
  });
  dbver = get_current_dbver_db();
  prev_schema = get_current_schema_db();
  stores_to_create = {};
  current_collections = get_current_collections();
  for (k in current_collections) {
    v = current_collections[k];
    if (prev_schema[k] == null) {
      stores_to_create[k] = v;
    }
  }
  res$ = {};
  for (k in prev_schema) {
    v = prev_schema[k];
    res$[k] = v;
  }
  new_schema = res$;
  if (Object.keys(stores_to_create).length > 0) {
    db.version(dbver).stores(prev_schema);
    dbver += 1;
    for (k in stores_to_create) {
      v = stores_to_create[k];
      new_schema[k] = v;
    }
    localStorage.setItem('current_schema_db', JSON.stringify(new_schema));
    localStorage.setItem('current_dbver_db', dbver);
  }
  db.version(dbver).stores(new_schema);
  db.on('versionchange', function(){
    var prev_schema;
    db.close();
    prev_schema = get_current_schema_db();
    dbver = parseInt(localStorage.getItem('current_dbver_db'));
    db.version(dbver).stores(prev_schema);
    db.open().then(function(new_db){
      return local_cache_db = new_db;
    });
    return false;
  });
  local_cache_db = (await db.open());
  getdb_running = false;
  return local_cache_db;
};
out$.deleteDbCollection = deleteDbCollection = async function(collection_name){
  var db, dbver, schema;
  db = (await getDb());
  db.close();
  dbver = get_current_dbver_db();
  dbver += 1;
  schema = get_current_schema_db();
  schema[collection_name] = null;
  db.version(dbver).stores(schema);
  localStorage.setItem('current_schema_db', JSON.stringify(schema));
  localStorage.setItem('current_dbver_db', dbver);
  return local_cache_db = (await db.open());
};
out$.deleteDb = deleteDb = async function(){
  var db;
  localStorage.removeItem('current_schema_db');
  localStorage.removeItem('current_dbver_db');
  db = new dexie('habitlab');
  (await db['delete']());
};
out$.getCollection = getCollection = async function(collection_name){
  var db;
  db = (await getDb());
  return db[collection_name];
};
out$.addtovar = addtovar = async function(key, val){
  var data, new_val, num_modified;
  data = (await getCollection('vars'));
  new_val = val;
  num_modified = (await data.where('key').equals(key).modify(function(x){
    x.synced = 0;
    x.val += val;
    return new_val = x.val;
  }));
  if (num_modified === 1) {
    return new_val;
  }
  if (num_modified > 1) {
    console.log("addtovar " + key + " matched more than 1");
    return new_val;
  }
  return (await setvar(key, val));
};
out$.setvar = setvar = async function(key, val){
  var data;
  data = (await getCollection('vars'));
  (await data.put({
    key: key,
    val: val,
    synced: 0,
    timestamp: Date.now()
  }));
  return val;
};
out$.getvar = getvar = async function(key){
  var data, result;
  data = (await getCollection('vars'));
  result = (await data.get(key));
  if (result != null) {
    return result.val;
  } else {
    return null;
  }
};
out$.clearvar = clearvar = async function(key){
  var data, num_deleted;
  data = (await getCollection('vars'));
  num_deleted = (await data.where('key').equals(key)['delete']());
};
out$.printvar = printvar = async function(key){
  var result;
  result = (await getvar(key));
  console.log(result);
  return result;
};
out$.setvar_experiment = setvar_experiment = async function(key, val, conditions){
  var data;
  data = (await getCollection('experiment_vars'));
  if (conditions != null) {
    (await data.put({
      key: key,
      val: val,
      conditions: conditions,
      synced: 0,
      timestamp: Date.now()
    }));
  } else {
    (await data.put({
      key: key,
      val: val,
      synced: 0,
      timestamp: Date.now()
    }));
  }
  return val;
};
out$.getvar_experiment = getvar_experiment = async function(key){
  var data, result;
  data = (await getCollection('experiment_vars'));
  result = (await data.get(key));
  if (result != null) {
    return result.val;
  } else {
    return null;
  }
};
out$.getvar_experiment_info = getvar_experiment_info = async function(key){
  var data, result;
  data = (await getCollection('experiment_vars'));
  result = (await data.get(key));
  return result;
};
out$.clearvar_experiment = clearvar_experiment = async function(key){
  var data, num_deleted;
  data = (await getCollection('experiment_vars'));
  num_deleted = (await data.where('key').equals(key)['delete']());
};
out$.printvar_experiment = printvar_experiment = async function(key){
  var result;
  result = (await getvar_experiment(key));
  console.log(result);
  return result;
};
out$.setvar_history = setvar_history = async function(key, val){
  var data;
  data = (await getCollection('history_vars'));
  (await data.put({
    key: key,
    val: val,
    synced: 0,
    timestamp: Date.now()
  }));
  return val;
};
out$.getvar_history = getvar_history = async function(key){
  var data, result;
  data = (await getCollection('history_vars'));
  result = (await data.get(key));
  if (result != null) {
    return result.val;
  } else {
    return null;
  }
};
out$.clearvar_history = clearvar_history = async function(key){
  var data, num_deleted;
  data = (await getCollection('history_vars'));
  num_deleted = (await data.where('key').equals(key)['delete']());
};
out$.printvar_history = printvar_history = async function(key){
  var result;
  result = (await getvar_history(key));
  console.log(result);
  return result;
};
out$.remove_key_from_var_dict = remove_key_from_var_dict = async function(dictname, key){
  var dict_text, dict;
  dict_text = (await getvar(dictname));
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  if (dict[key] != null) {
    delete dict[key];
  }
  (await setvar(dictname, JSON.stringify(dict)));
};
out$.remove_item_from_var_list = remove_item_from_var_list = async function(listname, item){
  var list_text, list;
  list_text = (await getvar(listname));
  if (list_text != null) {
    list = JSON.parse(list_text);
  } else {
    list = [];
  }
  list = list.filter(function(it){
    return it !== item;
  });
  return (await setvar(listname, JSON.stringify(list)));
};
out$.addtolist = addtolist = async function(name, val){
  var data, result;
  data = (await getCollection(name));
  result = (await data.add(val));
  return val;
};
out$.getlist = getlist = async function(name){
  var data, result;
  data = (await getCollection(name));
  result = (await data.toArray());
  return result;
};
out$.clearlist = clearlist = async function(name){
  var data, num_deleted;
  data = (await getCollection(name));
  num_deleted = (await data['delete']());
};
out$.addtolist_for_key = addtolist_for_key = async function(name, key, val){
  var data, newval, result;
  data = (await getCollection(name));
  newval = {
    key: key,
    val: val
  };
  result = (await data.add(newval));
  return newval;
};
out$.getlist_for_key = getlist_for_key = async function(name, key){
  var data, result, this$ = this;
  data = (await getCollection(name));
  result = (await data.where('key').equals(key).toArray());
  return result.map(function(it){
    return it.val;
  });
};
out$.clearlist_for_key = clearlist_for_key = async function(name, key){
  var data, num_deleted;
  data = (await getCollection(name));
  num_deleted = (await data.where('key').equals(key)['delete']());
};
out$.setkey_dict = setkey_dict = async function(name, key, val){
  var data, result;
  data = (await getCollection(name));
  result = (await data.put({
    key: key,
    val: val,
    synced: 0,
    timestamp: Date.now()
  }));
  return val;
};
out$.addtokey_dict = addtokey_dict = async function(name, key, val){
  var data, new_val, num_modified;
  data = (await getCollection(name));
  new_val = val;
  num_modified = (await data.where('key').equals(key).modify(function(x){
    x.synced = 0;
    x.val += val;
    return new_val = x.val;
  }));
  if (num_modified === 1) {
    return new_val;
  }
  if (num_modified > 1) {
    console.log("addtokey_dict " + name + " " + key + " matched more than 1");
    return new_val;
  }
  return (await setkey_dict(name, key, val));
};
out$.getkey_dict = getkey_dict = async function(name, key){
  var data, result;
  data = (await getCollection(name));
  result = (await data.where('key').equals(key).toArray());
  if (result.length > 0) {
    return result[0].val;
  }
};
out$.delkey_dict = delkey_dict = async function(name, key){
  var data, num_deleted;
  data = (await getCollection(name));
  num_deleted = (await data.where('key').equals(key)['delete']());
};
out$.getdict = getdict = async function(name){
  var data, result, key, val;
  data = (await getCollection(name));
  result = (await data.toArray());
  return (await (async function(){
    var i$, ref$, len$, ref1$, resultObj$ = {};
    for (i$ = 0, len$ = (ref$ = result).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], key = ref1$.key, val = ref1$.val;
      resultObj$[key] = val;
    }
    return resultObj$;
  }()));
};
out$.setdict = setdict = async function(name, dict){
  var data, items_to_add, res$, key, val, result;
  data = (await getCollection(name));
  res$ = [];
  for (key in dict) {
    val = dict[key];
    res$.push({
      key: key,
      val: val,
      synced: 0,
      timestamp: Date.now()
    });
  }
  items_to_add = res$;
  result = (await data.bulkPut(items_to_add));
  return dict;
};
out$.cleardict = cleardict = async function(name){
  var data, num_deleted;
  data = (await getCollection(name));
  num_deleted = (await data.filter(function(){
    return true;
  })['delete']());
};
out$.getdictdict = getdictdict = async function(name){
  var data, result, output, i$, len$, ref$, key, key2, val;
  data = (await getCollection(name));
  result = (await data.toArray());
  output = {};
  for (i$ = 0, len$ = result.length; i$ < len$; ++i$) {
    ref$ = result[i$], key = ref$.key, key2 = ref$.key2, val = ref$.val;
    if (output[key] == null) {
      output[key] = {};
    }
    output[key][key2] = val;
  }
  return output;
};
out$.getdict_for_key_dictdict = getdict_for_key_dictdict = async function(name, key){
  var data, result, output, i$, len$, ref$, key2, val;
  data = (await getCollection(name));
  result = (await data.where('key').equals(key).toArray());
  if (result.length > 0) {
    output = {};
    for (i$ = 0, len$ = result.length; i$ < len$; ++i$) {
      ref$ = result[i$], key2 = ref$.key2, val = ref$.val;
      output[key2] = val;
    }
    return output;
  }
  return {};
};
out$.getdict_for_key2_dictdict = getdict_for_key2_dictdict = async function(name, key2){
  var data, result, output, i$, len$, ref$, key, val;
  data = (await getCollection(name));
  result = (await data.where('key2').equals(key2).toArray());
  if (result.length > 0) {
    output = {};
    for (i$ = 0, len$ = result.length; i$ < len$; ++i$) {
      ref$ = result[i$], key = ref$.key, val = ref$.val;
      output[key] = val;
    }
    return output;
  }
  return {};
};
out$.getkey_dictdict = getkey_dictdict = async function(name, key, key2){
  var data, result;
  data = (await getCollection(name));
  result = (await data.where('[key+key2]').equals([key, key2]).toArray());
  if (result.length > 0) {
    return result[0].val;
  }
};
out$.setdict_for_key2_dictdict = setdict_for_key2_dictdict = async function(name, key2, dict){
  var data, items_to_add, res$, key, val, result;
  data = (await getCollection(name));
  res$ = [];
  for (key in dict) {
    val = dict[key];
    res$.push({
      key: key,
      key2: key2,
      val: val,
      synced: 0,
      timestamp: Date.now()
    });
  }
  items_to_add = res$;
  result = (await data.bulkPut(items_to_add));
  return dict;
};
out$.setdict_for_key_dictdict = setdict_for_key_dictdict = async function(name, key, dict){
  var data, items_to_add, res$, key2, val, result;
  data = (await getCollection(name));
  res$ = [];
  for (key2 in dict) {
    val = dict[key2];
    res$.push({
      key: key,
      key2: key2,
      val: val,
      synced: 0,
      timestamp: Date.now()
    });
  }
  items_to_add = res$;
  result = (await data.bulkPut(items_to_add));
  return dict;
};
out$.setkey_dictdict = setkey_dictdict = async function(name, key, key2, val){
  var data, result;
  data = (await getCollection(name));
  result = (await data.put({
    key: key,
    key2: key2,
    val: val,
    synced: 0,
    timestamp: Date.now()
  }));
  return val;
};
out$.addtokey_dictdict = addtokey_dictdict = async function(name, key, key2, val){
  var data, new_val, num_modified;
  data = (await getCollection(name));
  new_val = val;
  num_modified = (await data.where('[key+key2]').equals([key, key2]).modify(function(x){
    x.synced = 0;
    x.val += val;
    return new_val = x.val;
  }));
  if (num_modified === 1) {
    return new_val;
  }
  if (num_modified > 1) {
    console.log("addtokey_dictdict " + name + " " + key + " " + key2 + " matched more than 1");
    return new_val;
  }
  return (await setkey_dictdict(name, key, key2, val));
};
out$.clear_dictdict = clear_dictdict = async function(name){
  var data, num_deleted;
  data = (await getCollection(name));
  num_deleted = (await data.filter(function(){
    return true;
  })['delete']());
};
gexport_module('db_utils_backend', function(it){
  return eval(it);
});
//# sourceMappingURL=db_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/debug_console_utils.ls":
/*!*************************************************!*\
  !*** ./src/libs_backend/debug_console_utils.ls ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var open_debug_page_for_tab_id;
open_debug_page_for_tab_id = async function(tab_id){
  var debug_page_url, popup_windows, i$, len$, popup_window, window_info, j$, ref$, len1$, tab;
  debug_page_url = chrome.runtime.getURL('index.html?tag=terminal-view&autoload=true&ispopup=true&tabid=' + tab_id);
  popup_windows = (await new Promise(function(it){
    return chrome.windows.getAll({
      windowTypes: ['popup']
    }, it);
  }));
  for (i$ = 0, len$ = popup_windows.length; i$ < len$; ++i$) {
    popup_window = popup_windows[i$];
    window_info = (await new Promise(fn$));
    for (j$ = 0, len1$ = (ref$ = window_info.tabs).length; j$ < len1$; ++j$) {
      tab = ref$[j$];
      if (tab.url === debug_page_url) {
        (await new Promise(fn1$));
        return (await new Promise(fn2$));
      }
    }
  }
  return (await new Promise(function(it){
    return chrome.windows.create({
      url: debug_page_url,
      type: 'popup',
      width: 566,
      height: 422
    }, it);
  }));
  function fn$(it){
    return chrome.windows.get(popup_window.id, {
      populate: true
    }, it);
  }
  function fn1$(it){
    return chrome.tabs.update(tab.id, {
      active: true
    }, it);
  }
  function fn2$(it){
    return chrome.windows.update(popup_window.id, {
      focused: true
    }, it);
  }
};
module.exports.open_debug_page_for_tab_id = open_debug_page_for_tab_id;
//# sourceMappingURL=debug_console_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/disable_habitlab_utils.ls":
/*!****************************************************!*\
  !*** ./src/libs_backend/disable_habitlab_utils.ls ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, get_active_tab_id, disable_interventions_in_all_tabs, get_days_since_epoch, gexport, gexport_module, disable_habitlab, enable_habitlab, is_habitlab_enabled, is_habitlab_enabled_sync, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_active_tab_id = ref$.get_active_tab_id, disable_interventions_in_all_tabs = ref$.disable_interventions_in_all_tabs;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.disable_habitlab = disable_habitlab = async function(){
  var days_since_epoch, tabs, i$, len$, tab, results$ = [];
  days_since_epoch = get_days_since_epoch();
  localStorage.setItem('habitlab_disabled', days_since_epoch.toString());
  (await disable_interventions_in_all_tabs());
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({}, it);
  }));
  for (i$ = 0, len$ = tabs.length; i$ < len$; ++i$) {
    tab = tabs[i$];
    results$.push(chrome.browserAction.setIcon({
      tabId: tab.id,
      path: chrome.extension.getURL('icons/icon_disabled.svg')
    }));
  }
  return results$;
};
out$.enable_habitlab = enable_habitlab = async function(){
  var tabs, i$, len$, tab, results$ = [];
  localStorage.removeItem('habitlab_disabled');
  tabs = (await new Promise(function(it){
    return chrome.tabs.query({}, it);
  }));
  for (i$ = 0, len$ = tabs.length; i$ < len$; ++i$) {
    tab = tabs[i$];
    results$.push(chrome.browserAction.setIcon({
      tabId: tab.id,
      path: chrome.extension.getURL('icons/icon.svg')
    }));
  }
  return results$;
};
out$.is_habitlab_enabled = is_habitlab_enabled = async function(){
  return is_habitlab_enabled_sync();
};
out$.is_habitlab_enabled_sync = is_habitlab_enabled_sync = function(){
  var days_since_epoch;
  days_since_epoch = get_days_since_epoch();
  return localStorage.getItem('habitlab_disabled') !== days_since_epoch.toString();
};
gexport_module('disable_habitlab_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=disable_habitlab_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/duolingo_utils.js":
/*!********************************************!*\
  !*** ./src/libs_backend/duolingo_utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  getvar,
  setvar,
} = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls")


const {
  get_measurement_for_days_before_today,
  add_to_measurement_days_before_today
} = __webpack_require__(/*! libs_common/measurement_utils */ "./src/libs_common/measurement_utils.ls")

const {
  getvar_intervention_unsynced_backend,
  setvar_intervention_unsynced_backend
} = __webpack_require__(/*! libs_backend/intervention_vars_backend */ "./src/libs_backend/intervention_vars_backend.js")

const {
  promise_all_object
} = __webpack_require__ (/*! libs_common/promise_utils */ "./src/libs_common/promise_utils.js")

const {
  sleep
} = __webpack_require__(/*! libs_common/common_libs */ "./src/libs_common/common_libs.ls")

const moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js")

async function get_duolingo_username_uncached() {
  let duolingo_text = await fetch('https://www.duolingo.com/info', {credentials: 'include'}).then(x => x.text())
  let username_text_query = "'username': "
  let username_idx = duolingo_text.indexOf(username_text_query)
  if (username_idx == -1) {
    return ''
  }
  let duolingo_text_after_username = duolingo_text.substr(username_idx + username_text_query.length + 1)
  let username_end_idx = duolingo_text_after_username.indexOf("'")
  if (username_end_idx == -1) {
    return ''
  }
  return duolingo_text_after_username.substr(0, username_end_idx)
}

async function reset_cached_username() {
  await setvar('duolingo_username', '')
}

async function get_duolingo_username() {
  let cached_duolingo_username = await getvar('duolingo_username')
  if (cached_duolingo_username != null && cached_duolingo_username.length > 0) {
    return cached_duolingo_username
  }
  let duolingo_username = await get_duolingo_username_uncached()
  if (duolingo_username != null && duolingo_username.length > 0) {
    await setvar('duolingo_username', duolingo_username)
  }
  return duolingo_username
}

async function wait_until_user_is_logged_in(timeout) {
  let wait_start_time = moment()
  while (moment().diff(wait_start_time, 'seconds') < timeout) {
    let is_logged_in = await get_duolingo_is_logged_in()
    if (is_logged_in) {
      return true
    }
    await sleep(200)
  }
  return false
}

async function get_duolingo_info_for_user(username) {
  if (username == null || username.length == 0) {
    console.log('null username')    
    return {}
  }
  return await fetch('https://www.duolingo.com/users/' + username, {credentials: 'include'}).then(x => x.json())
}

async function get_duolingo_info() {
  var duolingo_username = await get_duolingo_username()
  try {
    return await get_duolingo_info_for_user(duolingo_username)
  } catch (err) {
    console.error(err)
    console.log('resetting username cache and trying again...')
    await reset_cached_username()
    duolingo_username = await get_duolingo_username()
    return await get_duolingo_info_for_user(duolingo_username)
  }
}

async function get_duolingo_is_logged_in() {
  let username = await get_duolingo_username_uncached()
  return username != ''
}

/// Precondition: user is logged in (call get_whether_logged_in() first)
async function get_duolingo_streak() {
  let info = await get_duolingo_info()
  return info.site_streak
}

async function get_last_duolingo_progress_update_time() {
  return await getvar_intervention_unsynced_backend('duolingo/complete_lesson_each_day', 'last_progress_update_time')
}

async function update_duolingo_progress() {
  // Use intervention_vars_backend
  let logged_in = await get_duolingo_is_logged_in()
  if (!logged_in) {
    console.error("not logged in to duolingo, can't update duolingo progress")
    return
  }

  let [last_progress_update, duolingo_info] = await Promise.all([
    get_last_duolingo_progress_update_time(),
    get_duolingo_info()
  ])

  // Iterate through the lesson events backward in time until last_progress_update, incrementing the lesson completed counts along the way
  let lesson_update_counts = new Map()
  for (let i = duolingo_info.calendar.length - 1; i >= 0; i--) {
    let lesson = duolingo_info.calendar[i]
    if (lesson == null) {
      console.error("Lesson is undefined! Calendar is:")
      console.error(duolingo_info.calendar)      
      continue
    }
    let lesson_moment = moment().year(1970).month(0).date(1).hours(0).minutes(0).seconds(0).milliseconds(lesson.datetime)
    if (lesson_moment.isBefore(last_progress_update)) {
      break
    }
    let lesson_days_ago = moment().diff(lesson_moment, 'days')
    if (!(lesson_days_ago in lesson_update_counts)) {
      lesson_update_counts.set(lesson_days_ago, 0)
    }
    let old_count = lesson_update_counts.get(lesson_days_ago)
    lesson_update_counts.set(lesson_days_ago, old_count + 1)
  }
  for (let [days_ago, count] of lesson_update_counts.entries()) {
    await add_to_measurement_days_before_today('duolingo_lessons_completed', days_ago, count)
  }
  setvar_intervention_unsynced_backend('duolingo/complete_lesson_each_day', 'last_progress_update_time', moment().format())  
}

module.exports = {
  get_duolingo_username,
  get_duolingo_username_uncached,
  get_duolingo_info_for_user,
  get_duolingo_info,
  get_duolingo_streak,
  get_duolingo_is_logged_in,
  update_duolingo_progress,
  get_last_duolingo_progress_update_time,
  wait_until_user_is_logged_in
}


/***/ }),

/***/ "./src/libs_backend/expose_lib.ls":
/*!****************************************!*\
  !*** ./src/libs_backend/expose_lib.ls ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, get_function_signature, list_functions_in_lib, func_name_to_func, expose_lib, expose, expose_func, get_func_by_name, get_message_handler, get_all_message_handlers, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/function_signatures */ "./src/libs_common/function_signatures.ls"), get_function_signature = ref$.get_function_signature, list_functions_in_lib = ref$.list_functions_in_lib;
func_name_to_func = {};
out$.expose_lib = expose_lib = function(lib_name, dict){
  var i$, ref$, len$, func_name;
  for (i$ = 0, len$ = (ref$ = list_functions_in_lib(lib_name)).length; i$ < len$; ++i$) {
    func_name = ref$[i$];
    expose_func(func_name, dict[func_name]);
  }
};
out$.expose = expose = function(dict){
  var func_name, func;
  for (func_name in dict) {
    func = dict[func_name];
    expose_func(func_name, func);
  }
};
out$.expose_func = expose_func = function(func_name, func){
  var signature;
  signature = get_function_signature(func_name);
  if (signature == null) {
    throw new Error("need to add function signature for function " + func_name + " to libs_common/function_signatures.ls");
  }
  if (!(typeof signature === 'string' || Array.isArray(signature))) {
    throw new Error("invalid signature " + JSON.stringify(signature) + " for function " + func_name + " in libs_common/function_signatures.ls");
  }
  if (func == null) {
    throw new Error("invalid function provided to expose_func for name " + func_name);
  }
  return func_name_to_func[func_name] = func;
};
out$.get_func_by_name = get_func_by_name = function(func_name){
  return func_name_to_func[func_name];
};
out$.get_message_handler = get_message_handler = function(func_name){
  var signature, func;
  signature = get_function_signature(func_name);
  func = func_name_to_func[func_name];
  if (Array.isArray(signature)) {
    return async function(data){
      var args, res$, i$, ref$, len$, arg_name;
      res$ = [];
      for (i$ = 0, len$ = (ref$ = signature).length; i$ < len$; ++i$) {
        arg_name = ref$[i$];
        res$.push(data[arg_name]);
      }
      args = res$;
      return (await func.apply(null, args));
    };
  }
  if (typeof signature === 'string') {
    return func;
  }
  throw new Error("get_message_handler failed for function named " + func_name + " with signature " + JSON.stringify(signature));
};
out$.get_all_message_handlers = get_all_message_handlers = function(){
  var output, i$, ref$, len$, func_name;
  output = {};
  for (i$ = 0, len$ = (ref$ = Object.keys(func_name_to_func)).length; i$ < len$; ++i$) {
    func_name = ref$[i$];
    output[func_name] = get_message_handler(func_name);
  }
  return output;
};
//# sourceMappingURL=expose_lib.ls.map


/***/ }),

/***/ "./src/libs_backend/favicon_utils.ls":
/*!*******************************************!*\
  !*** ./src/libs_backend/favicon_utils.ls ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var domain_to_url, ref$, get_canonical_domain, get_canonical_url, localforage, memoizeSingleAsync, unique, gexport, gexport_module, get_jimp, get_cheerio, get_icojs, favicon_patterns_href, localforage_store_iconcache, get_store_iconcache, domain_to_favicons_cache, fetchFavicons, fetch_favicon, toBuffer, make_async, does_file_exist_cached, does_file_exist, async_filter, arrayBufferToBase64, favicon_domain_icojs_blacklist, favicon_domain_jimp_blacklist, get_favicon_data_for_url, get_png_data_for_url, remove_cached_favicon_for_domain, get_favicon_data_for_domain_cached, get_favicon_data_for_domain, get_favicon_data_for_domains_bulk, out$ =  true && exports || this;
domain_to_url = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").domain_to_url;
ref$ = __webpack_require__(/*! libs_backend/canonical_url_utils */ "./src/libs_backend/canonical_url_utils.ls"), get_canonical_domain = ref$.get_canonical_domain, get_canonical_url = ref$.get_canonical_url;
localforage = __webpack_require__(/*! localforage */ "./node_modules/localforage/dist/localforage.js");
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
unique = __webpack_require__(/*! libs_common/array_utils */ "./src/libs_common/array_utils.ls").unique;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
get_jimp = memoizeSingleAsync(async function(){
  return (await SystemJS['import']('jimp'));
});
get_cheerio = memoizeSingleAsync(async function(){
  return (await SystemJS['import']('cheerio'));
});
get_icojs = memoizeSingleAsync(async function(){
  return (await SystemJS['import']('icojs'));
});
favicon_patterns_href = ['link[rel=apple-touch-icon-precomposed]', 'link[rel=apple-touch-icon]', 'link[rel="shortcut icon"]', 'link[rel="Shortcut Icon"]', 'link[rel=icon]'];
localforage_store_iconcache = null;
get_store_iconcache = function(){
  if (localforage_store_iconcache == null) {
    localforage_store_iconcache = localforage.createInstance({
      name: 'iconcache'
    });
  }
  return localforage_store_iconcache;
};
domain_to_favicons_cache = {};
out$.fetchFavicons = fetchFavicons = async function(domain){
  var response, text, cheerio, $, output, i$, ref$, len$, pattern, j$, ref1$, len1$, x, url;
  domain = domain_to_url(domain);
  if (domain_to_favicons_cache[domain] != null) {
    return domain_to_favicons_cache[domain];
  }
  response = (await fetch(domain));
  text = (await response.text());
  cheerio = (await get_cheerio());
  $ = cheerio.load(text);
  output = [];
  for (i$ = 0, len$ = (ref$ = favicon_patterns_href).length; i$ < len$; ++i$) {
    pattern = ref$[i$];
    for (j$ = 0, len1$ = (ref1$ = $(pattern)).length; j$ < len1$; ++j$) {
      x = ref1$[j$];
      url = $(x).attr('href');
      if (url != null && url.trim != null) {
        output.push(url.trim());
      }
    }
  }
  output.push('/favicon.ico');
  output = output.map(function(x){
    var domain_without_slash;
    if (x.startsWith('http://') || x.startsWith('https://')) {
      return x;
    }
    if (x.startsWith('//')) {
      return 'http:' + x;
    }
    domain_without_slash = domain;
    if (domain.endsWith('/') && x.startsWith('/')) {
      domain_without_slash = domain.substr(0, domain.length - 1);
    }
    return domain_without_slash + x;
  });
  output = unique(output);
  output = output.map(function(it){
    return {
      href: it,
      name: 'favicon.ico'
    };
  });
  domain_to_favicons_cache[domain] = output;
  return output;
};
fetch_favicon = {
  fetchFavicons: fetchFavicons
};
toBuffer = function(ab){
  var buf, view, i$, to$, i;
  buf = new Buffer(ab.byteLength);
  view = new Uint8Array(ab);
  for (i$ = 0, to$ = buf.length; i$ < to$; ++i$) {
    i = i$;
    buf[i] = view[i];
  }
  return buf;
};
make_async = function(sync_func){
  return function(x){
    return Promise.resolve(sync_func(x));
  };
};
does_file_exist_cached = {};
does_file_exist = async function(url){
  var request, e;
  if (typeof url !== 'string' && typeof url.href === 'string') {
    url = url.href;
  }
  if (does_file_exist_cached[url] != null) {
    return does_file_exist_cached[url];
  }
  try {
    request = (await fetch(url));
    if (!request.ok) {
      return false;
    }
    (await request.text());
    does_file_exist_cached[url] = true;
    return true;
  } catch (e$) {
    e = e$;
    does_file_exist_cached[url] = false;
    return false;
  }
};
async_filter = async function(list, async_function){
  var output, i$, len$, x;
  output = [];
  for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
    x = list[i$];
    if ((await async_function(x))) {
      output.push(x);
    }
  }
  return output;
};
arrayBufferToBase64 = function(buffer){
  var binary, bytes, len, i$, i;
  binary = '';
  bytes = new Uint8Array(buffer);
  len = bytes.byteLength;
  for (i$ = 0; i$ < len; ++i$) {
    i = i$;
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
};
favicon_domain_icojs_blacklist = {
  'news.ycombinator.com': 'news.ycombinator.com'
};
favicon_domain_jimp_blacklist = {};
out$.get_favicon_data_for_url = get_favicon_data_for_url = async function(domain){
  var icojs_convert, favicon_path, all_favicon_paths, filter_functions, i$, len$, filter_function, new_all_favicon_paths, favicon_response, favicon_buffer, icojs, favicon_ico_parsed, favicon_png_buffer, favicon_ico_base64, e, jimp, favicon_data;
  icojs_convert = false;
  if (domain.endsWith('.ico')) {
    favicon_path = domain;
  } else {
    if (!(domain.startsWith('http://') || domain.startsWith('https://') || domain.startsWith('//'))) {
      domain = 'http://' + domain;
    } else if (domain.startsWith('//')) {
      domain = 'http:' + domain;
    }
    all_favicon_paths = (await fetch_favicon.fetchFavicons(domain));
    filter_functions = [does_file_exist];
    filter_functions = filter_functions.concat([
      function(it){
        return it.name === 'favicon.ico';
      }, function(it){
        return it.href.endsWith('favicon.ico');
      }, function(it){
        return it.href.startsWith('favicon.ico');
      }, function(it){
        return it.href.includes('favicon.ico');
      }, function(it){
        return it.href.endsWith('.ico');
      }, function(it){
        return it.href.includes('favicon');
      }
    ].map(make_async));
    for (i$ = 0, len$ = filter_functions.length; i$ < len$; ++i$) {
      filter_function = filter_functions[i$];
      new_all_favicon_paths = (await async_filter(all_favicon_paths, filter_function));
      if (new_all_favicon_paths.length > 0) {
        all_favicon_paths = new_all_favicon_paths;
      }
    }
    favicon_path = (await get_canonical_url(all_favicon_paths[0].href));
  }
  if (favicon_path == null || favicon_path.length === 0) {
    throw new Error('no favicon path found');
  }
  try {
    favicon_response = (await fetch(favicon_path));
    favicon_buffer = (await favicon_response.arrayBuffer());
    if (icojs_convert) {
      icojs = (await get_icojs());
      favicon_ico_parsed = (await icojs.parse(favicon_buffer, 'image/png'));
      favicon_png_buffer = toBuffer(favicon_ico_parsed[0].buffer);
      return 'data:image/png;base64,' + favicon_png_buffer.toString('base64');
    } else {
      favicon_ico_base64 = arrayBufferToBase64(favicon_buffer);
      return 'data:image/png;base64,' + favicon_ico_base64;
    }
  } catch (e$) {
    e = e$;
  }
  try {
    jimp = (await get_jimp());
    favicon_data = (await jimp.read(favicon_path));
    favicon_data.resize(40, 40);
    return (await new Promise(function(it){
      return favicon_data.getBase64('image/png', it);
    }));
  } catch (e$) {
    e = e$;
  }
};
out$.get_png_data_for_url = get_png_data_for_url = async function(domain){
  var jimp_convert, favicon_path, all_favicon_paths, filter_functions, i$, len$, filter_function, new_all_favicon_paths, jimp, favicon_data, favicon_response, favicon_buffer, favicon_ico_base64, e;
  jimp_convert = false;
  if (domain.endsWith('.png') || domain.endsWith('.svg') || domain.endsWith('.ico')) {
    favicon_path = domain;
  } else {
    if (!(domain.startsWith('http://') || domain.startsWith('https://') || domain.startsWith('//'))) {
      domain = 'http://' + domain;
    } else if (domain.startsWith('//')) {
      domain = 'http:' + domain;
    }
    all_favicon_paths = (await fetch_favicon.fetchFavicons(domain));
    filter_functions = [does_file_exist];
    filter_functions = filter_functions.concat([
      function(it){
        return it.href.includes('icon');
      }, function(it){
        return it.href.endsWith('.png');
      }, function(it){
        return it.href.includes('.png');
      }
    ].map(make_async));
    for (i$ = 0, len$ = filter_functions.length; i$ < len$; ++i$) {
      filter_function = filter_functions[i$];
      new_all_favicon_paths = (await async_filter(all_favicon_paths, filter_function));
      if (new_all_favicon_paths.length > 0) {
        all_favicon_paths = new_all_favicon_paths;
      }
    }
    favicon_path = (await get_canonical_url(all_favicon_paths[0].href));
  }
  try {
    if (jimp_convert) {
      jimp = (await get_jimp());
      favicon_data = (await jimp.read(favicon_path));
      favicon_data.resize(40, 40);
      return (await new Promise(function(it){
        return favicon_data.getBase64('image/png', it);
      }));
    } else {
      favicon_response = (await fetch(favicon_path));
      favicon_buffer = (await favicon_response.arrayBuffer());
      favicon_ico_base64 = arrayBufferToBase64(favicon_buffer);
      return 'data:image/png;base64,' + favicon_ico_base64;
    }
  } catch (e$) {
    e = e$;
  }
};
out$.remove_cached_favicon_for_domain = remove_cached_favicon_for_domain = async function(domain){
  var store;
  store = get_store_iconcache();
  (await store.removeItem(domain));
};
out$.get_favicon_data_for_domain_cached = get_favicon_data_for_domain_cached = async function(domain){
  var store, res;
  if (domain == null) {
    return;
  }
  store = get_store_iconcache();
  res = (await store.getItem(domain));
  if (res != null) {
    return res;
  }
  res = (await get_favicon_data_for_domain(domain));
  if (res != null) {
    (await store.setItem(domain, res));
  }
  return res;
};
out$.get_favicon_data_for_domain = get_favicon_data_for_domain = async function(domain){
  var output, e, canonical_domain;
  try {
    output = (await get_png_data_for_url(domain));
  } catch (e$) {
    e = e$;
  }
  if (output != null) {
    return output;
  }
  canonical_domain = (await get_canonical_domain(domain));
  if (domain !== canonical_domain) {
    try {
      output = (await get_png_data_for_url(canonical_domain));
    } catch (e$) {
      e = e$;
    }
    if (output != null) {
      return output;
    }
  }
  try {
    output = (await get_favicon_data_for_url(domain));
  } catch (e$) {
    e = e$;
  }
  if (output != null) {
    return output;
  }
  if (domain !== canonical_domain) {
    try {
      output = (await get_favicon_data_for_url(canonical_domain));
    } catch (e$) {
      e = e$;
    }
    if (output != null) {
      return output;
    }
  }
};
out$.get_favicon_data_for_domains_bulk = get_favicon_data_for_domains_bulk = async function(domain_list){
  var output, favicon_promises_list, i$, len$, domain, favicon_list, idx, favicon;
  output = {};
  favicon_promises_list = [];
  for (i$ = 0, len$ = domain_list.length; i$ < len$; ++i$) {
    domain = domain_list[i$];
    favicon_promises_list.push(get_favicon_data_for_domain(domain));
  }
  favicon_list = (await Promise.all(favicon_promises_list));
  for (i$ = 0, len$ = domain_list.length; i$ < len$; ++i$) {
    idx = i$;
    domain = domain_list[i$];
    favicon = favicon_list[idx];
    output[domain] = favicon;
  }
  return output;
};
gexport_module('favicon_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=favicon_utils.ls.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/libs_backend/fetch_page_utils.ls":
/*!**********************************************!*\
  !*** ./src/libs_backend/fetch_page_utils.ls ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeSingleAsync, fetch_page_text, out$ =  true && exports || this;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
out$.fetch_page_text = fetch_page_text = async function(url){
  var page_request, page_text;
  page_request = (await fetch(url, {
    credentials: 'include'
  }));
  page_text = (await page_request.text());
  return page_text;
};
/*
export fetch_and_parse_page = (url) ->>
  page_text = await fetch_page_text(url)
  cheerio = await get_cheerio()
  $ = cheerio.load(page_text)
  return $
*/
//# sourceMappingURL=fetch_page_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/gamification_utils.ls":
/*!************************************************!*\
  !*** ./src/libs_backend/gamification_utils.ls ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, getvar, addtovar, clearvar, getkey_dict, addtokey_dict, addtokey_dictdict, cleardict, get_timesaved_badge_that_should_be_awarded, localstorage_getjson, get_intervention_level, get_num_times_intervention_used, get_time_saved_total, get_time_saved_total_for_domain, get_time_saved_total_with_intervention, baseline_time_per_session_for_domain, record_seconds_saved_and_get_rewards, add_seconds_saved_with_intervention_on_domain, clear_times_intervention_used, clear_seconds_saved, clear_gamification_data, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
ref$ = __webpack_require__(/*! libs_common/db_utils */ "./src/libs_backend/db_utils.ls"), getvar = ref$.getvar, addtovar = ref$.addtovar, clearvar = ref$.clearvar, getkey_dict = ref$.getkey_dict, addtokey_dict = ref$.addtokey_dict, addtokey_dictdict = ref$.addtokey_dictdict, cleardict = ref$.cleardict;
get_timesaved_badge_that_should_be_awarded = __webpack_require__(/*! libs_common/badges_utils */ "./src/libs_common/badges_utils.ls").get_timesaved_badge_that_should_be_awarded;
localstorage_getjson = __webpack_require__(/*! libs_common/localstorage_utils */ "./src/libs_common/localstorage_utils.ls").localstorage_getjson;
out$.get_intervention_level = get_intervention_level = async function(intervention_name){
  var times_used;
  times_used = get_num_times_intervention_used(intervention_name);
  if (times_used >= 10) {
    return 1;
  }
  return 0;
};
out$.get_num_times_intervention_used = get_num_times_intervention_used = async function(intervention_name){
  var result;
  result = (await getkey_dict('times_intervention_used', intervention_name));
  return result != null ? result : 0;
};
out$.get_time_saved_total = get_time_saved_total = async function(){
  var result;
  result = (await getvar('seconds_saved_total'));
  return result != null ? result : 0;
};
out$.get_time_saved_total_for_domain = get_time_saved_total_for_domain = async function(domain){
  var result;
  result = (await getkey_dict('seconds_saved_for_domain', domain));
  return result != null ? result : 0;
};
out$.get_time_saved_total_with_intervention = get_time_saved_total_with_intervention = async function(intervention_name){
  var result;
  result = (await getkey_dict('seconds_saved_for_intervention', intervention_name));
  return result != null ? result : 0;
};
out$.baseline_time_per_session_for_domain = baseline_time_per_session_for_domain = async function(domain){
  var result;
  result = (await getkey_dict('baseline_session_time_on_domains', domain));
  return result != null ? result : 300;
};
out$.record_seconds_saved_and_get_rewards = record_seconds_saved_and_get_rewards = async function(seconds, intervention_name, domain){
  var rewards, add_times_used_reward, add_seconds_saved_total_reward, times_used, seconds_saved_prev, seconds_saved;
  rewards = [];
  add_times_used_reward = function(times_used, times_used_prev){
    if (times_used === 10) {
      return rewards.push({
        type: 'intervention_mastered',
        intervention_name: intervention_name
      });
    }
  };
  add_seconds_saved_total_reward = function(seconds_saved, seconds_saved_prev){
    var timesaved_badge;
    timesaved_badge = get_timesaved_badge_that_should_be_awarded(seconds_saved, seconds_saved_prev);
    if (timesaved_badge != null) {
      return rewards.push(timesaved_badge);
    }
  };
  times_used = (await addtokey_dict('times_intervention_used', intervention_name, 1));
  seconds_saved_prev = (await get_time_saved_total());
  seconds_saved = (await addtovar('seconds_saved_total', seconds));
  add_seconds_saved_total_reward(seconds_saved, seconds_saved_prev);
  (await addtokey_dict('seconds_saved_for_intervention', intervention_name, seconds));
  (await addtokey_dict('seconds_saved_for_domain', domain, seconds));
  (await addtokey_dictdict('seconds_saved_for_intervention_on_domain', intervention_name, domain, seconds));
  return rewards;
};
out$.add_seconds_saved_with_intervention_on_domain = add_seconds_saved_with_intervention_on_domain = async function(seconds, intervention_name, domain){
  (await addtokey_dict('times_intervention_used', intervention_name, 1));
  (await addtovar('seconds_saved_total', seconds));
  (await addtokey_dict('seconds_saved_for_intervention', intervention_name, seconds));
  (await addtokey_dict('seconds_saved_for_domain', domain, seconds));
  (await addtokey_dictdict('seconds_saved_for_intervention_on_domain', intervention_name, domain, seconds));
};
out$.clear_times_intervention_used = clear_times_intervention_used = async function(){
  (await cleardict('times_intervention_used'));
};
out$.clear_seconds_saved = clear_seconds_saved = async function(){
  (await clearvar('seconds_saved_total'));
  (await cleardict('seconds_saved_for_intervention'));
  (await cleardict('seconds_saved_for_domain'));
  (await cleardict('seconds_saved_for_intervention_on_domain'));
};
out$.clear_gamification_data = clear_gamification_data = async function(){
  (await clear_times_intervention_used());
  (await clear_seconds_saved());
};
gexport_module('gamification_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=gamification_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/goal_progress.ls":
/*!*******************************************!*\
  !*** ./src/libs_backend/goal_progress.ls ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeSingleAsync, ref$, gexport, gexport_module, as_array, measurement_functions, measurement_functions_generated, get_progress_measurement_functions, get_progress_measurement_function_for_goal_name, get_progress_on_goal_today, get_whether_goal_achieved_today, get_whether_goal_achieved_days_before_today, get_progress_on_goal_this_week, get_progress_on_enabled_goals_today, get_progress_on_goal_days_before_today, get_num_goals_met_today, get_num_goals_met_yesterday, get_num_goals_met_days_before_today, get_num_goals_met_this_week, get_progress_on_enabled_goals_days_before_today, get_progress_on_enabled_goals_this_week, intervention_manager, goal_utils, out$ =  true && exports || this;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
as_array = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls").as_array;
measurement_functions = __webpack_require__(/*! goals/progress_measurement */ "./src/goals/progress_measurement.ls");
measurement_functions_generated = __webpack_require__(/*! goals/progress_measurement_generated */ "./src/goals/progress_measurement_generated.ls");
out$.get_progress_measurement_functions = get_progress_measurement_functions = async function(){
  var output, goals, goal_name, goal_info, measurement_function;
  output = {};
  goals = (await goal_utils.get_goals());
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    if (goal_info.measurement != null) {
      measurement_function = measurement_functions[goal_info.measurement];
      if (measurement_function != null) {
        output[goal_name] = measurement_function(goal_info);
        continue;
      }
    }
    measurement_function = measurement_functions_generated[goal_name];
    if (measurement_function != null) {
      output[goal_name] = measurement_function(goal_info);
      continue;
    }
    console.log("no measurement found for goal " + goal_name);
  }
  return output;
};
out$.get_progress_measurement_function_for_goal_name = get_progress_measurement_function_for_goal_name = async function(goal_name){
  var progress_measurement_functions;
  progress_measurement_functions = (await get_progress_measurement_functions());
  return progress_measurement_functions[goal_name];
};
out$.get_progress_on_goal_today = get_progress_on_goal_today = async function(goal_name){
  return (await get_progress_on_goal_days_before_today(goal_name, 0));
};
out$.get_whether_goal_achieved_today = get_whether_goal_achieved_today = async function(goal_name){
  return (await get_whether_goal_achieved_days_before_today(goal_name, 0));
};
out$.get_whether_goal_achieved_days_before_today = get_whether_goal_achieved_days_before_today = async function(goal_name, days_before_today){
  var goal_targets, progress_info, goal_target, goal_info;
  goal_targets = (await goal_utils.get_all_goal_targets());
  progress_info = (await get_progress_on_goal_days_before_today(goal_name, days_before_today));
  goal_target = goal_targets[goal_name];
  goal_info = (await goal_utils.get_goal_info(goal_name));
  return progress_info.progress >= goal_target === goal_info.is_positive;
};
out$.get_progress_on_goal_this_week = get_progress_on_goal_this_week = async function(goal_name){
  var results, i$, days_before_today, progress_info;
  results = [];
  for (i$ = 0; i$ <= 6; ++i$) {
    days_before_today = i$;
    progress_info = (await get_progress_on_goal_days_before_today(goal_name, days_before_today));
    results.push(progress_info);
  }
  return results;
};
out$.get_progress_on_enabled_goals_today = get_progress_on_enabled_goals_today = async function(){
  return (await get_progress_on_enabled_goals_days_before_today(0));
};
out$.get_progress_on_goal_days_before_today = get_progress_on_goal_days_before_today = async function(goal_name, days_before_today){
  var goal_measurement_function;
  goal_measurement_function = (await get_progress_measurement_function_for_goal_name(goal_name));
  if (goal_measurement_function == null) {
    console.log('no goal_measurement_function found for goal');
    console.log(goal_name);
    return;
  }
  return (await goal_measurement_function(days_before_today));
};
out$.get_num_goals_met_today = get_num_goals_met_today = async function(){
  return (await get_num_goals_met_days_before_today(0));
};
out$.get_num_goals_met_yesterday = get_num_goals_met_yesterday = async function(){
  return (await get_num_goals_met_days_before_today(1));
};
out$.get_num_goals_met_days_before_today = get_num_goals_met_days_before_today = async function(days_before_today){
  var enabled_goals, goal_targets, num_goals_met, i$, ref$, len$, goal_name;
  enabled_goals = (await goal_utils.get_enabled_goals());
  goal_targets = (await goal_utils.get_all_goal_targets());
  num_goals_met = 0;
  for (i$ = 0, len$ = (ref$ = as_array(enabled_goals)).length; i$ < len$; ++i$) {
    goal_name = ref$[i$];
    if (get_whether_goal_achieved_days_before_today(goal_name, days_before_today)) {
      num_goals_met += 1;
    }
  }
  return num_goals_met;
};
out$.get_num_goals_met_this_week = get_num_goals_met_this_week = async function(){
  var enabled_goals, goal_targets, days_before_today_to_num_goals_met, i$, days_before_today, num_goals_met, j$, ref$, len$, goal_name, progress_info, goal_target, goal_info;
  enabled_goals = (await goal_utils.get_enabled_goals());
  goal_targets = (await goal_utils.get_all_goal_targets());
  days_before_today_to_num_goals_met = [0, 0, 0, 0, 0, 0, 0];
  for (i$ = 0; i$ <= 6; ++i$) {
    days_before_today = i$;
    num_goals_met = 0;
    for (j$ = 0, len$ = (ref$ = as_array(enabled_goals)).length; j$ < len$; ++j$) {
      goal_name = ref$[j$];
      progress_info = (await get_progress_on_goal_days_before_today(goal_name, days_before_today));
      goal_target = goal_targets[goal_name];
      goal_info = (await goal_utils.get_goal_info(goal_name));
      if (goal_info.is_positive) {
        if (progress_info.progress > goal_target) {
          num_goals_met += 1;
        }
      } else {
        if (progress_info.progress < goal_target) {
          num_goals_met += 1;
        }
      }
    }
    days_before_today_to_num_goals_met[days_before_today] = num_goals_met;
  }
  return days_before_today_to_num_goals_met;
};
out$.get_progress_on_enabled_goals_days_before_today = get_progress_on_enabled_goals_days_before_today = async function(days_before_today){
  var enabled_goals, enabled_goals_list, output, i$, len$, goal_name, progress_info;
  enabled_goals = (await goal_utils.get_enabled_goals());
  enabled_goals_list = as_array(enabled_goals);
  output = {};
  for (i$ = 0, len$ = enabled_goals_list.length; i$ < len$; ++i$) {
    goal_name = enabled_goals_list[i$];
    progress_info = (await get_progress_on_goal_days_before_today(goal_name, days_before_today));
    output[goal_name] = progress_info;
  }
  return output;
};
/**
 * Gets the goal progress info on each enabled goal this week.
 * @return {Promise.<Object.<string, Array.<GoalProgressInfo>>>} Object mapping goal names to an array of goal progress info objects, one for each of the past 7 days (index 0=today, 1=yesterday, etc)
 */
out$.get_progress_on_enabled_goals_this_week = get_progress_on_enabled_goals_this_week = async function(){
  var enabled_goals, enabled_goals_list, output, i$, len$, goal_name, progress_this_week;
  enabled_goals = (await goal_utils.get_enabled_goals());
  enabled_goals_list = as_array(enabled_goals);
  output = {};
  for (i$ = 0, len$ = enabled_goals_list.length; i$ < len$; ++i$) {
    goal_name = enabled_goals_list[i$];
    progress_this_week = (await get_progress_on_goal_this_week(goal_name));
    output[goal_name] = progress_this_week;
  }
  return output;
};
intervention_manager = __webpack_require__(/*! libs_backend/intervention_manager */ "./src/libs_backend/intervention_manager.ls");
goal_utils = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls");
gexport_module('goal_progress', function(it){
  return eval(it);
});
//# sourceMappingURL=goal_progress.ls.map


/***/ }),

/***/ "./src/libs_backend/goal_utils.ls":
/*!****************************************!*\
  !*** ./src/libs_backend/goal_utils.ls ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeSingleAsync, ref$, gexport, gexport_module, getkey_dict, setkey_dict, getdict, url_to_domain, as_array, remove_key_from_localstorage_dict, remove_item_from_localstorage_list, unique_concat, localget_json, remove_cached_favicon_for_domain, moment, getAllInterventionsGoalInfo, get_num_enabled_goals, list_enabled_goals, default_goals_list, get_enabled_goals, set_enabled_goals, set_goal_enabled_manual, set_goals_enabled, set_default_goals_enabled, set_goal_enabled, set_goal_disabled_manual, set_goals_disabled, set_goal_disabled, is_goal_enabled, site_has_enabled_spend_less_time_goal, get_goal_intervention_info, list_all_goals, clear_cache_list_all_goals, get_site_to_goals_sync, get_site_to_goals, list_goals_for_location, list_nonpositive_goals_for_location, list_goals_for_site, list_sites_for_which_goals_are_enabled, list_site_info_for_sites_for_which_goals_are_enabled, get_goal_info, get_goals, get_unproductive_domains_set, is_domain_unproductive, get_positive_enabled_goals, cached_domains_suggested_as_goal, get_have_suggested_domain_as_goal, remove_have_suggested_domain_as_goal, record_have_suggested_domain_as_goal, accept_domain_as_goal_and_record, reject_domain_as_goal_and_record, get_positive_enabled_uncompleted_goals, get_random_positive_goal, get_random_uncompleted_positive_goal, get_random_value_from_object, get_spend_more_time_goals, clear_cache_get_goals, clear_cache_all_goals, make_goal_frequency_info, get_is_goal_frequent_from_frequency_info, get_is_goal_frequent, add_custom_goal_info, add_custom_goal_reduce_time_on_domain, get_goal_statement, add_custom_goal_involving_time_on_domain, get_spend_less_time_goals_for_domain, get_spend_more_time_goals_for_domain, add_enable_custom_goal_reduce_time_on_domain, add_enable_custom_goal_increase_time_on_domain, disable_all_custom_goals, remove_all_custom_goals_and_interventions, remove_all_custom_goals, remove_custom_goal_and_generated_interventions, get_interventions_to_goals, get_goals_for_intervention, get_goal_target, set_goal_target, get_all_goal_targets, list_goal_info_for_enabled_goals, intervention_utils, log_utils, goal_progress, out$ =  true && exports || this;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), getkey_dict = ref$.getkey_dict, setkey_dict = ref$.setkey_dict, getdict = ref$.getdict;
url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
ref$ = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls"), as_array = ref$.as_array, remove_key_from_localstorage_dict = ref$.remove_key_from_localstorage_dict, remove_item_from_localstorage_list = ref$.remove_item_from_localstorage_list;
unique_concat = __webpack_require__(/*! libs_common/array_utils */ "./src/libs_common/array_utils.ls").unique_concat;
localget_json = __webpack_require__(/*! libs_common/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls").localget_json;
remove_cached_favicon_for_domain = __webpack_require__(/*! libs_backend/favicon_utils */ "./src/libs_backend/favicon_utils.ls").remove_cached_favicon_for_domain;
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
getAllInterventionsGoalInfo = async function(){
  var goal_info, all_interventions;
  goal_info = {
    name: 'debug/all_interventions',
    sitename: 'debug',
    description: 'This goal is satisfied by all interventions',
    measurement: 'always_zero_progress'
  };
  all_interventions = (await intervention_utils.list_all_interventions());
  goal_info.interventions = all_interventions;
  return goal_info;
};
/*
cached_get_goal_info_unmodified = {}

export getGoalInfo = (goal_name) ->>
  if goal_name == 'debug/all_interventions'
    return await getAllInterventionsGoalInfo()
  cached_goal_info = cached_get_goal_info_unmodified[goal_name]
  if cached_goal_info?
    return cached_goal_info
  goal_info = await localget_json("/goals/#{goal_name}/info.json")
  goal_info.name = goal_name
  if not goal_info.sitename?
    goal_info.sitename = goal_name.split('/')[0]
  if not goal_info.sitename_printable?
    goal_info.sitename_printable = goal_info.sitename.substr(0, 1).toUpperCase() + goal_info.sitename.substr(1)
  if not goal_info.homepage?
    goal_info.homepage = "https://www.#{goal_info.sitename}.com/"
  cached_get_goal_info_unmodified[goal_name] = goal_info
  return goal_info
*/
out$.get_num_enabled_goals = get_num_enabled_goals = async function(){
  var enabled_goals;
  enabled_goals = (await get_enabled_goals());
  return as_array(enabled_goals).length;
};
/**
 * Returns a list of names of enabled goals
 * @return {Promise.<Array.<GoalName>>} List of enabled goal names
 */
out$.list_enabled_goals = list_enabled_goals = async function(){
  var enabled_goals;
  enabled_goals = (await get_enabled_goals());
  return as_array(enabled_goals);
};
default_goals_list = ['facebook/spend_less_time', 'youtube/spend_less_time'];
/**
 * Returns a object with with names of enabled goals as keys, and whether they are enabled as values
 * @return {Promise.<Object.<GoalName, boolean>>} Object with enabled goals as keys
 */
out$.get_enabled_goals = get_enabled_goals = async function(){
  var all_goals, enabled_goals_str, enabled_goals, i$, ref$, len$, default_goal_name, k, v;
  all_goals = (await get_goals());
  enabled_goals_str = localStorage.getItem('enabled_goals');
  enabled_goals = {};
  if (enabled_goals_str == null) {
    for (i$ = 0, len$ = (ref$ = default_goals_list).length; i$ < len$; ++i$) {
      default_goal_name = ref$[i$];
      if (all_goals[default_goal_name] == null) {
        continue;
      }
      enabled_goals[default_goal_name] = true;
    }
  } else {
    for (k in ref$ = JSON.parse(enabled_goals_str)) {
      v = ref$[k];
      if (all_goals[k] == null) {
        continue;
      }
      enabled_goals[k] = v;
    }
    if (enabled_goals['debug/all_interventions']) {
      if (localStorage.getItem('intervention_view_show_debug_all_interventions_goal') !== 'true') {
        delete enabled_goals['debug/all_interventions'];
        localStorage.setItem('enabled_goals', JSON.stringify(enabled_goals));
      }
    }
  }
  return enabled_goals;
};
out$.set_enabled_goals = set_enabled_goals = async function(enabled_goals){
  localStorage.setItem('enabled_goals', JSON.stringify(enabled_goals));
};
out$.set_goal_enabled_manual = set_goal_enabled_manual = async function(goal_name){
  var enabled_goals, prev_enabled_goals;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  if (enabled_goals[goal_name] != null) {
    return;
  }
  enabled_goals[goal_name] = true;
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goal_enabled',
    manual: true,
    goal_name: goal_name,
    prev_enabled_goals: prev_enabled_goals,
    enabled_goals: enabled_goals
  });
};
out$.set_goals_enabled = set_goals_enabled = async function(goal_list){
  var enabled_goals, prev_enabled_goals, i$, len$, goal_name;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  for (i$ = 0, len$ = goal_list.length; i$ < len$; ++i$) {
    goal_name = goal_list[i$];
    if (enabled_goals[goal_name] != null) {
      continue;
    }
    enabled_goals[goal_name] = true;
  }
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goals_enabled',
    manual: false,
    goal_list: goal_list,
    prev_enabled_goals: prev_enabled_goals
  });
};
out$.set_default_goals_enabled = set_default_goals_enabled = async function(){
  return (await set_goals_enabled(default_goals_list));
};
out$.set_goal_enabled = set_goal_enabled = async function(goal_name){
  var enabled_goals, prev_enabled_goals;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  if (enabled_goals[goal_name] != null) {
    return;
  }
  enabled_goals[goal_name] = true;
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goal_enabled',
    manual: false,
    goal_name: goal_name,
    prev_enabled_goals: prev_enabled_goals
  });
};
out$.set_goal_disabled_manual = set_goal_disabled_manual = async function(goal_name){
  var enabled_goals, prev_enabled_goals;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  if (enabled_goals[goal_name] == null) {
    return;
  }
  delete enabled_goals[goal_name];
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goal_disabled',
    manual: true,
    goal_name: goal_name,
    prev_enabled_goals: prev_enabled_goals
  });
};
out$.set_goals_disabled = set_goals_disabled = async function(goal_list){
  var enabled_goals, prev_enabled_goals, i$, len$, goal_name;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  for (i$ = 0, len$ = goal_list.length; i$ < len$; ++i$) {
    goal_name = goal_list[i$];
    if (enabled_goals[goal_name] == null) {
      continue;
    }
    delete enabled_goals[goal_name];
  }
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goals_disabled',
    manual: false,
    goal_list: goal_list,
    prev_enabled_goals: prev_enabled_goals
  });
};
out$.set_goal_disabled = set_goal_disabled = async function(goal_name){
  var enabled_goals, prev_enabled_goals;
  enabled_goals = (await get_enabled_goals());
  prev_enabled_goals = import$({}, enabled_goals);
  if (enabled_goals[goal_name] == null) {
    return;
  }
  delete enabled_goals[goal_name];
  (await set_enabled_goals(enabled_goals));
  return log_utils.add_log_goals({
    type: 'goal_disabled',
    manual: false,
    goal_name: goal_name,
    prev_enabled_goals: prev_enabled_goals
  });
};
out$.is_goal_enabled = is_goal_enabled = async function(goal_name){
  var enabled_goals;
  enabled_goals = (await get_enabled_goals());
  return enabled_goals[goal_name] != null;
};
out$.site_has_enabled_spend_less_time_goal = site_has_enabled_spend_less_time_goal = async function(domain){
  var goals, goal_name, goal_info;
  goals = (await get_goals());
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    if (domain === goal_info.domain && !goal_info.is_positive) {
      return (await is_goal_enabled(goal_name));
    }
  }
  return false;
};
out$.get_goal_intervention_info = get_goal_intervention_info = memoizeSingleAsync(async function(){
  return (await localget_json('/goal_intervention_info.json'));
});
/**
 * Lists names of all available goals
 * @return {Promise.<Array.<GoalName>>} List of goal names.
 */
out$.list_all_goals = list_all_goals = async function(){
  var cached_list_all_goals, goals_list, extra_list_all_goals_text, extra_list_all_goals, this$ = this;
  cached_list_all_goals = localStorage.getItem('cached_list_all_goals');
  if (cached_list_all_goals != null) {
    return JSON.parse(cached_list_all_goals);
  }
  goals_list = (await get_goal_intervention_info()).goals.map(function(it){
    return it.name;
  });
  extra_list_all_goals_text = localStorage.getItem('extra_list_all_goals');
  if (extra_list_all_goals_text != null) {
    extra_list_all_goals = JSON.parse(extra_list_all_goals_text);
    goals_list = unique_concat(goals_list, extra_list_all_goals);
  }
  localStorage.setItem('cached_list_all_goals', JSON.stringify(goals_list));
  return goals_list;
};
out$.clear_cache_list_all_goals = clear_cache_list_all_goals = function(){
  localStorage.removeItem('cached_list_all_goals');
};
get_site_to_goals_sync = function(goals){
  var output, goal_name, goal_info, sitename;
  output = {};
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    sitename = goal_info.sitename;
    if (output[sitename] == null) {
      output[sitename] = [];
    }
    output[sitename].push(goal_info);
  }
  return output;
};
get_site_to_goals = async function(){
  var goals;
  goals = (await get_goals());
  return get_site_to_goals_sync(goals);
};
out$.list_goals_for_location = list_goals_for_location = async function(domain){
  var all_goals, output, goal_name, goal_info;
  all_goals = (await get_goals());
  output = [];
  for (goal_name in all_goals) {
    goal_info = all_goals[goal_name];
    if (domain.indexOf(goal_info.domain) !== -1) {
      output.push(goal_name);
    }
  }
  return output;
};
out$.list_nonpositive_goals_for_location = list_nonpositive_goals_for_location = async function(domain){
  var all_goals, output, goal_name, goal_info;
  all_goals = (await get_goals());
  output = [];
  for (goal_name in all_goals) {
    goal_info = all_goals[goal_name];
    if (goal_info.is_positive) {
      continue;
    }
    if (domain.indexOf(goal_info.domain) !== -1) {
      output.push(goal_name);
    }
  }
  return output;
};
out$.list_goals_for_site = list_goals_for_site = async function(sitename){
  var site_to_goals;
  site_to_goals = (await get_site_to_goals());
  return site_to_goals[sitename];
};
out$.list_sites_for_which_goals_are_enabled = list_sites_for_which_goals_are_enabled = async function(){
  var goals, enabled_goals, output, output_set, goal_name, goal_info, sitename;
  goals = (await get_goals());
  enabled_goals = (await get_enabled_goals());
  output = [];
  output_set = {};
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    sitename = goal_info.sitename;
    if (enabled_goals[goal_name] != null && output_set[sitename] == null) {
      output.push(sitename);
      output_set[sitename] = true;
    }
  }
  return output;
};
out$.list_site_info_for_sites_for_which_goals_are_enabled = list_site_info_for_sites_for_which_goals_are_enabled = async function(){
  var goals, enabled_goals, site_to_goals, output, output_set, goal_name, goal_info, sitename, this$ = this;
  goals = (await get_goals());
  enabled_goals = (await get_enabled_goals());
  site_to_goals = get_site_to_goals_sync(goals);
  output = [];
  output_set = {};
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    sitename = goal_info.sitename;
    if (enabled_goals[goal_name] != null && output_set[sitename] == null) {
      output.push({
        sitename: sitename,
        sitename_printable: goal_info.sitename_printable,
        goals: site_to_goals[sitename],
        goal_names: site_to_goals[sitename].map(fn$)
      });
      output_set[sitename] = true;
    }
  }
  return output;
  function fn$(it){
    return it.name;
  }
};
/**
 * Gets the goal info for the specified goal name
 * @param {GoalName} goal_name - The name of the goal
 * @return {Promise.<GoalInfo>} The goal info
 */
out$.get_goal_info = get_goal_info = async function(goal_name){
  var goals;
  goals = (await get_goals());
  return goals[goal_name];
};
/*
export get_goals = ->>
  #if local_cached_get_goals?
  #  return local_cached_get_goals
  cached_get_goals = localStorage.getItem 'cached_get_goals'
  if cached_get_goals?
    return JSON.parse cached_get_goals
    #local_cached_get_goals := JSON.parse cached_get_goals
    #return local_cached_get_goals
  goals_list = await list_all_goals()
  output = {}
  extra_get_goals_text = localStorage.getItem 'extra_get_goals'
  if extra_get_goals_text?
    extra_get_goals = JSON.parse extra_get_goals_text
    for k,v of extra_get_goals
      output[k] = v
  goal_name_to_info_promises = {[goal_name, getGoalInfo(goal_name)] for goal_name in goals_list when not output[goal_name]?}
  goal_info_dict = await goal_name_to_info_promises
  for k,v of goal_info_dict
    output[k] = v
  localStorage.setItem 'cached_get_goals', JSON.stringify(output)
  #local_cached_get_goals := output
  return output
*/
/**
 * Gets the goal info for all goals, in the form of an object mapping goal names to goal info
 * @return {Promise.<Object.<GoalName, GoalInfo>>} Object mapping goal names to goal info
 */
out$.get_goals = get_goals = async function(){
  var cached_get_goals, output, goal_name, goal_info, goal_info_list, i$, len$, extra_get_goals_text, extra_get_goals, k, v, extra_get_interventions_text, goal_name_to_intervention_name_set, extra_get_interventions, intervention_name, intervention_info, ref$, intervention_name_set, res$, j$, ref1$, len1$, existing_intervention_name;
  cached_get_goals = localStorage.getItem('cached_get_goals');
  if (cached_get_goals != null) {
    output = JSON.parse(cached_get_goals);
    for (goal_name in output) {
      goal_info = output[goal_name];
      if (goal_info.icon === 'icon.png' || goal_info.icon === 'icon.svg' || goal_info.icon === 'icon.jpg') {
        goal_info.icon = chrome.runtime.getURL('goals/' + goal_name + '/' + goal_info.icon);
      }
    }
    return output;
  }
  goal_info_list = JSON.parse(JSON.stringify((await get_goal_intervention_info()).goals));
  output = {};
  for (i$ = 0, len$ = goal_info_list.length; i$ < len$; ++i$) {
    goal_info = goal_info_list[i$];
    output[goal_info.name] = goal_info;
  }
  extra_get_goals_text = localStorage.getItem('extra_get_goals');
  if (extra_get_goals_text != null) {
    extra_get_goals = JSON.parse(extra_get_goals_text);
    for (k in extra_get_goals) {
      v = extra_get_goals[k];
      output[k] = v;
    }
  }
  extra_get_interventions_text = localStorage.getItem('extra_get_interventions');
  goal_name_to_intervention_name_set = {};
  if (extra_get_interventions_text != null) {
    extra_get_interventions = JSON.parse(extra_get_interventions_text);
    for (intervention_name in extra_get_interventions) {
      intervention_info = extra_get_interventions[intervention_name];
      if (!intervention_info.custom) {
        continue;
      }
      for (i$ = 0, len$ = (ref$ = intervention_info.goals).length; i$ < len$; ++i$) {
        goal_name = ref$[i$];
        goal_info = output[goal_name];
        if (goal_info == null) {
          continue;
        }
        intervention_name_set = goal_name_to_intervention_name_set[goal_name];
        if (intervention_name_set == null) {
          res$ = {};
          for (j$ = 0, len1$ = (ref1$ = goal_info.interventions).length; j$ < len1$; ++j$) {
            existing_intervention_name = ref1$[j$];
            res$[existing_intervention_name] = true;
          }
          intervention_name_set = res$;
          goal_name_to_intervention_name_set[goal_name] = intervention_name_set;
        }
        if (intervention_name_set[intervention_name]) {
          continue;
        }
        intervention_name_set[intervention_name] = true;
        goal_info.interventions.push(intervention_name);
      }
    }
  }
  localStorage.setItem('cached_get_goals', JSON.stringify(output));
  for (goal_name in output) {
    goal_info = output[goal_name];
    if (goal_info.icon === 'icon.png' || goal_info.icon === 'icon.svg' || goal_info.icon === 'icon.jpg') {
      goal_info.icon = chrome.runtime.getURL('goals/' + goal_name + '/' + goal_info.icon);
    }
  }
  return output;
};
out$.get_unproductive_domains_set = get_unproductive_domains_set = memoizeSingleAsync(async function(){
  var unproductive_domains_list, unproductive_domains_set, i$, len$, x, this$ = this;
  unproductive_domains_list = (await fetch('/unproductive_domains.json').then(function(it){
    return it.json();
  }));
  unproductive_domains_set = new Set();
  for (i$ = 0, len$ = unproductive_domains_list.length; i$ < len$; ++i$) {
    x = unproductive_domains_list[i$];
    unproductive_domains_set.add(x);
  }
  return unproductive_domains_set;
});
out$.is_domain_unproductive = is_domain_unproductive = async function(domain){
  var unproductive_domains_set;
  unproductive_domains_set = (await get_unproductive_domains_set());
  if (unproductive_domains_set.has(domain)) {
    return true;
  }
  return false;
};
/**
 * Gets the goal info for all goals where is_positive set to true, in the form of an object mapping goal names to goal info
 * @return {Promise.<Object.<GoalName, GoalInfo>>} Object mapping goal names to goal info
 */
out$.get_positive_enabled_goals = get_positive_enabled_goals = async function(){
  var goalToInfoMap, enabled_goals, output, goal, goal_info;
  goalToInfoMap = (await get_goals());
  enabled_goals = (await get_enabled_goals());
  output = {};
  for (goal in goalToInfoMap) {
    goal_info = goalToInfoMap[goal];
    if (enabled_goals[goal] && goal_info.is_positive) {
      output[goal] = goal_info;
    }
  }
  return output;
};
cached_domains_suggested_as_goal = {};
out$.get_have_suggested_domain_as_goal = get_have_suggested_domain_as_goal = async function(domain){
  var has_been_suggested;
  if (cached_domains_suggested_as_goal[domain] != null) {
    return cached_domains_suggested_as_goal[domain];
  }
  has_been_suggested = (await getkey_dict('domains_suggested_as_goals', domain));
  cached_domains_suggested_as_goal[domain] = has_been_suggested;
  return has_been_suggested;
};
out$.remove_have_suggested_domain_as_goal = remove_have_suggested_domain_as_goal = async function(domain){
  cached_domains_suggested_as_goal[domain] = false;
  (await setkey_dict('domains_suggested_as_goals', domain, false));
};
out$.record_have_suggested_domain_as_goal = record_have_suggested_domain_as_goal = async function(domain){
  cached_domains_suggested_as_goal[domain] = true;
  (await setkey_dict('domains_suggested_as_goals', domain, true));
};
out$.accept_domain_as_goal_and_record = accept_domain_as_goal_and_record = async function(domain){
  (await record_have_suggested_domain_as_goal(domain));
  (await log_utils.log_goal_suggestion_action({
    'action': 'accepted',
    'accepted': 'true',
    'goal_type': 'spend_less_time',
    'domain': domain
  }));
  (await add_enable_custom_goal_reduce_time_on_domain(domain));
  /*
  await record_have_suggested_domain_as_goal(window.location.host)
  await log_goal_suggestion_action({'action': 'accepted', 'accepted': 'true', 'type': 'spend_less_time', 'domain': window.location.host})
  await add_enable_custom_goal_reduce_time_on_domain(window.location.host)
  */
};
out$.reject_domain_as_goal_and_record = reject_domain_as_goal_and_record = async function(domain){
  (await record_have_suggested_domain_as_goal(domain));
  (await log_utils.log_goal_suggestion_action({
    'action': 'rejected',
    'accepted': 'false',
    'goal_type': 'spend_less_time',
    'domain': domain
  }));
  /*
  await record_have_suggested_domain_as_goal(window.location.host)
  await log_goal_suggestion_action({'action': 'rejected', 'accepted': 'false', 'type': 'spend_less_time', 'domain': window.location.host})
  */
};
/**
 * Gets the goal info for all goals where is_positive set to true and that have not yet been completed
 * @return {Promise.<Object.<GoalName, GoalInfo>>} Object mapping goal names to goal info
 */
out$.get_positive_enabled_uncompleted_goals = get_positive_enabled_uncompleted_goals = async function(){
  var goals, output, completed_promises_list, goal_list, i$, len$, goal_name, completed_list, idx, completed, goal_info;
  goals = (await get_positive_enabled_goals());
  output = {};
  completed_promises_list = [];
  goal_list = Object.keys(goals);
  for (i$ = 0, len$ = goal_list.length; i$ < len$; ++i$) {
    goal_name = goal_list[i$];
    completed_promises_list.push(goal_progress.get_whether_goal_achieved_today(goal_name));
  }
  completed_list = (await Promise.all(completed_promises_list));
  for (i$ = 0, len$ = goal_list.length; i$ < len$; ++i$) {
    idx = i$;
    goal_name = goal_list[i$];
    completed = completed_list[idx];
    goal_info = goals[goal_name];
    if (!completed) {
      output[goal_name] = goal_info;
    }
  }
  return output;
};
/**
 * Gets the goal info for a random enabled positive goal
 * @return {GoalInfo} The goal info
 */
out$.get_random_positive_goal = get_random_positive_goal = async function(){
  var goalNameToGoalInfo;
  goalNameToGoalInfo = (await get_positive_enabled_goals());
  return get_random_value_from_object(goalNameToGoalInfo);
};
/**
 * Gets the goal info for a random enabled uncompleted positive goal
 * @return {GoalInfo} The goal info
 */
out$.get_random_uncompleted_positive_goal = get_random_uncompleted_positive_goal = async function(){
  var goalNameToGoalInfo;
  goalNameToGoalInfo = (await get_positive_enabled_uncompleted_goals());
  console.log(goalNameToGoalInfo);
  return get_random_value_from_object(goalNameToGoalInfo);
};
get_random_value_from_object = function(obj){
  var keyList, randIndex, key;
  keyList = Object.keys(obj);
  if (keyList.length === 0) {
    return null;
  }
  randIndex = Math.floor(Math.random() * keyList.length);
  key = keyList[randIndex];
  return obj[key];
};
/* TODO: Consolidate with get_positive_enabled_goals */
out$.get_spend_more_time_goals = get_spend_more_time_goals = async function(){
  var goals, spendMoreTimeGoals, goal, goalInfo;
  goals = (await get_goals());
  spendMoreTimeGoals = {};
  for (goal in goals) {
    goalInfo = goals[goal];
    if (goalInfo.is_positive) {
      spendMoreTimeGoals[goal] = goalInfo;
    }
  }
  return spendMoreTimeGoals;
};
out$.clear_cache_get_goals = clear_cache_get_goals = function(){
  localStorage.removeItem('cached_get_goals');
};
out$.clear_cache_all_goals = clear_cache_all_goals = function(){
  clear_cache_get_goals();
  clear_cache_list_all_goals();
};
/*
export make_goal_frequency_info = ->
  output = {}
  output.algorithm = 'isoweek_alternating'
  output.onweeks = Math.round(Math.random()) # either 0 or 1
  output.timestamp = Date.now()
  return output
*/
out$.make_goal_frequency_info = make_goal_frequency_info = function(){
  var output, res$, i$, x;
  output = {};
  output.algorithm = 'isoweek_random';
  res$ = [];
  for (i$ = 0; i$ <= 53; ++i$) {
    x = i$;
    res$.push(Math.round(Math.random()));
  }
  output.onweeks = res$;
  output.timestamp = Date.now();
  return output;
};
out$.get_is_goal_frequent_from_frequency_info = get_is_goal_frequent_from_frequency_info = function(goal_frequency_info){
  var algorithm, isoweek, onweeks;
  algorithm = goal_frequency_info.algorithm;
  if (algorithm === 'isoweek_alternating') {
    isoweek = moment().isoWeek();
    onweeks = goal_frequency_info.onweeks;
    return isoweek % 2 === onweeks;
  }
  if (algorithm === 'isoweek_random') {
    isoweek = moment().isoWeek();
    onweeks = goal_frequency_info.onweeks;
    return onweeks[isoweek] === 1;
  }
  throw new Error('goal frequency algorithm not implemented');
};
out$.get_is_goal_frequent = get_is_goal_frequent = async function(goal_name){
  var goal_frequency_info;
  goal_frequency_info = (await getkey_dict('goal_frequencies', goal_name));
  if (goal_frequency_info != null) {
    goal_frequency_info = JSON.parse(goal_frequency_info);
    if (goal_frequency_info.algorithm === 'isoweek_alternating') {
      if (moment().year() === 2018 && moment().isoWeek() > 32) {
        goal_frequency_info = make_goal_frequency_info();
        (await setkey_dict('goal_frequencies', goal_name, JSON.stringify(goal_frequency_info)));
      }
    }
  } else {
    goal_frequency_info = make_goal_frequency_info();
    (await setkey_dict('goal_frequencies', goal_name, JSON.stringify(goal_frequency_info)));
  }
  return get_is_goal_frequent_from_frequency_info(goal_frequency_info);
};
out$.add_custom_goal_info = add_custom_goal_info = async function(goal_info){
  var extra_get_goals_text, extra_get_goals, extra_list_all_goals_text, extra_list_all_goals;
  extra_get_goals_text = localStorage.getItem('extra_get_goals');
  if (extra_get_goals_text != null) {
    extra_get_goals = JSON.parse(extra_get_goals_text);
  } else {
    extra_get_goals = {};
  }
  extra_list_all_goals_text = localStorage.getItem('extra_list_all_goals');
  if (extra_list_all_goals_text != null) {
    extra_list_all_goals = JSON.parse(extra_list_all_goals_text);
  } else {
    extra_list_all_goals = [];
  }
  extra_list_all_goals = unique_concat(extra_list_all_goals, [goal_info.name]);
  extra_get_goals[goal_info.name] = goal_info;
  clear_cache_all_goals();
  localStorage.setItem('extra_list_all_goals', JSON.stringify(extra_list_all_goals));
  localStorage.setItem('extra_get_goals', JSON.stringify(extra_get_goals));
  (await list_all_goals());
  (await get_goals());
};
out$.add_custom_goal_reduce_time_on_domain = add_custom_goal_reduce_time_on_domain = async function(domain){
  (await add_custom_goal_involving_time_on_domain(domain, false));
};
out$.get_goal_statement = get_goal_statement = async function(goal_info){
  var ad_lib, target, unit;
  if (goal_info.goal_statement_to_fill_in != null) {
    ad_lib = goal_info.goal_statement_to_fill_in;
    target = (await get_goal_target(goal_info.name));
    ad_lib = ad_lib.replace("TARGET", target);
    unit = goal_info.target.units;
    if (goal_info.goal_statement_units != null) {
      unit = goal_info.goal_statement_units;
    }
    if (target === 1) {
      unit = unit.substring(0, unit.length - 1);
    }
    return ad_lib.replace("UNITS", unit);
  } else {
    return goal_info.description;
  }
};
out$.add_custom_goal_involving_time_on_domain = add_custom_goal_involving_time_on_domain = async function(domain, isPositive){
  var domain_printable, custom_goal_name, description, goal_statement_to_fill_in, call_to_action, generic_positive_interventions, fix_names_generic_positive, generated_interventions, default_interventions, target_default, generic_interventions, fix_names_generic, fix_names_video, video_interventions, goal_info;
  domain_printable = domain;
  if (domain_printable.startsWith('www.')) {
    domain_printable = domain_printable.substr(4);
  }
  if (isPositive) {
    custom_goal_name = "custom/spend_more_time_" + domain;
    description = "Spend more time on " + domain_printable;
    goal_statement_to_fill_in = "Spend at least TARGET UNITS on " + domain_printable + " each day";
    call_to_action = "Go to " + domain_printable;
    generic_positive_interventions = (await intervention_utils.list_generic_positive_interventions());
    fix_names_generic_positive = function(x){
      return x.replace('generic_positive/', "generated_" + domain + "/");
    };
    generated_interventions = generic_positive_interventions.map(fix_names_generic_positive);
    default_interventions = (await intervention_utils.list_enabled_generic_positive_interventions());
    default_interventions = default_interventions.map(fix_names_generic_positive);
    target_default = 5;
  } else {
    custom_goal_name = "custom/spend_less_time_" + domain;
    description = "Spend less time on " + domain_printable;
    goal_statement_to_fill_in = "Spend less than TARGET UNITS on " + domain_printable + " each day";
    call_to_action = "Close " + domain_printable;
    generic_interventions = (await intervention_utils.list_generic_interventions());
    fix_names_generic = function(x){
      return x.replace('generic/', "generated_" + domain + "/");
    };
    fix_names_video = function(x){
      return x.replace('video/', "generated_" + domain + "/");
    };
    generated_interventions = generic_interventions.map(fix_names_generic);
    default_interventions = (await intervention_utils.list_enabled_generic_interventions());
    default_interventions = default_interventions.map(fix_names_generic);
    if (intervention_utils.is_video_domain(domain)) {
      video_interventions = (await intervention_utils.list_video_interventions());
      generated_interventions = generated_interventions.concat(video_interventions.map(fix_names_video));
    }
    target_default = 20;
  }
  goal_info = {
    name: custom_goal_name,
    custom: true,
    description: description,
    call_to_action: call_to_action,
    homepage: "http://" + domain + "/",
    progress_description: "Time spent on " + domain_printable,
    sitename: domain,
    sitename_printable: domain_printable,
    default_interventions: default_interventions,
    interventions: generated_interventions,
    measurement: 'time_spent_on_domain',
    domain: domain,
    is_positive: isPositive,
    target: {
      'default': target_default,
      units: 'minutes'
    }
  };
  (await add_custom_goal_info(goal_info));
};
out$.get_spend_less_time_goals_for_domain = get_spend_less_time_goals_for_domain = async function(domain){
  var output, all_goals, goal_name, goal_info;
  output = [];
  all_goals = (await get_goals());
  for (goal_name in all_goals) {
    goal_info = all_goals[goal_name];
    if (goal_info.is_positive) {
      continue;
    }
    if (goal_info.domain === domain) {
      output.push(goal_name);
    }
  }
  return output;
};
out$.get_spend_more_time_goals_for_domain = get_spend_more_time_goals_for_domain = async function(domain){
  var output, all_goals, goal_name, goal_info;
  output = [];
  all_goals = (await get_goals());
  for (goal_name in all_goals) {
    goal_info = all_goals[goal_name];
    if (!goal_info.is_positive) {
      continue;
    }
    if (goal_info.domain === domain) {
      output.push(goal_name);
    }
  }
  return output;
};
out$.add_enable_custom_goal_reduce_time_on_domain = add_enable_custom_goal_reduce_time_on_domain = async function(domain){
  var existing_goals, goal_name;
  existing_goals = (await get_spend_less_time_goals_for_domain(domain));
  if (existing_goals.length > 0) {
    goal_name = existing_goals[0];
    (await set_goal_enabled(goal_name));
    return goal_name;
  }
  (await add_custom_goal_reduce_time_on_domain(domain));
  (await set_goal_enabled("custom/spend_less_time_" + domain));
  (await intervention_utils.generate_interventions_for_domain(domain));
  return "custom/spend_less_time_" + domain;
};
out$.add_enable_custom_goal_increase_time_on_domain = add_enable_custom_goal_increase_time_on_domain = async function(domain){
  var existing_goals, goal_name;
  existing_goals = (await get_spend_more_time_goals_for_domain(domain));
  if (existing_goals.length > 0) {
    goal_name = existing_goals[0];
    (await set_goal_enabled(goal_name));
    return goal_name;
  }
  (await add_custom_goal_involving_time_on_domain(domain, true));
  (await set_goal_enabled("custom/spend_more_time_" + domain));
  (await intervention_utils.generate_interventions_for_positive_domain(domain));
  return "custom/spend_more_time_" + domain;
};
out$.disable_all_custom_goals = disable_all_custom_goals = async function(){
  var enabled_goals, new_enabled_goals, goal_name, is_enabled;
  enabled_goals = (await get_enabled_goals());
  new_enabled_goals = {};
  for (goal_name in enabled_goals) {
    is_enabled = enabled_goals[goal_name];
    if (goal_name.startsWith('custom/')) {
      continue;
    }
    new_enabled_goals[goal_name] = is_enabled;
  }
  (await set_enabled_goals(new_enabled_goals));
};
out$.remove_all_custom_goals_and_interventions = remove_all_custom_goals_and_interventions = async function(){
  (await remove_all_custom_goals());
  intervention_utils.remove_all_custom_interventions();
};
out$.remove_all_custom_goals = remove_all_custom_goals = async function(){
  (await disable_all_custom_goals());
  clear_cache_all_goals();
  localStorage.removeItem('extra_get_goals');
  localStorage.removeItem('extra_list_all_goals');
};
out$.remove_custom_goal_and_generated_interventions = remove_custom_goal_and_generated_interventions = async function(goal_name){
  var all_goals, goal;
  all_goals = (await get_goals());
  goal = all_goals[goal_name];
  intervention_utils.remove_generated_interventions_for_domain(goal.domain);
  (await set_goal_disabled(goal_name));
  clear_cache_all_goals();
  remove_key_from_localstorage_dict('extra_get_goals', goal_name);
  remove_item_from_localstorage_list('extra_list_all_goals', goal_name);
  remove_cached_favicon_for_domain(goal.domain);
};
out$.get_interventions_to_goals = get_interventions_to_goals = async function(){
  var output, goals, goal_name, goal_info, i$, ref$, len$, intervention_name;
  output = {};
  goals = (await get_goals());
  for (goal_name in goals) {
    goal_info = goals[goal_name];
    if (goal_info.interventions == null) {
      continue;
    }
    for (i$ = 0, len$ = (ref$ = goal_info.interventions).length; i$ < len$; ++i$) {
      intervention_name = ref$[i$];
      if (output[intervention_name] == null) {
        output[intervention_name] = [];
      }
      output[intervention_name].push(goal_name);
    }
  }
  return output;
};
out$.get_goals_for_intervention = get_goals_for_intervention = async function(intervention_name){
  var interventions_to_goals, goals_for_intervention, ref$;
  interventions_to_goals = (await get_interventions_to_goals());
  goals_for_intervention = (ref$ = interventions_to_goals[intervention_name]) != null
    ? ref$
    : [];
  return goals_for_intervention;
};
/**
 * Gets the target time spent in seconds for the specified goal
 * @param {GoalName} goal_name - The name of the goal
 * @return {Promise.<Number>} The target in seconds
 */
out$.get_goal_target = get_goal_target = async function(goal_name){
  var result, all_goals, goal_info;
  result = (await getkey_dict('goal_targets', goal_name));
  if (result != null) {
    return parseFloat(result);
  }
  all_goals = (await get_goals());
  goal_info = all_goals[goal_name];
  return parseFloat(goal_info.target['default']);
};
out$.set_goal_target = set_goal_target = async function(goal_name, target_value){
  var result;
  result = (await getkey_dict('goal_targets', goal_name));
  if (result != null && parseInt(result) === target_value) {
    return;
  }
  (await setkey_dict('goal_targets', goal_name, target_value));
};
out$.get_all_goal_targets = get_all_goal_targets = async function(){
  var all_goals, saved_targets, output, goal_name, goal_info;
  all_goals = (await get_goals());
  saved_targets = (await getdict('goal_targets'));
  output = {};
  for (goal_name in all_goals) {
    goal_info = all_goals[goal_name];
    if (saved_targets[goal_name] != null) {
      output[goal_name] = parseFloat(saved_targets[goal_name]);
    } else {
      output[goal_name] = parseFloat(goal_info.target['default']);
    }
  }
  return output;
};
out$.list_goal_info_for_enabled_goals = list_goal_info_for_enabled_goals = async function(){
  var goal_names, goal_name_to_info, output, i$, len$, goal_name;
  goal_names = (await get_enabled_goals());
  goal_names = as_array(goal_names);
  goal_name_to_info = (await get_goals());
  output = [];
  for (i$ = 0, len$ = goal_names.length; i$ < len$; ++i$) {
    goal_name = goal_names[i$];
    if (goal_name_to_info[goal_name] != null) {
      output.push(goal_name_to_info[goal_name]);
    }
  }
  return output;
};
intervention_utils = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls");
log_utils = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls");
goal_progress = __webpack_require__(/*! libs_common/goal_progress */ "./src/libs_backend/goal_progress.ls");
gexport_module('goal_utils', function(it){
  return eval(it);
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
//# sourceMappingURL=goal_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/goal_vars_backend.js":
/*!***********************************************!*\
  !*** ./src/libs_backend/goal_vars_backend.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  getkey_dictdict,
  setkey_dictdict
} = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls")

async function setvar_goal_synced_backend(goal_name, key, val) {
  await setkey_dictdict('goal_vars_synced', goal_name, key, val)
}

async function setvar_goal_unsynced_backend(goal_name, key, val) {
  await setkey_dictdict('goal_vars_unsynced', goal_name, key, val)
}

async function getvar_goal_synced_backend(goal_name, key) {
  return await getkey_dictdict('goal_vars_synced', goal_name, key)
}

async function getvar_goal_unsynced_backend(goal_name, key) {
  return await getkey_dictdict('goal_vars_unsynced', goal_name, key)
}

module.exports = {
  setvar_goal_synced_backend,
  setvar_goal_unsynced_backend,
  getvar_goal_synced_backend,
  getvar_goal_unsynced_backend,
}


/***/ }),

/***/ "./src/libs_backend/habitlab_update_utils.ls":
/*!***************************************************!*\
  !*** ./src/libs_backend/habitlab_update_utils.ls ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var semver, ref$, get_user_id, get_install_id, gexport, gexport_module, chrome_manifest, habitlab_version, developer_mode, run_check_for_update_if_needed, get_latest_habitlab_version, is_habitlab_update_available, check_if_update_available_and_run_update, out$ =  true && exports || this;
semver = __webpack_require__(/*! semver */ "./node_modules/semver/semver.js");
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_user_id = ref$.get_user_id, get_install_id = ref$.get_install_id;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
chrome_manifest = chrome.runtime.getManifest();
habitlab_version = chrome_manifest.version;
developer_mode = chrome_manifest.update_url == null;
out$.run_check_for_update_if_needed = run_check_for_update_if_needed = function(){
  var last_time_update_checked, current_time;
  if (developer_mode) {
    return;
  }
  if (!(chrome.runtime.id === 'obghclocpdgcekcognpkblghkedcpdgd' || chrome.runtime.id === 'bleifeoekkfhicamkpadfoclfhfmmina')) {
    return;
  }
  last_time_update_checked = localStorage.getItem('habitlab_last_time_checked_for_updates');
  if (last_time_update_checked != null) {
    last_time_update_checked = parseInt(last_time_update_checked);
  } else {
    last_time_update_checked = 0;
  }
  current_time = Date.now();
  if (last_time_update_checked + 1000 * 60 * 15 > current_time) {
    return;
  }
  localStorage.setItem('habitlab_last_time_checked_for_updates', current_time);
  return chrome.runtime.requestUpdateCheck(function(status, details){});
};
out$.get_latest_habitlab_version = get_latest_habitlab_version = async function(){
  var chrome_runtime_id, user_id, install_id, latest_version_info;
  chrome_runtime_id = 'obghclocpdgcekcognpkblghkedcpdgd';
  if (chrome.runtime.id === 'bleifeoekkfhicamkpadfoclfhfmmina') {
    chrome_runtime_id = 'bleifeoekkfhicamkpadfoclfhfmmina';
  }
  user_id = (await get_user_id());
  install_id = (await get_install_id());
  latest_version_info = null;
  if ((latest_version_info != null ? latest_version_info.version : void 8) == null || !semver.valid(latest_version_info.version)) {
    return null;
  }
  return latest_version_info.version;
};
out$.is_habitlab_update_available = is_habitlab_update_available = async function(){
  var latest_version;
  latest_version = (await get_latest_habitlab_version());
  if (latest_version == null) {
    return false;
  }
  return semver.gt(latest_version, habitlab_version);
};
out$.check_if_update_available_and_run_update = check_if_update_available_and_run_update = async function(){
  var is_checking_for_updates_enabled, update_available;
  is_checking_for_updates_enabled = false;
  if (chrome.runtime.id === 'obghclocpdgcekcognpkblghkedcpdgd' || chrome.runtime.id === 'bleifeoekkfhicamkpadfoclfhfmmina') {
    is_checking_for_updates_enabled = true;
  } else {
    if (developer_mode && localStorage.getItem('check_for_updates_devmode') === 'true') {
      is_checking_for_updates_enabled = true;
    }
  }
  if (!is_checking_for_updates_enabled) {
    return false;
  }
  update_available = (await is_habitlab_update_available());
  if (update_available) {
    run_check_for_update_if_needed();
  }
  return update_available;
};
gexport_module('habitlab_update_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=habitlab_update_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/history_utils.ls":
/*!*******************************************!*\
  !*** ./src/libs_backend/history_utils.ls ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var url_to_domain, memoizeSingleAsync, ref$, gexport, gexport_module, moment, median, localget, get_seconds_spent_on_domain_all_days, getvar_history, setvar_history, getdict, setdict, prelude, lzstring, get_pages_visited_today, get_pages_visited_all_time, get_productivity_classifications, get_work_pages_visited_today, get_url_to_visits, get_url_to_visits_from_pages_list, get_url_and_visit_time_sorted_for_url_to_visits, get_url_and_visit_time_sorted, get_url_to_time_spent_for_url_and_visit_time, get_url_to_time_spent, get_domain_to_time_spent_for_url_to_visits, get_domain_to_time_spent_for_url_to_time_spent, get_domain_to_time_spent, get_url_to_time_spent_days_before_today, get_url_to_time_spent_today, get_domain_to_time_spent_days_before_today, get_domain_to_time_spent_today, get_domain_to_earliest_visit_for_url_to_visits, get_domain_to_earliest_visit, get_baseline_time_on_domains_real_passing_url_to_visits_and_time, get_baseline_time_on_domains_real, get_baseline_time_on_domains, get_baseline_time_on_domain, get_baseline_session_time_on_domains_real_passing_url_to_visits_and_time, get_baseline_session_time_on_domains_real, get_baseline_session_time_on_domains, get_baseline_session_time_on_domain, get_domain_visit_info, ensure_history_utils_data_cached, list_all_domains_in_history, get_average_seconds_spent_on_domain, out$ =  true && exports || this;
url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
median = __webpack_require__(/*! libs_common/math_utils */ "./src/libs_common/math_utils.js").median;
localget = __webpack_require__(/*! libs_common/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls").localget;
get_seconds_spent_on_domain_all_days = __webpack_require__(/*! libs_common/time_spent_utils */ "./src/libs_common/time_spent_utils.ls").get_seconds_spent_on_domain_all_days;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), getvar_history = ref$.getvar_history, setvar_history = ref$.setvar_history, getdict = ref$.getdict, setdict = ref$.setdict;
prelude = __webpack_require__(/*! prelude-ls */ "./node_modules/prelude-ls/lib/index.js");
lzstring = __webpack_require__(/*! lz-string */ "./node_modules/lz-string/libs/lz-string.js");
out$.get_pages_visited_today = get_pages_visited_today = async function(){
  var yesterday, pages_list;
  yesterday = Date.now() - 24 * 3600 * 1000;
  pages_list = (await new Promise(function(it){
    return chrome.history.search({
      text: '',
      startTime: yesterday,
      maxResults: Math.pow(2, 31) - 1
    }, it);
  }));
  return pages_list;
};
out$.get_pages_visited_all_time = get_pages_visited_all_time = async function(){
  var pages_list;
  pages_list = (await new Promise(function(it){
    return chrome.history.search({
      text: '',
      startTime: 0,
      maxResults: Math.pow(2, 31) - 1
    }, it);
  }));
  return pages_list;
};
out$.get_productivity_classifications = get_productivity_classifications = memoizeSingleAsync(async function(){
  var classifications;
  classifications = (await localget('/productivity_classifications.json'));
  return JSON.parse(classifications);
});
out$.get_work_pages_visited_today = get_work_pages_visited_today = async function(){
  var yesterday, pages_list, productivity_classifications, productive_pages_list;
  yesterday = Date.now() - 24 * 3600 * 1000;
  pages_list = (await new Promise(function(it){
    return chrome.history.search({
      text: '',
      startTime: yesterday,
      maxResults: Math.pow(2, 31) - 1
    }, it);
  }));
  productivity_classifications = (await get_productivity_classifications());
  productive_pages_list = pages_list.filter(function(page_info){
    var url, domain;
    url = page_info.url;
    domain = url_to_domain(url);
    if (productivity_classifications[domain] === 'work') {
      return true;
    }
    return false;
  });
  return productive_pages_list;
};
out$.get_url_to_visits = get_url_to_visits = async function(start_time, end_time){
  var pages_list, url_list, seen_urls, i$, len$, page, url, url_to_visits, visits;
  pages_list = (await new Promise(function(it){
    return chrome.history.search({
      text: '',
      startTime: start_time,
      endTime: end_time,
      maxResults: Math.pow(2, 31) - 1
    }, it);
  }));
  url_list = [];
  seen_urls = {};
  for (i$ = 0, len$ = pages_list.length; i$ < len$; ++i$) {
    page = pages_list[i$];
    url = page.url;
    if (url == null || url === '') {
      continue;
    }
    seen_urls[url] = true;
    url_list.push(url);
  }
  url_to_visits = {};
  for (i$ = 0, len$ = url_list.length; i$ < len$; ++i$) {
    url = url_list[i$];
    visits = (await new Promise(fn$));
    url_to_visits[url] = visits;
  }
  return url_to_visits;
  function fn$(it){
    return chrome.history.getVisits({
      url: url
    }, it);
  }
};
out$.get_url_to_visits_from_pages_list = get_url_to_visits_from_pages_list = async function(pages_list){
  var url_list, seen_urls, i$, len$, page, url, url_to_visits, visits;
  url_list = [];
  seen_urls = {};
  for (i$ = 0, len$ = pages_list.length; i$ < len$; ++i$) {
    page = pages_list[i$];
    url = page.url;
    if (url == null || url === '') {
      continue;
    }
    seen_urls[url] = true;
    url_list.push(url);
  }
  url_to_visits = {};
  for (i$ = 0, len$ = url_list.length; i$ < len$; ++i$) {
    url = url_list[i$];
    visits = (await new Promise(fn$));
    url_to_visits[url] = visits;
  }
  return url_to_visits;
  function fn$(it){
    return chrome.history.getVisits({
      url: url
    }, it);
  }
};
out$.get_url_and_visit_time_sorted_for_url_to_visits = get_url_and_visit_time_sorted_for_url_to_visits = function(url_to_visits, start_time, end_time){
  var url_and_visit_time, url, visits, i$, len$, visit, visitTime, this$ = this;
  url_and_visit_time = [];
  for (url in url_to_visits) {
    visits = url_to_visits[url];
    for (i$ = 0, len$ = visits.length; i$ < len$; ++i$) {
      visit = visits[i$];
      visitTime = visit.visitTime;
      if (start_time <= visitTime && visitTime <= end_time) {
        url_and_visit_time.push({
          url: url,
          visitTime: visitTime
        });
      }
    }
  }
  url_and_visit_time = prelude.sortBy(function(it){
    return it.visitTime;
  }, url_and_visit_time);
  return url_and_visit_time;
};
out$.get_url_and_visit_time_sorted = get_url_and_visit_time_sorted = async function(start_time, end_time){
  var url_to_visits;
  url_to_visits = (await get_url_to_visits(start_time, end_time));
  return get_url_and_visit_time_sorted_for_url_to_visits(url_to_visits, start_time, end_time);
};
out$.get_url_to_time_spent_for_url_and_visit_time = get_url_to_time_spent_for_url_and_visit_time = function(url_and_visit_time, start_time, end_time){
  var url_to_time_spent, i$, len$, idx, item, visitTime, url, nextitem, visit_duration, nextVisitTime;
  url_to_time_spent = {};
  for (i$ = 0, len$ = url_and_visit_time.length; i$ < len$; ++i$) {
    idx = i$;
    item = url_and_visit_time[i$];
    visitTime = item.visitTime, url = item.url;
    nextitem = url_and_visit_time[idx + 1];
    visit_duration = 5 * 60 * 1000;
    if (nextitem != null) {
      nextVisitTime = nextitem.visitTime;
      visit_duration = Math.min(visit_duration, nextVisitTime - visitTime);
    }
    if (visitTime + visit_duration > end_time) {
      visit_duration = end_time - visitTime;
    }
    if (visit_duration < 0) {
      console.log('visit duration negative');
      console.log(item);
      console.log(start_time);
      console.log(end_time);
      console.log(nextitem);
      console.log(visit_duration);
    }
    if (url_to_time_spent[url] == null) {
      url_to_time_spent[url] = visit_duration;
    } else {
      url_to_time_spent[url] += visit_duration;
    }
  }
  return url_to_time_spent;
};
out$.get_url_to_time_spent = get_url_to_time_spent = async function(start_time, end_time){
  var url_and_visit_time;
  url_and_visit_time = (await get_url_and_visit_time_sorted(start_time, end_time));
  return get_url_to_time_spent_for_url_and_visit_time(url_and_visit_time, start_time, end_time);
};
out$.get_domain_to_time_spent_for_url_to_visits = get_domain_to_time_spent_for_url_to_visits = function(url_to_visits, start_time, end_time){
  var url_and_visit_time, url_to_time_spent;
  url_and_visit_time = get_url_and_visit_time_sorted_for_url_to_visits(url_to_visits, start_time, end_time);
  url_to_time_spent = get_url_to_time_spent_for_url_and_visit_time(url_and_visit_time, start_time, end_time);
  return get_domain_to_time_spent_for_url_to_time_spent(url_to_time_spent);
};
out$.get_domain_to_time_spent_for_url_to_time_spent = get_domain_to_time_spent_for_url_to_time_spent = function(url_to_time_spent){
  var domain_to_time_spent, url, time_spent, domain;
  domain_to_time_spent = {};
  for (url in url_to_time_spent) {
    time_spent = url_to_time_spent[url];
    if (url.startsWith('chrome://') || url.startsWith('chrome-extension://')) {
      continue;
    }
    domain = url_to_domain(url);
    if (domain_to_time_spent[domain] == null) {
      domain_to_time_spent[domain] = time_spent;
    } else {
      domain_to_time_spent[domain] += time_spent;
    }
  }
  return domain_to_time_spent;
};
out$.get_domain_to_time_spent = get_domain_to_time_spent = async function(start_time, end_time){
  var url_to_time_spent;
  url_to_time_spent = (await get_url_to_time_spent(start_time, end_time));
  return get_domain_to_time_spent_for_url_to_time_spent(url_to_time_spent);
};
out$.get_url_to_time_spent_days_before_today = get_url_to_time_spent_days_before_today = async function(days_before_today){
  var start_time, end_time;
  start_time = moment().subtract(days_before_today, 'days').hour(0).minute(0).second(0).valueOf();
  end_time = moment().subtract(days_before_today, 'days').hour(23).minute(59).second(59).valueOf();
  return (await get_url_to_time_spent(start_time, end_time));
};
out$.get_url_to_time_spent_today = get_url_to_time_spent_today = async function(){
  return (await get_url_to_time_spent_days_before_today(0));
};
out$.get_domain_to_time_spent_days_before_today = get_domain_to_time_spent_days_before_today = async function(days_before_today){
  var start_time, end_time;
  start_time = moment().subtract(days_before_today, 'days').hour(0).minute(0).second(0).valueOf();
  end_time = moment().subtract(days_before_today, 'days').hour(23).minute(59).second(59).valueOf();
  return (await get_domain_to_time_spent(start_time, end_time));
};
out$.get_domain_to_time_spent_today = get_domain_to_time_spent_today = async function(){
  return (await get_domain_to_time_spent_days_before_today(0));
};
out$.get_domain_to_earliest_visit_for_url_to_visits = get_domain_to_earliest_visit_for_url_to_visits = function(url_to_visits){
  var domain_to_earliest_visit, url, visits, domain, i$, len$, visit, visitTime;
  domain_to_earliest_visit = {};
  for (url in url_to_visits) {
    visits = url_to_visits[url];
    domain = url_to_domain(url);
    for (i$ = 0, len$ = visits.length; i$ < len$; ++i$) {
      visit = visits[i$];
      visitTime = visit.visitTime;
      if (domain_to_earliest_visit[domain] == null) {
        domain_to_earliest_visit[domain] = visitTime;
      } else {
        domain_to_earliest_visit[domain] = Math.min(visitTime, domain_to_earliest_visit[domain]);
      }
    }
  }
  return domain_to_earliest_visit;
};
out$.get_domain_to_earliest_visit = get_domain_to_earliest_visit = async function(){
  var url_to_visits;
  url_to_visits = (await get_url_to_visits(0, Date.now()));
  return get_domain_to_earliest_visit_for_url_to_visits(url_to_visits);
};
out$.get_baseline_time_on_domains_real_passing_url_to_visits_and_time = get_baseline_time_on_domains_real_passing_url_to_visits_and_time = function(url_to_visits, date_now){
  var total_time_spent_on_domains, earliest_visit_to_domains, baseline_time_on_domains, current_time, domain, time_spent, earliest_visit, num_days, daily_time_spent;
  total_time_spent_on_domains = get_domain_to_time_spent_for_url_to_visits(url_to_visits, 0, date_now);
  earliest_visit_to_domains = get_domain_to_earliest_visit_for_url_to_visits(url_to_visits);
  baseline_time_on_domains = {};
  current_time = Date.now();
  for (domain in total_time_spent_on_domains) {
    time_spent = total_time_spent_on_domains[domain];
    earliest_visit = earliest_visit_to_domains[domain];
    if (earliest_visit == null) {
      continue;
    }
    num_days = Math.round((current_time - earliest_visit) / (24 * 1000 * 3600));
    if (num_days < 1) {
      continue;
    }
    daily_time_spent = time_spent / num_days;
    baseline_time_on_domains[domain] = daily_time_spent;
  }
  return baseline_time_on_domains;
};
out$.get_baseline_time_on_domains_real = get_baseline_time_on_domains_real = async function(){
  var url_to_visits;
  url_to_visits = (await get_url_to_visits(0, Date.now()));
  return get_baseline_time_on_domains_real_passing_url_to_visits_and_time(url_to_visits, Date.now());
};
out$.get_baseline_time_on_domains = get_baseline_time_on_domains = memoizeSingleAsync(async function(){
  var baseline_time_on_domains;
  baseline_time_on_domains = (await getdict('baseline_time_on_domains'));
  if (baseline_time_on_domains != null && Object.keys(baseline_time_on_domains).length > 0) {
    return baseline_time_on_domains;
  }
  baseline_time_on_domains = (await get_baseline_time_on_domains_real());
  (await setdict('baseline_time_on_domains', baseline_time_on_domains));
  return baseline_time_on_domains;
});
out$.get_baseline_time_on_domain = get_baseline_time_on_domain = async function(domain){
  var baseline_time_on_domains;
  baseline_time_on_domains = (await get_baseline_time_on_domains());
  if (baseline_time_on_domains[domain] != null) {
    return baseline_time_on_domains[domain];
  }
  return 0;
};
out$.get_baseline_session_time_on_domains_real_passing_url_to_visits_and_time = get_baseline_session_time_on_domains_real_passing_url_to_visits_and_time = function(url_to_visits, date_now){
  var url_and_visit_time_sorted, prev_domain, prev_visit_time_start, prev_visit_time_most_recent, domain_to_visit_lengths, i$, len$, ref$, url, visitTime, domain, prev_visit_end_time, domain_to_average_visit_lengths, visit_lengths;
  url_and_visit_time_sorted = get_url_and_visit_time_sorted_for_url_to_visits(url_to_visits, 0, date_now);
  prev_domain = null;
  prev_visit_time_start = 0;
  prev_visit_time_most_recent = 0;
  domain_to_visit_lengths = {};
  for (i$ = 0, len$ = url_and_visit_time_sorted.length; i$ < len$; ++i$) {
    ref$ = url_and_visit_time_sorted[i$], url = ref$.url, visitTime = ref$.visitTime;
    domain = url_to_domain(url);
    if (domain_to_visit_lengths[domain] == null) {
      domain_to_visit_lengths[domain] = [];
    }
    if (visitTime > prev_visit_time_most_recent + 60 * 60 * 1000) {
      if (prev_domain != null) {
        domain_to_visit_lengths[prev_domain].push(prev_visit_time_most_recent + 60 * 1000 - prev_visit_time_start);
      }
      prev_domain = domain;
      prev_visit_time_start = visitTime;
      prev_visit_time_most_recent = visitTime;
      continue;
    }
    if (domain !== prev_domain) {
      if (prev_domain != null) {
        prev_visit_end_time = Math.min(visitTime, prev_visit_time_most_recent + 60 * 60 * 1000);
        domain_to_visit_lengths[prev_domain].push(prev_visit_end_time - prev_visit_time_start);
      }
      prev_domain = domain;
      prev_visit_time_start = visitTime;
      prev_visit_time_most_recent = visitTime;
      continue;
    }
    prev_visit_time_most_recent = visitTime;
  }
  domain_to_average_visit_lengths = {};
  for (domain in domain_to_visit_lengths) {
    visit_lengths = domain_to_visit_lengths[domain];
    if (visit_lengths.length === 0) {
      continue;
    }
    domain_to_average_visit_lengths[domain] = median(visit_lengths) / 1000;
  }
  return domain_to_average_visit_lengths;
};
out$.get_baseline_session_time_on_domains_real = get_baseline_session_time_on_domains_real = async function(){
  var url_to_visits;
  url_to_visits = (await get_url_to_visits(0, Date.now()));
  return get_baseline_session_time_on_domains_real_passing_url_to_visits_and_time(url_to_visits, Date.now());
};
out$.get_baseline_session_time_on_domains = get_baseline_session_time_on_domains = memoizeSingleAsync(async function(){
  var baseline_time_on_domains;
  baseline_time_on_domains = (await getdict('baseline_session_time_on_domains'));
  if (baseline_time_on_domains != null && Object.keys(baseline_time_on_domains).length > 0) {
    return baseline_time_on_domains;
  }
  baseline_time_on_domains = (await get_baseline_session_time_on_domains_real());
  (await setdict('baseline_session_time_on_domains', baseline_time_on_domains));
  return baseline_time_on_domains;
});
out$.get_baseline_session_time_on_domain = get_baseline_session_time_on_domain = async function(domain){
  var baseline_time_on_domains;
  baseline_time_on_domains = (await get_baseline_session_time_on_domains());
  if (baseline_time_on_domains[domain] != null) {
    return baseline_time_on_domains[domain];
  }
  return 0;
};
out$.get_domain_visit_info = get_domain_visit_info = function(pages_list){
  var output, i$, len$, x, url, domain, curitem;
  output = {};
  for (i$ = 0, len$ = pages_list.length; i$ < len$; ++i$) {
    x = pages_list[i$];
    url = x.url;
    if (!(url.startsWith('https://') || url.startsWith('http://'))) {
      continue;
    }
    domain = url_to_domain(url);
    curitem = output[domain];
    if (curitem == null) {
      output[domain] = [0, 0, 0, 0, x.lastVisitTime, x.lastVisitTime];
      curitem = output[domain];
    } else {
      curitem[4] = Math.min(curitem[4], x.lastVisitTime);
      curitem[5] = Math.max(curitem[5], x.lastVisitTime);
    }
    curitem[0] += 1;
    curitem[2] += x.visitCount;
    if (x.typedCount > 0) {
      curitem[1] += 1;
      curitem[3] += x.typedCount;
    }
  }
  return output;
};
out$.ensure_history_utils_data_cached = ensure_history_utils_data_cached = async function(){
  var date_now, domain_visit_info_compressed, pages_list, baseline_session_time_on_domains, baseline_time_on_domains, url_to_visits;
  date_now = Date.now();
  if (localStorage.cached_domain_visit_info !== 'true') {
    domain_visit_info_compressed = (await getvar_history('domain_visit_info'));
    if (domain_visit_info_compressed == null) {
      pages_list = (await new Promise(function(it){
        return chrome.history.search({
          text: '',
          startTime: 0,
          endTime: date_now,
          maxResults: Math.pow(2, 31) - 1
        }, it);
      }));
      domain_visit_info_compressed = lzstring.compressToEncodedURIComponent(JSON.stringify(get_domain_visit_info(pages_list)));
      (await setvar_history('domain_visit_info', domain_visit_info_compressed));
    }
    localStorage.cached_domain_visit_info = 'true';
  }
  if (localStorage.cached_domain_baseline_times !== 'true') {
    baseline_session_time_on_domains = (await getdict('baseline_session_time_on_domains'));
    baseline_time_on_domains = (await getdict('baseline_time_on_domains'));
    if (!(baseline_session_time_on_domains != null && baseline_time_on_domains != null && Object.keys(baseline_session_time_on_domains).length > 0 && Object.keys(baseline_time_on_domains).length > 0)) {
      if (pages_list == null) {
        pages_list = (await new Promise(function(it){
          return chrome.history.search({
            text: '',
            startTime: 0,
            endTime: date_now,
            maxResults: Math.pow(2, 31) - 1
          }, it);
        }));
      }
      url_to_visits = (await get_url_to_visits_from_pages_list(pages_list));
      baseline_session_time_on_domains = (await get_baseline_session_time_on_domains_real_passing_url_to_visits_and_time(url_to_visits, date_now));
      (await setdict('baseline_session_time_on_domains', baseline_session_time_on_domains));
      baseline_time_on_domains = (await get_baseline_time_on_domains_real_passing_url_to_visits_and_time(url_to_visits, date_now));
      (await setdict('baseline_time_on_domains', baseline_time_on_domains));
    }
    return localStorage.cached_domain_baseline_times = 'true';
  }
};
out$.list_all_domains_in_history = list_all_domains_in_history = async function(){
  var start_time, end_time, url_history_info_list, output_set, output, i$, len$, url, domain;
  start_time = 0;
  end_time = Date.now();
  url_history_info_list = (await new Promise(function(it){
    return chrome.history.search({
      text: '',
      startTime: start_time,
      endTime: end_time,
      maxResults: Math.pow(2, 31) - 1
    }, it);
  }));
  output_set = {};
  output = [];
  for (i$ = 0, len$ = url_history_info_list.length; i$ < len$; ++i$) {
    url = url_history_info_list[i$].url;
    domain = url_to_domain(url);
    if (domain.length === 0) {
      continue;
    }
    if (output_set[domain] == null) {
      output_set[domain] = true;
      output.push(domain);
    }
  }
  output.sort();
  return output;
};
out$.get_average_seconds_spent_on_domain = get_average_seconds_spent_on_domain = async function(domain){
  var days_before_to_seconds_spent, num_days_of_data;
  days_before_to_seconds_spent = (await get_seconds_spent_on_domain_all_days(domain));
  num_days_of_data = Object.keys(days_before_to_seconds_spent).length;
  if (num_days_of_data < 2) {
    return (await get_baseline_time_on_domain(domain)) / 1000.0;
  }
  return prelude.sum(Object.values(days_before_to_seconds_spent)) / num_days_of_data;
};
gexport_module('history_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=history_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/intervention_feedback_utils.js":
/*!*********************************************************!*\
  !*** ./src/libs_backend/intervention_feedback_utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  addtolist_for_key,
  getlist_for_key,
} = __webpack_require__(/*! libs_common/db_utils */ "./src/libs_backend/db_utils.ls")

const {
  log_upvote_internal,
  log_downvote_internal,
  log_feedback_internal
} = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls")

async function get_num_upvotes_for_intervention(intervention_name) {
  let results = await getlist_for_key('intervention_upvote_timestamps', intervention_name)
  return results.length
}

async function get_upvote_timestamps_for_intervention(intervention_name) {
  return await getlist_for_key('intervention_upvote_timestamps', intervention_name)
}

async function get_num_downvotes_for_intervention(intervention_name) {
  let results = await getlist_for_key('intervention_downvote_timestamps', intervention_name)
  return results.length
}

async function get_downvote_timestamps_for_intervention(intervention_name) {
  return await getlist_for_key('intervention_downvote_timestamps', intervention_name)
}

async function get_feedback_for_intervention(intervention_name) {
  return await getlist_for_key('intervention_feedback', intervention_name)
}

async function upvote_intervention(intervention_name) {
  await addtolist_for_key('intervention_upvote_timestamps', intervention_name, Date.now())
  await log_upvote_internal(intervention_name, {})
}

async function downvote_intervention(intervention_name) {
  await addtolist_for_key('intervention_downvote_timestamps', intervention_name, Date.now())
  await log_downvote_internal(intervention_name, {})
}

async function add_feedback_for_intervention(intervention_name, feedback_data) {
  let data = JSON.parse(JSON.stringify(feedback_data))
  data.timestamp = Date.now()
  await addtolist_for_key('intervention_feedback', intervention_name, data)
  await log_feedback_internal(intervention_name, feedback_data)
}

module.exports = {
  upvote_intervention,
  downvote_intervention,
  add_feedback_for_intervention,
  get_num_upvotes_for_intervention,
  get_num_downvotes_for_intervention,
  get_upvote_timestamps_for_intervention,
  get_downvote_timestamps_for_intervention,
  get_feedback_for_intervention,
}


/***/ }),

/***/ "./src/libs_backend/intervention_first_impression_utils_backend.js":
/*!*************************************************************************!*\
  !*** ./src/libs_backend/intervention_first_impression_utils_backend.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  setvar_experiment
} = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls")

async function show_firstimpression_message_for_intervention(intervention_name) {
  let condition = localStorage.getItem('intervention_firstimpression_notice')
  if (condition == 'none' || condition == null) {
    return 'none'
  }
  let interventions_shown_for = localStorage.getItem('intervention_firstimpression_notice_seenlist')
  if (interventions_shown_for == null) {
    interventions_shown_for = []
  } else {
    interventions_shown_for = JSON.parse(interventions_shown_for)
  }
  let already_shown = interventions_shown_for.includes(intervention_name)
  if (already_shown) {
    return 'none'
  }
  interventions_shown_for.push(intervention_name)
  localStorage.setItem('intervention_firstimpression_notice_seenlist', JSON.stringify(interventions_shown_for))
  setvar_experiment('intervention_firstimpression_notice_seenlist', JSON.stringify(interventions_shown_for))
  return condition
}

module.exports = {
  show_firstimpression_message_for_intervention
}



/***/ }),

/***/ "./src/libs_backend/intervention_manager.ls":
/*!**************************************************!*\
  !*** ./src/libs_backend/intervention_manager.ls ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, get_enabled_goals, get_goals, get_days_since_epoch, getdict_for_key2_dictdict, setdict_for_key2_dictdict, getdict_for_key_dictdict, getCollection, setdict, getdict, getkey_dict, setkey_dict, getkey_dictdict, setkey_dictdict, as_array, as_dictset, get_intervention_selection_algorithm_for_visit, add_log_interventions, get_active_interventions_for_domain_and_session, set_active_interventions_for_domain_and_session, get_enabled_interventions_for_visit, get_last_day_with_intervention_enabled_data, get_days_before_today_on_which_intervention_was_deployed, get_days_on_which_intervention_was_deployed, get_currently_enabled_interventions, set_currently_enabled_interventions_manual, set_intervention_enabled_from_intervention_manager, set_intervention_disabled_from_intervention_manager, get_is_intervention_disabled_from_intervention_manager, set_currently_enabled_interventions_automatic, enable_interventions_because_goal_was_enabled, intervention_utils, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
ref$ = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls"), get_enabled_goals = ref$.get_enabled_goals, get_goals = ref$.get_goals;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), getdict_for_key2_dictdict = ref$.getdict_for_key2_dictdict, setdict_for_key2_dictdict = ref$.setdict_for_key2_dictdict, getdict_for_key_dictdict = ref$.getdict_for_key_dictdict, getCollection = ref$.getCollection, setdict = ref$.setdict, getdict = ref$.getdict, getkey_dict = ref$.getkey_dict, setkey_dict = ref$.setkey_dict, getkey_dictdict = ref$.getkey_dictdict, setkey_dictdict = ref$.setkey_dictdict;
ref$ = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls"), as_array = ref$.as_array, as_dictset = ref$.as_dictset;
get_intervention_selection_algorithm_for_visit = __webpack_require__(/*! libs_backend/intervention_selection_algorithms */ "./src/libs_backend/intervention_selection_algorithms.ls").get_intervention_selection_algorithm_for_visit;
add_log_interventions = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls").add_log_interventions;
/*
export set_enabled_interventions_for_today_manual = (enabled_interventions) ->>
  await setdict_for_key2_dictdict 'interventions_enabled_each_day', get_days_since_epoch(), enabled_interventions
  return

export set_enabled_interventions_for_today_automatic = (enabled_interventions) ->>
  await setdict_for_key2_dictdict 'interventions_enabled_each_day', get_days_since_epoch(), enabled_interventions
  return

export get_cached_enabled_interventions_for_today = ->>
  await get_cached_enabled_interventions_for_days_before_today 0

export get_cached_enabled_interventions_for_days_before_today = (days_before_today) ->>
  await getdict_for_key2_dictdict 'interventions_enabled_each_day', (get_days_since_epoch() - days_before_today)

export get_enabled_interventions_for_today = ->>
  await get_enabled_interventions_for_days_before_today 0
*/
out$.get_active_interventions_for_domain_and_session = get_active_interventions_for_domain_and_session = async function(domain, session_id){
  var result;
  result = (await getkey_dictdict('interventions_active_for_domain_and_session', domain, session_id));
  if (result == null) {
    return [];
  }
  return JSON.parse(result);
};
out$.set_active_interventions_for_domain_and_session = set_active_interventions_for_domain_and_session = async function(domain, session_id, interventions){
  return (await setkey_dictdict('interventions_active_for_domain_and_session', domain, session_id, JSON.stringify(interventions)));
};
out$.get_enabled_interventions_for_visit = get_enabled_interventions_for_visit = async function(){
  var enabled_interventions, intervention_selection_algorithm, selected_interventions_list, selected_interventions_set, res$, i$, len$, k;
  enabled_interventions = {};
  intervention_selection_algorithm = (await get_intervention_selection_algorithm_for_visit());
  selected_interventions_list = (await intervention_selection_algorithm());
  res$ = {};
  for (i$ = 0, len$ = selected_interventions_list.length; i$ < len$; ++i$) {
    k = selected_interventions_list[i$];
    res$[k] = true;
  }
  selected_interventions_set = res$;
  return selected_interventions_set;
};
/*
export get_enabled_interventions_for_visit = ->>
  enabled_interventions = {}
  intervention_selection_algorithm = await get_intervention_selection_algorithm_for_visit()
  automatically_enabled_interventions_list = await intervention_selection_algorithm()
  automatically_enabled_interventions_set = {[k, true] for k in automatically_enabled_interventions_list}
  enabled_interventions_set = await get_most_recent_enabled_interventions()
  manually_managed_interventions_set = await intervention_utils.get_manually_managed_interventions_localstorage()
  all_interventions = await intervention_utils.list_all_interventions()
  for intervention in all_interventions
    manually_managed = manually_managed_interventions_set[intervention]
    manually_managed = (manually_managed == true)
    enabled = false
    if manually_managed
      enabled = enabled_interventions_set[intervention]
    else
      enabled = automatically_enabled_interventions_set[intervention]
    enabled = (enabled == true)
    enabled_interventions[intervention] = enabled
  return enabled_interventions
*/
get_last_day_with_intervention_enabled_data = async function(){
  var collection, last_intervention_set_item;
  collection = (await getCollection('interventions_enabled_each_day'));
  last_intervention_set_item = (await collection.orderBy('key2').last());
  if (last_intervention_set_item == null) {
    return;
  }
  return last_intervention_set_item.key2;
};
out$.get_days_before_today_on_which_intervention_was_deployed = get_days_before_today_on_which_intervention_was_deployed = async function(intervention_name){
  var days_deployed, today, x;
  days_deployed = (await get_days_on_which_intervention_was_deployed(intervention_name));
  today = get_days_since_epoch();
  return (await (async function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = days_deployed).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(today - x);
    }
    return results$;
  }()));
};
out$.get_days_on_which_intervention_was_deployed = get_days_on_which_intervention_was_deployed = async function(intervention_name){
  var day_to_enabled, output, day, enabled;
  day_to_enabled = (await getdict_for_key_dictdict('interventions_enabled_each_day', intervention_name));
  output = [];
  for (day in day_to_enabled) {
    enabled = day_to_enabled[day];
    if (enabled) {
      output.push(day);
    }
  }
  return output;
};
out$.get_currently_enabled_interventions = get_currently_enabled_interventions = async function(){
  var interventions_currently_disabled, all_interventions, intervention_name_to_info, output, i$, len$, intervention_name, intervention_info, disable_status;
  interventions_currently_disabled = (await getdict('interventions_currently_disabled'));
  all_interventions = (await intervention_utils.list_all_interventions());
  intervention_name_to_info = (await intervention_utils.get_interventions());
  output = {};
  for (i$ = 0, len$ = all_interventions.length; i$ < len$; ++i$) {
    intervention_name = all_interventions[i$];
    intervention_info = intervention_name_to_info[intervention_name];
    if (intervention_info == null) {
      output[intervention_name] = false;
      continue;
    }
    disable_status = interventions_currently_disabled[intervention_name];
    if (disable_status != null) {
      if (disable_status) {
        output[intervention_name] = false;
      } else {
        output[intervention_name] = true;
      }
    } else {
      if (intervention_info.is_default == null) {
        output[intervention_name] = false;
      } else {
        output[intervention_name] = intervention_info.is_default;
      }
    }
  }
  return output;
};
out$.set_currently_enabled_interventions_manual = set_currently_enabled_interventions_manual = async function(enabled_interventions){
  var disabled_interventions, all_interventions, i$, len$, intervention_name;
  disabled_interventions = {};
  all_interventions = (await intervention_utils.list_all_interventions());
  for (i$ = 0, len$ = all_interventions.length; i$ < len$; ++i$) {
    intervention_name = all_interventions[i$];
    if (enabled_interventions[intervention_name]) {
      disabled_interventions[intervention_name] = false;
    } else {
      disabled_interventions[intervention_name] = true;
    }
  }
  (await setdict('interventions_currently_disabled', disabled_interventions));
};
out$.set_intervention_enabled_from_intervention_manager = set_intervention_enabled_from_intervention_manager = async function(intervention_name){
  (await setkey_dict('interventions_currently_disabled', intervention_name, false));
};
out$.set_intervention_disabled_from_intervention_manager = set_intervention_disabled_from_intervention_manager = async function(intervention_name){
  (await setkey_dict('interventions_currently_disabled', intervention_name, true));
};
out$.get_is_intervention_disabled_from_intervention_manager = get_is_intervention_disabled_from_intervention_manager = async function(intervention_name){
  return (await getkey_dict('interventions_currently_disabled', intervention_name));
};
out$.set_currently_enabled_interventions_automatic = set_currently_enabled_interventions_automatic = async function(enabled_interventions){
  var disabled_interventions, all_interventions, i$, len$, intervention_name;
  disabled_interventions = {};
  all_interventions = (await intervention_utils.list_all_interventions());
  for (i$ = 0, len$ = all_interventions.length; i$ < len$; ++i$) {
    intervention_name = all_interventions[i$];
    if (enabled_interventions[intervention_name]) {
      disabled_interventions[intervention_name] = false;
    } else {
      disabled_interventions[intervention_name] = true;
    }
  }
  (await setdict('interventions_currently_disabled', disabled_interventions));
};
/*
export get_most_recent_enabled_interventions = ->>
  day_with_enabled_interventions = await get_last_day_with_intervention_enabled_data()
  if not day_with_enabled_interventions?
    return {}
  days_before_today = get_days_since_epoch() - day_with_enabled_interventions
  await get_cached_enabled_interventions_for_days_before_today days_before_today
*/
/*
get_new_enabled_interventions_for_today = ->>
  enabled_interventions = {}
  intervention_selection_algorithm = await get_intervention_selection_algorithm()
  automatically_enabled_interventions_list = await intervention_selection_algorithm()
  automatically_enabled_interventions_set = {[k, true] for k in automatically_enabled_interventions_list}
  enabled_interventions_set = await get_most_recent_enabled_interventions()
  manually_managed_interventions_set = await intervention_utils.get_manually_managed_interventions_localstorage()
  all_interventions = await intervention_utils.list_all_interventions()
  for intervention in all_interventions
    manually_managed = manually_managed_interventions_set[intervention]
    manually_managed = (manually_managed == true)
    enabled = false
    if manually_managed
      enabled = enabled_interventions_set[intervention]
    else
      enabled = automatically_enabled_interventions_set[intervention]
    enabled = (enabled == true)
    enabled_interventions[intervention] = enabled
  return enabled_interventions
*/
/*
export get_and_set_new_enabled_interventions_for_today = ->>
  console.log 'picking new interventions for today'
  prev_enabled_interventions = await get_most_recent_enabled_interventions()
  enabled_interventions = await get_new_enabled_interventions_for_today()
  await set_enabled_interventions_for_today_automatic enabled_interventions
  add_log_interventions {
    type: 'new_interventions_for_new_day'
    manual: false
    prev_enabled_interventions: prev_enabled_interventions
    enabled_interventions: enabled_interventions
  }
  return enabled_interventions
*/
/*
export get_enabled_interventions_for_days_before_today = (days_before_today) ->>
  cached_enabled_interventions = await get_cached_enabled_interventions_for_days_before_today days_before_today
  if Object.keys(cached_enabled_interventions).length != 0
    return cached_enabled_interventions
  if days_before_today > 0 # no interventions were enabled in the past
    return {}
  enabled_interventions = await get_and_set_new_enabled_interventions_for_today()
  return enabled_interventions
*/
/*
export enable_interventions_because_goal_was_enabled = (goal_name) ->>
  intervention_selection_algorithm = await get_intervention_selection_algorithm()
  enabled_goals_for_selection_algorithm = {}
  enabled_goals_for_selection_algorithm[goal_name] = true
  automatically_enabled_interventions_list = await intervention_selection_algorithm(enabled_goals_for_selection_algorithm)
  console.log 'automatically_enabled_interventions_list is'
  console.log automatically_enabled_interventions_list
  enabled_interventions = await intervention_utils.get_enabled_interventions()
  prev_enabled_interventions = {} <<< enabled_interventions
  newly_enabled_interventions = []
  for intervention_name in automatically_enabled_interventions_list
    if enabled_interventions[intervention_name]
      continue
    newly_enabled_interventions.push intervention_name
    enabled_interventions[intervention_name] = true
  await set_enabled_interventions_for_today_automatic enabled_interventions
  add_log_interventions {
    type: 'enable_interventions_because_goal_was_enabled'
    manual: false
    goal_enabled: goal_name
    prev_enabled_interventions: prev_enabled_interventions
    enabled_interventions: enabled_interventions
  }
  return newly_enabled_interventions
*/
out$.enable_interventions_because_goal_was_enabled = enable_interventions_because_goal_was_enabled = async function(goal_name){
  var intervention_names, enabled_interventions, prev_enabled_interventions, intervention_name_to_info, i$, len$, intervention_name, intervention_info;
  intervention_names = (await intervention_utils.list_available_interventions_for_goal(goal_name));
  enabled_interventions = (await get_currently_enabled_interventions());
  prev_enabled_interventions = JSON.parse(JSON.stringify(enabled_interventions));
  intervention_name_to_info = (await intervention_utils.get_interventions());
  for (i$ = 0, len$ = intervention_names.length; i$ < len$; ++i$) {
    intervention_name = intervention_names[i$];
    if (enabled_interventions[intervention_name] != null) {
      continue;
    }
    intervention_info = intervention_name_to_info[intervention_name];
    if (intervention_info.is_default) {
      enabled_interventions[intervention_name] = true;
    } else {
      enabled_interventions[intervention_name] = false;
    }
  }
  (await set_currently_enabled_interventions_automatic(enabled_interventions));
  add_log_interventions({
    type: 'enable_interventions_because_goal_was_enabled',
    manual: false,
    goal_enabled: goal_name,
    prev_enabled_interventions: prev_enabled_interventions,
    enabled_interventions: enabled_interventions
  });
  return enabled_interventions;
};
intervention_utils = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls");
gexport_module('intervention_manager', function(it){
  return eval(it);
});
//# sourceMappingURL=intervention_manager.ls.map


/***/ }),

/***/ "./src/libs_backend/intervention_selection_algorithms.ls":
/*!***************************************************************!*\
  !*** ./src/libs_backend/intervention_selection_algorithms.ls ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shuffled, moment, prelude, ref$, list_available_interventions_for_enabled_goals, get_manually_managed_interventions, get_manually_managed_interventions_localstorage, list_all_interventions, get_enabled_interventions, get_number_sessions_for_each_intervention, is_intervention_enabled, get_time_since_intervention, get_intervention_info, get_interventions, get_intersection, list_enabled_interventions_for_goal, get_novelty, filter_interventions_by_temporary_difficulty, get_enabled_goals, get_goals, get_is_goal_frequent, getkey_dictdict, setkey_dictdict, getvar_experiment, setvar_experiment, as_array, train_multi_armed_bandit_for_goal, ThompsonMAB, gexport, gexport_module, one_random_intervention_per_enabled_goal, one_random_intervention_per_enabled_goal_with_frequency, try_parse_json, is_within_n_days_ago, how_many_days_ago, is_experiment_still_running, get_current_condition_for_experiment, choose_among_interventions_random, choose_among_interventions_same, choose_among_interventions_oneperday, choose_among_interventions_onepertwodays, choose_among_interventions_oneperthreedays, choose_among_interventions_by_rule, experiment_always_same, experiment_oneperday, experiment_onepertwodays, experiment_oneperthreedays, experiment_alternate_between_same_vs_random_daily_deterministic, experiment_alternate_between_same_vs_random_varlength_deterministic, experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare, thompsonsampling, novelty, thompson_novelty, selection_algorithms_for_visit, get_intervention_selection_algorithm_for_visit, multi_armed_bandit, out$ =  true && exports || this;
shuffled = __webpack_require__(/*! shuffled */ "./node_modules/shuffled/index.js");
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
prelude = __webpack_require__(/*! prelude-ls */ "./node_modules/prelude-ls/lib/index.js");
ref$ = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls"), list_available_interventions_for_enabled_goals = ref$.list_available_interventions_for_enabled_goals, get_manually_managed_interventions = ref$.get_manually_managed_interventions, get_manually_managed_interventions_localstorage = ref$.get_manually_managed_interventions_localstorage, list_all_interventions = ref$.list_all_interventions, get_enabled_interventions = ref$.get_enabled_interventions, get_number_sessions_for_each_intervention = ref$.get_number_sessions_for_each_intervention, is_intervention_enabled = ref$.is_intervention_enabled, get_time_since_intervention = ref$.get_time_since_intervention, get_intervention_info = ref$.get_intervention_info, get_interventions = ref$.get_interventions, get_intersection = ref$.get_intersection, list_enabled_interventions_for_goal = ref$.list_enabled_interventions_for_goal, get_novelty = ref$.get_novelty, filter_interventions_by_temporary_difficulty = ref$.filter_interventions_by_temporary_difficulty;
ref$ = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls"), get_enabled_goals = ref$.get_enabled_goals, get_goals = ref$.get_goals, get_is_goal_frequent = ref$.get_is_goal_frequent;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), getkey_dictdict = ref$.getkey_dictdict, setkey_dictdict = ref$.setkey_dictdict, getvar_experiment = ref$.getvar_experiment, setvar_experiment = ref$.setvar_experiment;
as_array = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls").as_array;
ref$ = __webpack_require__(/*! libs_backend/multi_armed_bandit_thompson */ "./src/libs_backend/multi_armed_bandit_thompson.ls"), train_multi_armed_bandit_for_goal = ref$.train_multi_armed_bandit_for_goal, ThompsonMAB = ref$.ThompsonMAB;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.one_random_intervention_per_enabled_goal = one_random_intervention_per_enabled_goal = async function(enabled_goals){
  var enabled_interventions, goals, all_interventions, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  all_interventions = (await get_interventions());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    console.log('one_random_intervention_per_enabled_goal');
    console.log(available_interventions);
    available_interventions = filter_interventions_by_temporary_difficulty(available_interventions, all_interventions);
    console.log('after filtering');
    console.log(available_interventions);
    selected_intervention = shuffled(available_interventions)[0];
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.one_random_intervention_per_enabled_goal_with_frequency = one_random_intervention_per_enabled_goal_with_frequency = async function(enabled_goals){
  var enabled_interventions, goals, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, is_frequent, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    is_frequent = (await get_is_goal_frequent(goal_name));
    if (!is_frequent && Math.random() > 0.2) {
      continue;
    }
    selected_intervention = shuffled(available_interventions)[0];
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
/*
export one_random_intervention_per_enabled_goal = (enabled_goals) ->>
  if not enabled_goals?
    enabled_goals = await get_enabled_goals()
  manually_enabled_interventions = await get_most_recent_manually_enabled_interventions()
  manually_enabled_interventions_list = as_array manually_enabled_interventions
  manually_disabled_interventions = await get_most_recent_manually_disabled_interventions()
  manually_disabled_interventions_list = as_array manually_disabled_interventions
  goals = await get_goals()
  output = []
  output_set = {}
  for goal_name,goal_enabled of enabled_goals
    goal_info = goals[goal_name]
    interventions = goal_info.interventions
    # do any manually enabled interventions already satisfy this goal? if yes we don't need to select one
    should_select_intervention = true
    for intervention in interventions
      if manually_enabled_interventions[intervention]
        should_select_intervention = false
        break
    if not should_select_intervention
      continue
    # what interventions are available that have not been manually disabled?
    available_interventions = [intervention for intervention in interventions when not manually_disabled_interventions[intervention]]
    if available_interventions.length == 0
      continue
    selected_intervention = shuffled(available_interventions)[0]
    output.push selected_intervention
    output_set[selected_intervention] = true
  return prelude.sort(output)
*/
/*
export each_intervention_enabled_with_probability_half = (enabled_goals) ->>
  interventions = await list_available_interventions_for_enabled_goals()
  return prelude.sort [x for x in interventions when Math.random() < 0.5]

export one_intervention_per_goal_multi_armed_bandit = (enabled_goals) ->>
  if not enabled_goals?
    enabled_goals = await get_enabled_goals()
  manually_enabled_interventions = await get_most_recent_manually_enabled_interventions()
  manually_enabled_interventions_list = as_array manually_enabled_interventions
  manually_disabled_interventions = await get_most_recent_manually_disabled_interventions()
  manually_disabled_interventions_list = as_array manually_disabled_interventions
  goals = await get_goals()
  output = []
  output_set = {}
  for goal_name,goal_enabled of enabled_goals
    goal_info = goals[goal_name]
    interventions = goal_info.interventions
    # do any manually enabled interventions already satisfy this goal? if yes we don't need to select one
    should_select_intervention = true
    for intervention in interventions
      if manually_enabled_interventions[intervention]
        should_select_intervention = false
        break
    if not should_select_intervention
      continue
    # what interventions are available that have not been manually disabled?
    available_interventions = [intervention for intervention in interventions when not manually_disabled_interventions[intervention]]
    if available_interventions.length == 0
      continue
    selected_intervention = await multi_armed_bandit.get_next_intervention_to_test_for_goal(goal_name, available_interventions)
    output.push selected_intervention
    output_set[selected_intervention] = true
  return prelude.sort(output)

selection_algorithms = {
  'one_intervention_per_goal_multi_armed_bandit': one_intervention_per_goal_multi_armed_bandit
  'one_random_intervention_per_enabled_goal': one_random_intervention_per_enabled_goal
  'each_intervention_enabled_with_probability_half': each_intervention_enabled_with_probability_half
  'default': one_intervention_per_goal_multi_armed_bandit
}

export get_intervention_selection_algorithm = ->>
  algorithm_name = localStorage.getItem('selection_algorithm')
  if not (algorithm_name? and selection_algorithms[algorithm_name]?)
    algorithm_name = 'default'
  return selection_algorithms[algorithm_name]
*/
/*
export experiment_always_same = (enabled_goals) ->>
  if not enabled_goals?
    enabled_goals = await get_enabled_goals()
  enabled_interventions = await get_enabled_interventions()
  goals = await get_goals()
  output = []
  output_set = {}
  for goal_name,goal_enabled of enabled_goals
    goal_info = goals[goal_name]
    if (not goal_info?) or (not goal_info.interventions?)
      continue
    interventions = goal_info.interventions
    # what interventions are available that have not been disabled?
    available_interventions = [intervention for intervention in interventions when enabled_interventions[intervention]]
    if available_interventions.length == 0
      continue
    selected_intervention = await getkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_always_same_intervention')
    if not selected_intervention? or available_interventions.indexOf(selected_intervention) == -1
      selected_intervention = shuffled(available_interventions)[0]
      await setkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_always_same_intervention', selected_intervention)
    output.push selected_intervention
    output_set[selected_intervention] = true
  return prelude.sort(output)
*/
try_parse_json = function(text){
  var e;
  if (typeof text !== 'string') {
    return;
  }
  try {
    return JSON.parse(text);
  } catch (e$) {
    e = e$;
  }
};
is_within_n_days_ago = function(date, n){
  var i$, ref$, len$, i;
  for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
    i = ref$[i$];
    if (moment().subtract(i, 'day').format('YYYYMMDD') === date) {
      return true;
    }
  }
  return false;
  function fn$(){
    var i$, to$, results$ = [];
    for (i$ = 0, to$ = n; i$ < to$; ++i$) {
      results$.push(i$);
    }
    return results$;
  }
};
how_many_days_ago = function(date){
  var i$, ref$, len$, i;
  for (i$ = 0, len$ = (ref$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]).length; i$ < len$; ++i$) {
    i = ref$[i$];
    if (moment().subtract(i, 'day').format('YYYYMMDD') === date) {
      return i;
    }
  }
  return -1;
};
is_experiment_still_running = function(experiment_info){
  var conditionduration, conditions, numconditions, day, totalduration;
  if (experiment_info == null) {
    return false;
  }
  conditionduration = experiment_info.conditionduration;
  if (conditionduration == null) {
    return false;
  }
  conditions = experiment_info.conditions;
  if (conditions == null) {
    return false;
  }
  numconditions = conditions.length;
  if (numconditions == null) {
    return false;
  }
  day = experiment_info.day;
  if (day == null) {
    return false;
  }
  totalduration = conditionduration * numconditions;
  return is_within_n_days_ago(day, totalduration);
};
get_current_condition_for_experiment = function(experiment_info){
  var days_since_experiment_start, conditionduration, conditionidx, condition;
  if (!is_experiment_still_running(experiment_info)) {
    return;
  }
  days_since_experiment_start = how_many_days_ago(experiment_info.day);
  conditionduration = experiment_info.conditionduration;
  conditionidx = Math.floor(days_since_experiment_start / conditionduration);
  condition = experiment_info.conditions[conditionidx];
  return condition;
};
choose_among_interventions_random = async function(available_interventions, goal_name){
  var selected_intervention;
  selected_intervention = shuffled(available_interventions)[0];
  return selected_intervention;
};
choose_among_interventions_same = async function(available_interventions, goal_name){
  var curday, selected_intervention_info, selected_intervention;
  curday = moment().format('YYYYMMDD');
  selected_intervention_info = (await getkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_always_same_intervention_info'));
  selected_intervention = null;
  selected_intervention_info = try_parse_json(selected_intervention_info);
  if (selected_intervention_info != null) {
    selected_intervention = selected_intervention_info.intervention;
  }
  if (selected_intervention == null || available_interventions.indexOf(selected_intervention) === -1) {
    selected_intervention = shuffled(available_interventions)[0];
    (await setkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_always_same_intervention_info', JSON.stringify({
      day: curday,
      intervention: selected_intervention
    })));
  }
  return selected_intervention;
};
choose_among_interventions_oneperday = async function(available_interventions, goal_name){
  var curday, selected_intervention_info, selected_intervention, day;
  curday = moment().format('YYYYMMDD');
  selected_intervention_info = (await getkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_oneperday_intervention_info'));
  selected_intervention = null;
  selected_intervention_info = try_parse_json(selected_intervention_info);
  if (selected_intervention_info != null) {
    day = selected_intervention_info.day;
    if (is_within_n_days_ago(day, 1)) {
      selected_intervention = selected_intervention_info.intervention;
    }
  }
  if (selected_intervention == null || available_interventions.indexOf(selected_intervention) === -1) {
    selected_intervention = shuffled(available_interventions)[0];
    (await setkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_oneperday_intervention_info', JSON.stringify({
      day: curday,
      intervention: selected_intervention
    })));
  }
  return selected_intervention;
};
choose_among_interventions_onepertwodays = async function(available_interventions, goal_name){
  var curday, selected_intervention_info, selected_intervention, day;
  curday = moment().format('YYYYMMDD');
  selected_intervention_info = (await getkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_onepertwodays_intervention_info'));
  selected_intervention = null;
  selected_intervention_info = try_parse_json(selected_intervention_info);
  if (selected_intervention_info != null) {
    day = selected_intervention_info.day;
    if (is_within_n_days_ago(day, 2)) {
      selected_intervention = selected_intervention_info.intervention;
    }
  }
  if (selected_intervention == null || available_interventions.indexOf(selected_intervention) === -1) {
    selected_intervention = shuffled(available_interventions)[0];
    (await setkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_onepertwodays_intervention_info', JSON.stringify({
      day: curday,
      intervention: selected_intervention
    })));
  }
  return selected_intervention;
};
choose_among_interventions_oneperthreedays = async function(available_interventions, goal_name){
  var curday, selected_intervention_info, selected_intervention, day;
  curday = moment().format('YYYYMMDD');
  selected_intervention_info = (await getkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_oneperthreedays_intervention_info'));
  selected_intervention = null;
  selected_intervention_info = try_parse_json(selected_intervention_info);
  if (selected_intervention_info != null) {
    day = selected_intervention_info.day;
    if (is_within_n_days_ago(day, 3)) {
      selected_intervention = selected_intervention_info.intervention;
    }
  }
  if (selected_intervention == null || available_interventions.indexOf(selected_intervention) === -1) {
    selected_intervention = shuffled(available_interventions)[0];
    (await setkey_dictdict('experiment_vars_for_goal', goal_name, 'experiment_oneperthreedays_intervention_info', JSON.stringify({
      day: curday,
      intervention: selected_intervention
    })));
  }
  return selected_intervention;
};
out$.choose_among_interventions_by_rule = choose_among_interventions_by_rule = async function(available_interventions, goal_name, rule){
  var selection_algorithm;
  selection_algorithm = {
    'random': choose_among_interventions_random,
    'same': choose_among_interventions_same,
    'oneperday': choose_among_interventions_oneperday,
    'onepertwodays': choose_among_interventions_onepertwodays,
    'oneperthreedays': choose_among_interventions_oneperthreedays
  }[rule];
  return (await selection_algorithm(available_interventions, goal_name));
};
out$.experiment_always_same = experiment_always_same = async function(enabled_goals){
  var enabled_interventions, goals, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, 'same'));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_oneperday = experiment_oneperday = async function(enabled_goals){
  var enabled_interventions, goals, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, 'oneperday'));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_onepertwodays = experiment_onepertwodays = async function(enabled_goals){
  var enabled_interventions, goals, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, 'onepertwodays'));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_oneperthreedays = experiment_oneperthreedays = async function(enabled_goals){
  var enabled_interventions, goals, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, 'oneperthreedays'));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_alternate_between_same_vs_random_daily_deterministic = experiment_alternate_between_same_vs_random_daily_deterministic = async function(enabled_goals){
  var enabled_interventions, goals, experiment_info, curday, condition, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  experiment_info = (await getvar_experiment('experiment_alternate_between_same_vs_random_daily_deterministic'));
  experiment_info = try_parse_json(experiment_info);
  if (experiment_info == null) {
    experiment_info = {};
  }
  curday = moment().format('YYYYMMDD');
  if (is_experiment_still_running(experiment_info)) {
    condition = get_current_condition_for_experiment(experiment_info);
  } else {
    if (experiment_info.conditions == null) {
      experiment_info.conditions = shuffled(['random', 'same']);
    }
    experiment_info.conditionduration = 1;
    experiment_info.day = curday;
    condition = get_current_condition_for_experiment(experiment_info);
    (await setvar_experiment('experiment_alternate_between_same_vs_random_daily_deterministic', JSON.stringify(experiment_info)));
  }
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, condition));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_alternate_between_same_vs_random_varlength_deterministic = experiment_alternate_between_same_vs_random_varlength_deterministic = async function(enabled_goals){
  var enabled_interventions, goals, experiment_info, curday, condition, duration_options, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  experiment_info = (await getvar_experiment('experiment_alternate_between_same_vs_random_varlength_deterministic'));
  experiment_info = try_parse_json(experiment_info);
  if (experiment_info == null) {
    experiment_info = {};
  }
  curday = moment().format('YYYYMMDD');
  if (is_experiment_still_running(experiment_info)) {
    condition = get_current_condition_for_experiment(experiment_info);
  } else {
    if (experiment_info.conditions == null) {
      experiment_info.conditions = shuffled(['random', 'same']);
    }
    duration_options = [1, 3, 5, 7];
    experiment_info.conditionduration = duration_options[Math.floor(Math.random() * duration_options.length)];
    experiment_info.day = curday;
    condition = get_current_condition_for_experiment(experiment_info);
    (await setvar_experiment('experiment_alternate_between_same_vs_random_varlength_deterministic', JSON.stringify(experiment_info)));
  }
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, condition));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
out$.experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare = experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare = async function(enabled_goals){
  var enabled_interventions, goals, experiment_info, curday, condition, output, output_set, goal_name, goal_enabled, goal_info, interventions, available_interventions, res$, i$, len$, intervention, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  goals = (await get_goals());
  experiment_info = (await getvar_experiment('experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare'));
  experiment_info = try_parse_json(experiment_info);
  if (experiment_info == null) {
    experiment_info = {};
  }
  curday = moment().format('YYYYMMDD');
  if (is_experiment_still_running(experiment_info)) {
    condition = get_current_condition_for_experiment(experiment_info);
  } else {
    if (experiment_info.conditions == null) {
      experiment_info.conditions = shuffled(['random', 'same']);
    }
    if (experiment_info.duration_order == null) {
      experiment_info.duration_order = shuffled([1, 3, 5, 7]);
    }
    if (experiment_info.duration_idx == null) {
      experiment_info.duration_idx = 0;
    } else {
      experiment_info.duration_idx = (experiment_info.duration_idx + 1) % experiment_info.duration_order.length;
    }
    experiment_info.conditionduration = experiment_info.duration_order[experiment_info.duration_idx];
    experiment_info.day = curday;
    condition = get_current_condition_for_experiment(experiment_info);
    (await setvar_experiment('experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare', JSON.stringify(experiment_info)));
  }
  output = [];
  output_set = {};
  for (goal_name in enabled_goals) {
    goal_enabled = enabled_goals[goal_name];
    goal_info = goals[goal_name];
    if (goal_info == null || goal_info.interventions == null) {
      continue;
    }
    interventions = goal_info.interventions;
    res$ = [];
    for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
      intervention = interventions[i$];
      if (enabled_interventions[intervention]) {
        res$.push(intervention);
      }
    }
    available_interventions = res$;
    if (available_interventions.length === 0) {
      continue;
    }
    selected_intervention = (await choose_among_interventions_by_rule(available_interventions, goal_name, condition));
    output.push(selected_intervention);
    output_set[selected_intervention] = true;
  }
  return prelude.sort(output);
};
/**
 * This selection algorithm recommends an intervention for each goal using the Thompson Sampling Algorithm.
  * @return List of intervention names (strings), one intervention for each user goal.
 */
out$.thompsonsampling = thompsonsampling = async function(enabled_goals){
  var res$, goal_name, value, output, i$, len$, enabled_interventions, is_frequent, mab, selected_intervention;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  res$ = [];
  for (goal_name in enabled_goals) {
    value = enabled_goals[goal_name];
    res$.push(goal_name);
  }
  enabled_goals = res$;
  output = [];
  for (i$ = 0, len$ = enabled_goals.length; i$ < len$; ++i$) {
    goal_name = enabled_goals[i$];
    enabled_interventions = (await list_enabled_interventions_for_goal(goal_name));
    if (enabled_interventions.length === 0) {
      continue;
    }
    is_frequent = (await get_is_goal_frequent(goal_name));
    if (!is_frequent && Math.random() > 0.2) {
      continue;
    }
    mab = (await train_multi_armed_bandit_for_goal(goal_name, enabled_interventions));
    selected_intervention = mab.predict();
    output.push(selected_intervention);
  }
  return prelude.sort(output);
};
/**
 * This selection algorithm ranks the interventions from lowest to highest novelty, prioritizing 
 * the least recently seen interventions over the most recently seen interventions.
 * @return List of intervention names (strings), one intervention for each user goal.
 */
out$.novelty = novelty = async function(enabled_goals){
  var enabled_interventions, novel_interventions, output, intervention_name, enabled, intervention, time, i$, ref$, len$, goal_name;
  if (enabled_goals == null) {
    enabled_goals = (await get_enabled_goals());
  }
  enabled_interventions = (await get_enabled_interventions());
  novel_interventions = {};
  output = [];
  for (intervention_name in enabled_interventions) {
    enabled = enabled_interventions[intervention_name];
    intervention = (await get_intervention_info(intervention_name));
    time = (await get_time_since_intervention(intervention_name));
    for (i$ = 0, len$ = (ref$ = intervention.goals).length; i$ < len$; ++i$) {
      goal_name = ref$[i$];
      if (goal_name in enabled_goals && (novel_interventions[goal_name] == null || novel_interventions[goal_name].time < time)) {
        novel_interventions[goal_name] = {
          intervention: intervention_name,
          time: time
        };
      }
    }
  }
  for (goal_name in enabled_goals) {
    output.push(novel_interventions[goal_name].intervention);
  }
  return prelude.sort(output);
};
/**
 * Generates thompson-novely combo algorithm given weight (% of reward that should be from sampling)
 * Precondition: @param weight must be between 0 and 1, inclusive.
 */
out$.thompson_novelty = thompson_novelty = function(weight){
  var denominator, sample_coefficient, novelty_coefficient;
  denominator = 0;
  if (weight < 0.5 && weight > 0) {
    denominator = 1 / weight;
  } else if (weight > 0 && weight < 1) {
    denominator = 1 / (1 - weight);
  } else {
    denominator = 1;
  }
  sample_coefficient = weight * denominator;
  novelty_coefficient = (1 - weight) * denominator;
  return async function(enabled_goals){
    var res$, goal_name, value, output, i$, len$, enabled_interventions, mab, novelty, selected_intervention;
    if (enabled_goals == null) {
      enabled_goals = (await get_enabled_goals());
    }
    res$ = [];
    for (goal_name in enabled_goals) {
      value = enabled_goals[goal_name];
      res$.push(goal_name);
    }
    enabled_goals = res$;
    output = [];
    for (i$ = 0, len$ = enabled_goals.length; i$ < len$; ++i$) {
      goal_name = enabled_goals[i$];
      enabled_interventions = (await list_enabled_interventions_for_goal(goal_name));
      if (enabled_interventions.length === 0) {
        continue;
      }
      mab = (await train_multi_armed_bandit_for_goal(goal_name, enabled_interventions, sample_coefficient, novelty_coefficient));
      novelty = (await get_novelty(enabled_interventions));
      selected_intervention = mab.predict(novelty);
      output.push(selected_intervention);
    }
    return prelude.sort(output);
  };
};
selection_algorithms_for_visit = {
  'thompsonnovelty05': thompson_novelty(0.5),
  'thompsonnovelty075': thompson_novelty(0.75),
  'thompsonnovelty09': thompson_novelty(0.9),
  'novelty': novelty,
  'thompsonsampling': thompsonsampling,
  'random': one_random_intervention_per_enabled_goal,
  'one_random_intervention_per_enabled_goal': one_random_intervention_per_enabled_goal,
  'one_random_intervention_per_enabled_goal_with_frequency': one_random_intervention_per_enabled_goal,
  'default': one_random_intervention_per_enabled_goal,
  'experiment_always_same': experiment_always_same,
  'experiment_oneperday': experiment_oneperday,
  'experiment_onepertwodays': experiment_onepertwodays,
  'experiment_oneperthreedays': experiment_oneperthreedays,
  'experiment_alternate_between_same_vs_random_daily_deterministic': experiment_alternate_between_same_vs_random_daily_deterministic,
  'experiment_alternate_between_same_vs_random_varlength_deterministic': experiment_alternate_between_same_vs_random_varlength_deterministic,
  'experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare': experiment_alternate_between_same_vs_random_varlength_deterministic_latinsquare
};
out$.get_intervention_selection_algorithm_for_visit = get_intervention_selection_algorithm_for_visit = async function(){
  var algorithm_name;
  algorithm_name = localStorage.getItem('selection_algorithm_for_visit');
  if (!(algorithm_name != null && selection_algorithms_for_visit[algorithm_name] != null)) {
    algorithm_name = 'default';
  }
  return selection_algorithms_for_visit[algorithm_name];
};
multi_armed_bandit = __webpack_require__(/*! libs_backend/multi_armed_bandit */ "./src/libs_backend/multi_armed_bandit.ls").get_multi_armed_bandit_algorithm('thompson');
gexport_module('intervention_selection_algorithms', function(it){
  return eval(it);
});
//# sourceMappingURL=intervention_selection_algorithms.ls.map


/***/ }),

/***/ "./src/libs_backend/intervention_session_vars_backend.js":
/*!***************************************************************!*\
  !*** ./src/libs_backend/intervention_session_vars_backend.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const intervention_to_session_id_to_vars = {}

async function get_intervention_session_var_backend(intervention_name, session_id, key) {
  console.log('get_intervention_session_var_backend')
  console.log(intervention_name)
  console.log(session_id)
  console.log(key)
  console.log(intervention_to_session_id_to_vars)
  if (intervention_to_session_id_to_vars[intervention_name] != null && intervention_to_session_id_to_vars[intervention_name][session_id] != null && intervention_to_session_id_to_vars[intervention_name][session_id][key] != null) {
    return intervention_to_session_id_to_vars[intervention_name][session_id][key]
  }
  return
}

async function set_intervention_session_var_backend(intervention_name, session_id, key, val) {
  if (intervention_to_session_id_to_vars[intervention_name] == null) {
    intervention_to_session_id_to_vars[intervention_name] = {}
  }
  if (intervention_to_session_id_to_vars[intervention_name][session_id] == null) {
    intervention_to_session_id_to_vars[intervention_name][session_id] = {}
  }
  intervention_to_session_id_to_vars[intervention_name][session_id][key] = val
}

module.exports = {
  get_intervention_session_var_backend,
  set_intervention_session_var_backend,
}


/***/ }),

/***/ "./src/libs_backend/intervention_utils.ls":
/*!************************************************!*\
  !*** ./src/libs_backend/intervention_utils.ls ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var moment, shuffled, prelude, median, memoizeSingleAsync, ref$, setkey_dictdict, getkey_dictdict, setkey_dict, getkey_dict, getdict_for_key_dictdict, getvar, setvar, setvar_experiment, getlog, get_baseline_session_time_on_domain, url_to_domain, gexport, gexport_module, get_days_since_epoch, as_dictset, as_array, remove_keys_matching_patternfunc_from_localstorage_dict, remove_items_matching_patternfunc_from_localstorage_list, remove_key_from_localstorage_dict, remove_item_from_localstorage_list, remove_keys_from_localstorage_dict, remove_items_from_localstorage_list, unique_concat, localget_json, set_override_enabled_interventions_once, get_enabled_interventions_with_override, get_enabled_interventions_with_override_for_visit, is_between_times, count_as_yesterday, is_it_outside_work_hours, list_enabled_interventions, get_enabled_interventions, set_enabled_interventions, default_generic_interventions_list, default_generic_positive_interventions_list, list_enabled_generic_interventions, list_enabled_generic_positive_interventions, set_default_generic_interventions_enabled, set_interventions_enabled, set_intervention_enabled, set_intervention_disabled_permanently, set_intervention_disabled, is_intervention_enabled, record_intensity_level_for_intervention, get_intensity_level_for_intervention, list_interventions_and_num_log_items, list_interventions_that_have_been_seen, list_interventions_that_have_not_been_seen, list_possible_intervention_suggestions, get_enabled_interventions_for_url_that_have_not_been_seen, list_possible_intervention_suggestions_for_url, get_suggested_intervention_if_needed_for_url, video_domains_set, is_video_domain, enabledisable_interventions_based_on_difficulty, intervention_first_seen_power_enabledisable, set_subinterventions_enabled_for_generic_intervention, set_subinterventions_disabled_for_generic_intervention, list_subinterventions_for_generic_intervention, generate_interventions_for_domain, generate_interventions_for_positive_domain, add_new_intervention, list_custom_interventions, add_new_interventions, remove_all_custom_interventions, remove_generated_interventions_for_domain, remove_custom_intervention, list_generic_interventions, list_generic_positive_interventions, list_video_interventions, list_all_interventions, clear_extra_interventions_and_cache, clear_cache_all_interventions, clear_cache_list_all_interventions, get_intervention_info, fix_intervention_info, fix_intervention_name_to_intervention_info_dict, get_interventions_per_goal, get_intervention_choosing_strategy, select_subset_of_available_interventions, get_interventions, clear_cache_get_interventions, list_enabled_interventions_for_location, list_all_enabled_interventions_for_location, list_enabled_nonconflicting_interventions_for_location, list_available_interventions_for_location, filter_interventions_by_temporary_difficulty, filter_interventions_to_best_match_difficulty, set_temporary_difficulty, set_asknext_time, get_manually_managed_interventions_localstorage, get_manually_managed_interventions, set_manually_managed_interventions, set_intervention_manually_managed, set_intervention_automatically_managed, list_available_interventions_for_enabled_goals, list_available_interventions_for_goal, list_enabled_interventions_for_goal, cast_to_bool, cast_to_type, set_intervention_parameter, get_intervention_parameter_type, get_intervention_parameter_default, get_intervention_parameters_default, get_intervention_parameter, get_intervention_parameters, get_number_sessions_for_each_intervention, get_seconds_spent_on_domain_for_each_intervention, get_seconds_spent_for_each_session_per_intervention, get_seconds_saved_per_session_for_each_intervention_for_goal, get_seconds_spent_per_session_for_each_intervention_for_goal, get_goals_and_interventions, get_nonpositive_goals_and_interventions, get_time_since_intervention, get_novelty, choose_intervention_for_difficulty_level_and_goal, choose_intervention_for_each_difficulty_level_and_goal, intervention_manager, goal_utils, log_utils, intervention_selection_algorithms, out$ =  true && exports || this;
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
shuffled = __webpack_require__(/*! shuffled */ "./node_modules/shuffled/index.js");
prelude = __webpack_require__(/*! prelude-ls */ "./node_modules/prelude-ls/lib/index.js");
median = __webpack_require__(/*! libs_common/math_utils */ "./src/libs_common/math_utils.js").median;
memoizeSingleAsync = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoizeSingleAsync;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), setkey_dictdict = ref$.setkey_dictdict, getkey_dictdict = ref$.getkey_dictdict, setkey_dict = ref$.setkey_dict, getkey_dict = ref$.getkey_dict, getdict_for_key_dictdict = ref$.getdict_for_key_dictdict, getvar = ref$.getvar, setvar = ref$.setvar, setvar_experiment = ref$.setvar_experiment;
getlog = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls").getlog;
get_baseline_session_time_on_domain = __webpack_require__(/*! libs_backend/history_utils */ "./src/libs_backend/history_utils.ls").get_baseline_session_time_on_domain;
url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
ref$ = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls"), as_dictset = ref$.as_dictset, as_array = ref$.as_array, remove_keys_matching_patternfunc_from_localstorage_dict = ref$.remove_keys_matching_patternfunc_from_localstorage_dict, remove_items_matching_patternfunc_from_localstorage_list = ref$.remove_items_matching_patternfunc_from_localstorage_list, remove_key_from_localstorage_dict = ref$.remove_key_from_localstorage_dict, remove_item_from_localstorage_list = ref$.remove_item_from_localstorage_list, remove_keys_from_localstorage_dict = ref$.remove_keys_from_localstorage_dict, remove_items_from_localstorage_list = ref$.remove_items_from_localstorage_list;
unique_concat = __webpack_require__(/*! libs_common/array_utils */ "./src/libs_common/array_utils.ls").unique_concat;
localget_json = __webpack_require__(/*! libs_common/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls").localget_json;
/*
cached_get_intervention_info = {}
cached_get_intervention_info_unmodified = {}

getInterventionInfo = (intervention_name) ->>
  cached_val = cached_get_intervention_info[intervention_name]
  if cached_val?
    return JSON.parse JSON.stringify cached_val
  cached_val = cached_get_intervention_info_unmodified[intervention_name]
  if cached_val?
    return JSON.parse JSON.stringify cached_val
  intervention_info = await localget_json("/interventions/#{intervention_name}/info.json")
  intervention_info.name = intervention_name
  intervention_info.sitename = intervention_name.split('/')[0]
  cached_get_intervention_info[intervention_name] = intervention_info
  cached_get_intervention_info_unmodified[intervention_name] = intervention_info
  return intervention_info
*/
out$.set_override_enabled_interventions_once = set_override_enabled_interventions_once = function(intervention_name){
  localStorage.setItem('override_enabled_interventions_once', JSON.stringify([intervention_name]));
};
out$.get_enabled_interventions_with_override = get_enabled_interventions_with_override = async function(){
  var override_enabled_interventions, enabled_interventions;
  override_enabled_interventions = localStorage.getItem('override_enabled_interventions_once');
  if (override_enabled_interventions != null) {
    return as_dictset(JSON.parse(override_enabled_interventions));
  }
  enabled_interventions = (await intervention_manager.get_enabled_interventions_for_today());
  return enabled_interventions;
};
out$.get_enabled_interventions_with_override_for_visit = get_enabled_interventions_with_override_for_visit = async function(){
  var override_enabled_interventions, enabled_interventions;
  override_enabled_interventions = localStorage.getItem('override_enabled_interventions_once');
  if (override_enabled_interventions != null) {
    return as_dictset(JSON.parse(override_enabled_interventions));
  }
  enabled_interventions = (await intervention_manager.get_enabled_interventions_for_visit());
  return enabled_interventions;
};
/*
export get_enabled_interventions = ->>
  enabled_interventions = await intervention_manager.get_enabled_interventions_for_today()
  return enabled_interventions

export set_enabled_interventions = (enabled_interventions) ->>
  await intervention_manager.set_enabled_interventions_for_today_manual enabled_interventions
  return
*/
is_between_times = function(time, start, end){
  if (start > end) {
    return start <= time || time <= end;
  }
  return start <= time && time <= end;
};
count_as_yesterday = function(time, start, end){
  return time < end && end < start;
};
out$.is_it_outside_work_hours = is_it_outside_work_hours = function(){
  var work_hours_only, ref$, start_mins_since_midnight, end_mins_since_midnight, activedaysarray, mins_since_midnight, day, today_idx;
  work_hours_only = (ref$ = localStorage.work_hours_only) != null ? ref$ : 'false', start_mins_since_midnight = (ref$ = localStorage.start_mins_since_midnight) != null ? ref$ : '0', end_mins_since_midnight = (ref$ = localStorage.end_mins_since_midnight) != null ? ref$ : '1440', activedaysarray = localStorage.activedaysarray;
  work_hours_only = work_hours_only === 'true';
  start_mins_since_midnight = parseInt(start_mins_since_midnight);
  end_mins_since_midnight = parseInt(end_mins_since_midnight);
  mins_since_midnight = moment().hours() * 60 + moment().minutes();
  if (work_hours_only) {
    if (!is_between_times(mins_since_midnight, start_mins_since_midnight, end_mins_since_midnight)) {
      return true;
    }
    if (activedaysarray != null) {
      activedaysarray = JSON.parse(activedaysarray);
      day = moment();
      if (count_as_yesterday(mins_since_midnight, start_mins_since_midnight, end_mins_since_midnight)) {
        day.subtract(1, 'day');
      }
      today_idx = day.weekday();
      if (!activedaysarray.includes(today_idx)) {
        return true;
      }
    }
  }
  return false;
};
/**
 * Returns a list of names of enabled interventions
 * @return {Promise.<Array.<InterventionName>>} List of enabled intervention names
 */
out$.list_enabled_interventions = list_enabled_interventions = async function(){
  var enabled_interventions;
  enabled_interventions = (await intervention_manager.get_currently_enabled_interventions());
  return as_array(enabled_interventions);
};
/**
 * Returns a object with with names of enabled interventions as keys, and whether they are enabled as values
 * @return {Promise.<Object.<InterventionName, boolean>>} Object with enabled interventions as keys
 */
out$.get_enabled_interventions = get_enabled_interventions = async function(){
  var enabled_interventions;
  enabled_interventions = (await intervention_manager.get_currently_enabled_interventions());
  return enabled_interventions;
};
out$.set_enabled_interventions = set_enabled_interventions = async function(enabled_interventions){
  return (await intervention_manager.set_currently_enabled_interventions_manual(enabled_interventions));
};
/*
export set_intervention_enabled = (intervention_name) ->>
  enabled_interventions = await get_enabled_interventions()
  if enabled_interventions[intervention_name]
    return
  enabled_interventions[intervention_name] = true
  await set_enabled_interventions enabled_interventions

export set_intervention_disabled_permanently = (intervention_name) ->>
  await set_intervention_manually_managed intervention_name
  enabled_interventions = await get_enabled_interventions()
  if not enabled_interventions[intervention_name]
    return
  enabled_interventions[intervention_name] = false
  await set_enabled_interventions enabled_interventions

export set_intervention_disabled = (intervention_name) ->>
  enabled_interventions = await get_enabled_interventions()
  if not enabled_interventions[intervention_name]
    return
  enabled_interventions[intervention_name] = false
  await set_enabled_interventions enabled_interventions
*/
default_generic_interventions_list = ['generic/block_after_interval_per_visit', 'generic/close_tab_timer', 'generic/make_user_wait', 'generic/prompt_reason', 'generic/scroll_blocker', 'generic/show_timer_banner', 'generic/show_user_info_banner', 'generic/show_user_info_interstitial', 'generic/toast_notifications'];
default_generic_positive_interventions_list = ['generic_positive/feed_injection_positive_goal_widget'];
out$.list_enabled_generic_interventions = list_enabled_generic_interventions = async function(){
  var enabled_interventions, output, k, v;
  enabled_interventions = (await get_enabled_interventions());
  output = [];
  for (k in enabled_interventions) {
    v = enabled_interventions[k];
    if (v && k.startsWith('generic/')) {
      output.push(k);
    }
  }
  if (output.length === 0) {
    return default_generic_interventions_list;
  }
  return output;
};
out$.list_enabled_generic_positive_interventions = list_enabled_generic_positive_interventions = async function(){
  var enabled_interventions, output, k, v;
  enabled_interventions = (await get_enabled_interventions());
  output = [];
  for (k in enabled_interventions) {
    v = enabled_interventions[k];
    if (v && k.startsWith('generic_positive/')) {
      output.push(k);
    }
  }
  if (output.length === 0) {
    return default_generic_positive_interventions_list;
  }
  return output;
};
out$.set_default_generic_interventions_enabled = set_default_generic_interventions_enabled = async function(){
  (await set_interventions_enabled(default_generic_interventions_list.concat(default_generic_positive_interventions_list)));
};
out$.set_interventions_enabled = set_interventions_enabled = async function(intervention_name_list){
  var i$, len$, x;
  for (i$ = 0, len$ = intervention_name_list.length; i$ < len$; ++i$) {
    x = intervention_name_list[i$];
    (await set_intervention_enabled(x));
  }
};
out$.set_intervention_enabled = set_intervention_enabled = async function(intervention_name){
  var is_disabled;
  is_disabled = (await intervention_manager.get_is_intervention_disabled_from_intervention_manager(intervention_name));
  if (is_disabled === false) {
    return;
  }
  (await intervention_manager.set_intervention_enabled_from_intervention_manager(intervention_name));
};
out$.set_intervention_disabled_permanently = set_intervention_disabled_permanently = async function(intervention_name){
  var is_disabled;
  is_disabled = (await intervention_manager.get_is_intervention_disabled_from_intervention_manager(intervention_name));
  if (is_disabled === true) {
    return;
  }
  (await intervention_manager.set_intervention_disabled_from_intervention_manager(intervention_name));
};
out$.set_intervention_disabled = set_intervention_disabled = async function(intervention_name){
  var is_disabled;
  is_disabled = (await intervention_manager.get_is_intervention_disabled_from_intervention_manager(intervention_name));
  if (is_disabled === true) {
    return;
  }
  (await intervention_manager.set_intervention_disabled_from_intervention_manager(intervention_name));
};
out$.is_intervention_enabled = is_intervention_enabled = async function(intervention_name){
  var is_disabled;
  is_disabled = (await intervention_manager.get_is_intervention_disabled_from_intervention_manager(intervention_name));
  if (is_disabled === true) {
    return false;
  }
  return true;
};
out$.record_intensity_level_for_intervention = record_intensity_level_for_intervention = async function(intervention_name, generic_name, intensity){
  (await setkey_dict('interventions_to_intensity_ratings', generic_name, intensity));
  return (await log_utils.log_feedback_internal(intervention_name, {
    feedback_type: 'intensity',
    intensity: intensity,
    generic_name: generic_name,
    intervention_name: intervention_name
  }));
};
out$.get_intensity_level_for_intervention = get_intensity_level_for_intervention = async function(intervention_name){
  return (await getkey_dict('interventions_to_intensity_ratings', intervention_name));
};
out$.list_interventions_and_num_log_items = list_interventions_and_num_log_items = async function(){
  var all_interventions, intervention_log_db, intervention_names, intervention_count_promises, intervention_to_generic_name, intervention_name, intervention_info, intervention_log_collection, intervention_counts, intervention_name_to_count, intervention_names_and_counts, i$, len$, ref$, intervention_count, generic_name, intervention_name_to_count_all, generic_count, output;
  all_interventions = (await get_interventions());
  intervention_log_db = (await log_utils.getInterventionLogDb());
  intervention_names = [];
  intervention_count_promises = [];
  intervention_to_generic_name = {};
  for (intervention_name in all_interventions) {
    intervention_info = all_interventions[intervention_name];
    if (intervention_info.generic_intervention != null) {
      intervention_to_generic_name[intervention_name] = intervention_info.generic_intervention;
    }
    intervention_names.push(intervention_name);
    intervention_log_collection = intervention_log_db[intervention_name];
    if (intervention_log_collection == null) {
      intervention_count_promises.push(Promise.resolve(0));
    } else {
      intervention_count_promises.push(intervention_log_collection.count());
    }
  }
  intervention_counts = (await Promise.all(intervention_count_promises));
  intervention_name_to_count = {};
  intervention_names_and_counts = prelude.zip(intervention_names, intervention_counts);
  for (i$ = 0, len$ = intervention_names_and_counts.length; i$ < len$; ++i$) {
    ref$ = intervention_names_and_counts[i$], intervention_name = ref$[0], intervention_count = ref$[1];
    generic_name = intervention_to_generic_name[intervention_name];
    if (generic_name == null) {
      continue;
    }
    if (intervention_name_to_count[generic_name] == null) {
      intervention_name_to_count[generic_name] = intervention_count;
    } else {
      intervention_name_to_count[generic_name] += intervention_count;
    }
  }
  intervention_name_to_count_all = {};
  for (i$ = 0, len$ = intervention_names_and_counts.length; i$ < len$; ++i$) {
    ref$ = intervention_names_and_counts[i$], intervention_name = ref$[0], intervention_count = ref$[1];
    generic_name = intervention_to_generic_name[intervention_name];
    if (generic_name == null) {
      intervention_name_to_count_all[intervention_name] = intervention_count;
    } else {
      generic_count = intervention_name_to_count[generic_name];
      intervention_name_to_count_all[intervention_name] = generic_count;
    }
  }
  output = [];
  for (i$ = 0, len$ = intervention_names_and_counts.length; i$ < len$; ++i$) {
    ref$ = intervention_names_and_counts[i$], intervention_name = ref$[0], intervention_count = ref$[1];
    output.push([intervention_name, intervention_name_to_count_all[intervention_name]]);
  }
  return output;
};
out$.list_interventions_that_have_been_seen = list_interventions_that_have_been_seen = async function(){
  var interventions_and_num_log_items, output, i$, len$, ref$, intervention_name, num_log_items;
  interventions_and_num_log_items = (await list_interventions_and_num_log_items());
  output = [];
  for (i$ = 0, len$ = interventions_and_num_log_items.length; i$ < len$; ++i$) {
    ref$ = interventions_and_num_log_items[i$], intervention_name = ref$[0], num_log_items = ref$[1];
    if (num_log_items > 0) {
      output.push(intervention_name);
    }
  }
  return output;
};
out$.list_interventions_that_have_not_been_seen = list_interventions_that_have_not_been_seen = async function(){
  var interventions_and_num_log_items, output, i$, len$, ref$, intervention_name, num_log_items;
  interventions_and_num_log_items = (await list_interventions_and_num_log_items());
  output = [];
  for (i$ = 0, len$ = interventions_and_num_log_items.length; i$ < len$; ++i$) {
    ref$ = interventions_and_num_log_items[i$], intervention_name = ref$[0], num_log_items = ref$[1];
    if (num_log_items === 0) {
      output.push(intervention_name);
    }
  }
  return output;
};
out$.list_possible_intervention_suggestions = list_possible_intervention_suggestions = async function(){
  var interventions_not_seen, enabled_goals, all_interventions, output, i$, len$, intervention_name, intervention_info, goal_for_intervention, ref$;
  interventions_not_seen = (await list_interventions_that_have_not_been_seen());
  enabled_goals = (await goal_utils.get_enabled_goals());
  all_interventions = (await get_interventions());
  output = [];
  for (i$ = 0, len$ = interventions_not_seen.length; i$ < len$; ++i$) {
    intervention_name = interventions_not_seen[i$];
    intervention_info = all_interventions[intervention_name];
    goal_for_intervention = intervention_info != null ? (ref$ = intervention_info.goals) != null ? ref$[0] : void 8 : void 8;
    if (goal_for_intervention == null) {
      continue;
    }
    if (enabled_goals[goal_for_intervention] !== true) {
      continue;
    }
    output.push(intervention_name);
  }
  return output;
};
out$.get_enabled_interventions_for_url_that_have_not_been_seen = get_enabled_interventions_for_url_that_have_not_been_seen = async function(url){
  var output, enabled_interventions, possible_suggestions, i$, len$, intervention_name;
  output = [];
  enabled_interventions = (await get_enabled_interventions());
  possible_suggestions = (await list_possible_intervention_suggestions_for_url(url));
  for (i$ = 0, len$ = possible_suggestions.length; i$ < len$; ++i$) {
    intervention_name = possible_suggestions[i$];
    if (enabled_interventions[intervention_name]) {
      output.push(intervention_name);
    }
  }
  return output;
};
out$.list_possible_intervention_suggestions_for_url = list_possible_intervention_suggestions_for_url = async function(url){
  var available_interventions, available_interventions_set, possible_intervention_suggestions;
  available_interventions = (await list_available_interventions_for_location(url));
  available_interventions_set = new Set(available_interventions);
  possible_intervention_suggestions = (await list_possible_intervention_suggestions());
  return possible_intervention_suggestions.filter(function(it){
    return available_interventions_set.has(it);
  });
};
out$.get_suggested_intervention_if_needed_for_url = get_suggested_intervention_if_needed_for_url = async function(url){
  var cur_epoch, intervention_suggestion_frequency_days, last_epoch_new_intervention_seen, last_epoch_new_intervention_suggested_or_seen, possible_suggestions, enabled_interventions, i$, len$, intervention_name, random_intervention;
  if (localStorage.suggest_interventions !== 'true') {
    return null;
  }
  cur_epoch = get_days_since_epoch();
  intervention_suggestion_frequency_days = (await (async function(){
    switch (localStorage.intervention_suggestion_algorithm) {
    case '1day':
      return 1;
    case '3day':
      return 3;
    case '5day':
      return 5;
    case '7day':
      return 7;
    case 'always':
      return 0;
    default:
      return 0;
    }
  }()));
  last_epoch_new_intervention_seen = (await getvar('last_epoch_new_intervention_seen'));
  last_epoch_new_intervention_seen = parseInt(last_epoch_new_intervention_seen);
  if (!(last_epoch_new_intervention_seen != null && isFinite(last_epoch_new_intervention_seen))) {
    last_epoch_new_intervention_seen = 0;
  }
  last_epoch_new_intervention_suggested_or_seen = last_epoch_new_intervention_seen;
  if (Math.abs(cur_epoch - last_epoch_new_intervention_suggested_or_seen) < intervention_suggestion_frequency_days) {
    return null;
  }
  possible_suggestions = (await list_possible_intervention_suggestions_for_url(url));
  if (possible_suggestions.length === 0) {
    return null;
  }
  enabled_interventions = (await get_enabled_interventions());
  for (i$ = 0, len$ = possible_suggestions.length; i$ < len$; ++i$) {
    intervention_name = possible_suggestions[i$];
    if (enabled_interventions[intervention_name]) {
      return null;
    }
  }
  random_intervention = possible_suggestions[Math.floor(Math.random() * possible_suggestions.length)];
  return random_intervention;
};
video_domains_set = new Set(['www.iqiyi.com', 'v.youku.com', 'vimeo.com', 'www.youtube.com', 'www.netflix.com', 'www.hulu.com', 'www.dailymotion.com', 'www.iqiyi.com', 'www.youku.com', 'www.bilibili.com', 'www.nicovideo.jp', 'metacafe.com', 'www.veoh.com', 'www.sonycrackle.com', 'www.screenjunkies.com', '9gag.com', 'www.ted.com']);
out$.is_video_domain = is_video_domain = function(domain){
  return video_domains_set.has(domain);
};
out$.enabledisable_interventions_based_on_difficulty = enabledisable_interventions_based_on_difficulty = async function(difficulty){
  var difficulty_numeric_map, difficulty_numeric, all_interventions, prev_enabled_interventions, new_enabled_interventions, changed_interventions, i$, ref$, len$, intervention_name, intervention_info, was_previously_enabled, now_enabled;
  difficulty_numeric_map = {
    'nothing': 0,
    'easy': 1,
    'medium': 2,
    'hard': 3
  };
  difficulty_numeric = difficulty_numeric_map[difficulty];
  all_interventions = (await get_interventions());
  prev_enabled_interventions = (await get_enabled_interventions());
  new_enabled_interventions = {};
  changed_interventions = [];
  for (i$ = 0, len$ = (ref$ = Object.keys(all_interventions)).length; i$ < len$; ++i$) {
    intervention_name = ref$[i$];
    intervention_info = all_interventions[intervention_name];
    was_previously_enabled = prev_enabled_interventions[intervention_name] === true;
    now_enabled = was_previously_enabled;
    if (difficulty === 'nothing') {
      now_enabled = false;
    }
    if (intervention_info.difficulty !== null && difficulty_numeric_map[intervention_info.difficulty] !== null) {
      now_enabled = difficulty_numeric_map[intervention_info.difficulty] <= difficulty_numeric;
    }
    new_enabled_interventions[intervention_name] = now_enabled;
    if (now_enabled !== was_previously_enabled) {
      changed_interventions.push(intervention_name);
    }
  }
  for (i$ = 0, len$ = changed_interventions.length; i$ < len$; ++i$) {
    intervention_name = changed_interventions[i$];
    now_enabled = new_enabled_interventions[intervention_name];
    if (now_enabled) {
      (await set_intervention_enabled(intervention_name));
    } else {
      (await set_intervention_disabled(intervention_name));
    }
  }
};
out$.intervention_first_seen_power_enabledisable = intervention_first_seen_power_enabledisable = async function(intervention, is_enabled, url){
  var is_generic, intervention_name_orig, intervention_name, prev_enabled_interventions, log_intervention_info;
  is_generic = false;
  intervention_name_orig = intervention.name;
  intervention_name = intervention.name;
  if (intervention.generic_intervention != null) {
    intervention_name = intervention.generic_intervention;
    is_generic = true;
  }
  prev_enabled_interventions = (await get_enabled_interventions());
  log_intervention_info = {
    page: 'habitlab-intervention-first-seen-power',
    subpage: 'habitlab-intervention-first-seen-power',
    category: 'intervention_enabledisable',
    is_permanent: true,
    is_generic: is_generic,
    manual: true,
    turned_off_for_visit: false,
    url: url,
    intervention_name: intervention_name_orig,
    prev_enabled_interventions: prev_enabled_interventions
  };
  if (is_enabled) {
    log_intervention_info.type = 'intervention_set_smartly_managed';
    log_intervention_info.now_enabled = true;
    (await set_intervention_enabled(intervention_name));
    if (is_generic) {
      log_intervention_info.change_subinterventions = true;
      log_intervention_info.subinterventions_list = (await list_subinterventions_for_generic_intervention(intervention_name));
      (await set_subinterventions_enabled_for_generic_intervention(intervention_name));
    }
  } else {
    log_intervention_info.type = 'intervention_set_always_disabled';
    log_intervention_info.now_enabled = false;
    (await set_intervention_disabled(intervention_name));
    if (is_generic) {
      log_intervention_info.change_subinterventions = true;
      log_intervention_info.subinterventions_list = (await list_subinterventions_for_generic_intervention(intervention_name));
      (await set_subinterventions_disabled_for_generic_intervention(intervention_name));
    }
  }
  (await log_utils.add_log_interventions(log_intervention_info));
};
out$.set_subinterventions_enabled_for_generic_intervention = set_subinterventions_enabled_for_generic_intervention = async function(generic_intervention_name){
  var subinterventions_list, i$, len$, intervention_name;
  subinterventions_list = (await list_subinterventions_for_generic_intervention(generic_intervention_name));
  for (i$ = 0, len$ = subinterventions_list.length; i$ < len$; ++i$) {
    intervention_name = subinterventions_list[i$];
    (await set_intervention_enabled(intervention_name));
  }
};
out$.set_subinterventions_disabled_for_generic_intervention = set_subinterventions_disabled_for_generic_intervention = async function(generic_intervention_name){
  var subinterventions_list, i$, len$, intervention_name;
  subinterventions_list = (await list_subinterventions_for_generic_intervention(generic_intervention_name));
  for (i$ = 0, len$ = subinterventions_list.length; i$ < len$; ++i$) {
    intervention_name = subinterventions_list[i$];
    (await set_intervention_disabled(intervention_name));
  }
};
out$.list_subinterventions_for_generic_intervention = list_subinterventions_for_generic_intervention = async function(generic_intervention_name){
  var interventions_list, all_interventions, output, i$, len$, intervention_name, intervention_info;
  interventions_list = (await list_all_interventions());
  all_interventions = (await get_interventions());
  output = [];
  for (i$ = 0, len$ = interventions_list.length; i$ < len$; ++i$) {
    intervention_name = interventions_list[i$];
    intervention_info = all_interventions[intervention_name];
    if (intervention_info != null && intervention_info.generic_intervention != null && intervention_info.generic_intervention === generic_intervention_name) {
      output.push(intervention_name);
    }
  }
  return output;
};
out$.generate_interventions_for_domain = generate_interventions_for_domain = async function(domain){
  var goal_name, goal_info, default_interventions, ref$, generic_interventions, all_intervention_info, video_interventions, new_intervention_info_list, i$, len$, generic_intervention, intervention_info, fixed_intervention_name, make_absolute_path;
  goal_name = "custom/spend_less_time_" + domain;
  goal_info = (await goal_utils.get_goal_info(goal_name));
  default_interventions = (ref$ = goal_info.default_interventions) != null
    ? ref$
    : [];
  generic_interventions = (await list_generic_interventions());
  all_intervention_info = (await get_interventions());
  if (is_video_domain(domain)) {
    video_interventions = (await list_video_interventions());
    generic_interventions = generic_interventions.concat(video_interventions);
  }
  new_intervention_info_list = [];
  for (i$ = 0, len$ = generic_interventions.length; i$ < len$; ++i$) {
    generic_intervention = generic_interventions[i$];
    intervention_info = all_intervention_info[generic_intervention];
    if (intervention_info == null) {
      continue;
    }
    intervention_info = JSON.parse(JSON.stringify(intervention_info));
    fixed_intervention_name = generic_intervention;
    fixed_intervention_name = fixed_intervention_name.split('generic/').join("generated_" + domain + "/");
    fixed_intervention_name = fixed_intervention_name.split('video/').join("generated_" + domain + "/");
    intervention_info.name = fixed_intervention_name;
    intervention_info.matches = [domain];
    make_absolute_path = fn$;
    if (intervention_info.content_scripts != null) {
      intervention_info.content_scripts = intervention_info.content_scripts.map(make_absolute_path);
    }
    if (intervention_info.background_scripts != null) {
      intervention_info.background_scripts = intervention_info.background_scripts.map(make_absolute_path);
    }
    intervention_info.sitename = domain;
    intervention_info.sitename_printable = domain;
    if (intervention_info.sitename_printable.startsWith('www.')) {
      intervention_info.sitename_printable = intervention_info.sitename_printable.substr(4);
    }
    intervention_info.generated = true;
    intervention_info.generic_intervention = generic_intervention;
    intervention_info.goals = [goal_name];
    intervention_info.is_default = default_interventions.includes(intervention_info.name);
    new_intervention_info_list.push(intervention_info);
  }
  /*
  [default_enabled_interventions, interventions_per_goal, intervention_choosing_strategy] = select_subset_of_available_interventions(new_intervention_info_list)
  log_utils.add_log_interventions {
    type: 'default_interventions_for_custom_goal'
    interventions_per_goal: interventions_per_goal
    custom_goal: goal_name
    intervention_choosing_strategy: intervention_choosing_strategy
    default_enabled_interventions: default_enabled_interventions
  }
  */
  (await add_new_interventions(new_intervention_info_list));
  function fn$(content_script){
    if (content_script.path != null) {
      if (content_script.path[0] === '/') {
        return content_script;
      }
      content_script.path = '/interventions/' + generic_intervention + '/' + content_script.path;
      return content_script;
    }
    if (content_script[0] === '/') {
      return content_script;
    }
    return '/interventions/' + generic_intervention + '/' + content_script;
  }
};
out$.generate_interventions_for_positive_domain = generate_interventions_for_positive_domain = async function(domain){
  var goal_name, goal_info, default_interventions, ref$, generic_interventions, all_intervention_info, new_intervention_info_list, i$, len$, generic_intervention, intervention_info, fixed_intervention_name, make_absolute_path;
  goal_name = "custom/spend_more_time_" + domain;
  goal_info = (await goal_utils.get_goal_info(goal_name));
  default_interventions = (ref$ = goal_info.default_interventions) != null
    ? ref$
    : [];
  generic_interventions = (await list_generic_positive_interventions());
  all_intervention_info = (await get_interventions());
  new_intervention_info_list = [];
  for (i$ = 0, len$ = generic_interventions.length; i$ < len$; ++i$) {
    generic_intervention = generic_interventions[i$];
    intervention_info = all_intervention_info[generic_intervention];
    if (intervention_info == null) {
      continue;
    }
    intervention_info = JSON.parse(JSON.stringify(intervention_info));
    fixed_intervention_name = generic_intervention;
    fixed_intervention_name = fixed_intervention_name.split('generic_positive/').join("generated_" + domain + "/");
    intervention_info.name = fixed_intervention_name;
    make_absolute_path = fn$;
    if (intervention_info.content_scripts != null) {
      intervention_info.content_scripts = intervention_info.content_scripts.map(make_absolute_path);
    }
    if (intervention_info.background_scripts != null) {
      intervention_info.background_scripts = intervention_info.background_scripts.map(make_absolute_path);
    }
    intervention_info.sitename = domain;
    intervention_info.sitename_printable = domain;
    if (intervention_info.sitename_printable.startsWith('www.')) {
      intervention_info.sitename_printable = intervention_info.sitename_printable.substr(4);
    }
    intervention_info.generated = true;
    intervention_info.generic_intervention = generic_intervention;
    intervention_info.goals = [goal_name];
    intervention_info.is_default = default_interventions.includes(intervention_info.name);
    new_intervention_info_list.push(intervention_info);
  }
  (await add_new_interventions(new_intervention_info_list));
  function fn$(content_script){
    if (content_script.path != null) {
      if (content_script.path[0] === '/') {
        return content_script;
      }
      content_script.path = '/interventions/' + generic_intervention + '/' + content_script.path;
      return content_script;
    }
    if (content_script[0] === '/') {
      return content_script;
    }
    return '/interventions/' + generic_intervention + '/' + content_script;
  }
};
out$.add_new_intervention = add_new_intervention = async function(intervention_info){
  return (await add_new_interventions([intervention_info]));
};
/**
 * Returns a list of names of custom interventions
 * @return {Promise.<Array.<InterventionName>>} List of names of custom interventions
 */
out$.list_custom_interventions = list_custom_interventions = async function(){
  var all_interventions, name, info;
  all_interventions = (await get_interventions());
  return prelude.sort((await (async function(){
    var ref$, results$ = [];
    for (name in ref$ = all_interventions) {
      info = ref$[name];
      if (info.custom) {
        results$.push(name);
      }
    }
    return results$;
  }())));
};
out$.add_new_interventions = add_new_interventions = async function(intervention_info_list){
  var extra_get_interventions, extra_list_all_interventions, new_intervention_names, i$, len$, intervention_info, this$ = this;
  extra_get_interventions = localStorage.getItem('extra_get_interventions');
  if (extra_get_interventions != null) {
    extra_get_interventions = JSON.parse(extra_get_interventions);
  } else {
    extra_get_interventions = {};
  }
  extra_list_all_interventions = localStorage.getItem('extra_list_all_interventions');
  if (extra_list_all_interventions != null) {
    extra_list_all_interventions = JSON.parse(extra_list_all_interventions);
  } else {
    extra_list_all_interventions = [];
  }
  new_intervention_names = intervention_info_list.map(function(it){
    return it.name;
  });
  extra_list_all_interventions = unique_concat(extra_list_all_interventions, new_intervention_names);
  localStorage.setItem('extra_list_all_interventions', JSON.stringify(extra_list_all_interventions));
  for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
    intervention_info = intervention_info_list[i$];
    extra_get_interventions[intervention_info.name] = intervention_info;
  }
  localStorage.setItem('extra_get_interventions', JSON.stringify(extra_get_interventions));
  goal_utils.clear_cache_get_goals();
  clear_cache_all_interventions();
  log_utils.clear_intervention_logdb_cache();
  (await list_all_interventions());
  (await get_interventions());
  (await goal_utils.get_goals());
  (await log_utils.getInterventionLogDb());
};
out$.remove_all_custom_interventions = remove_all_custom_interventions = function(){
  clear_cache_all_interventions();
  goal_utils.clear_cache_get_goals();
  localStorage.removeItem('extra_get_interventions');
  localStorage.removeItem('extra_list_all_interventions');
};
out$.remove_generated_interventions_for_domain = remove_generated_interventions_for_domain = function(domain){
  clear_cache_all_interventions();
  goal_utils.clear_cache_get_goals();
  remove_keys_matching_patternfunc_from_localstorage_dict('extra_get_interventions', function(it){
    return it.startsWith("generated_" + domain + "/");
  });
  remove_items_matching_patternfunc_from_localstorage_list('extra_list_all_interventions', function(it){
    return it.startsWith("generated_" + domain + "/");
  });
};
out$.remove_custom_intervention = remove_custom_intervention = function(intervention_name){
  clear_cache_all_interventions();
  goal_utils.clear_cache_get_goals();
  remove_key_from_localstorage_dict('extra_get_interventions', intervention_name);
  remove_item_from_localstorage_list('extra_list_all_interventions', intervention_name);
  localStorage.removeItem('saved_intervention_' + intervention_name);
  localStorage.removeItem('saved_interventions_' + intervention_name);
  localStorage.removeItem('saved_intervention_time_' + intervention_name);
  localStorage.removeItem('downloaded_intervention_' + intervention_name);
};
out$.list_generic_interventions = list_generic_interventions = memoizeSingleAsync(async function(){
  var cached_generic_interventions, interventions_list, generic_interventions_list, this$ = this;
  cached_generic_interventions = localStorage.getItem('cached_list_generic_interventions');
  if (cached_generic_interventions != null) {
    return JSON.parse(cached_generic_interventions);
  }
  interventions_list = (await goal_utils.get_goal_intervention_info()).interventions.map(function(it){
    return it.name;
  });
  generic_interventions_list = interventions_list.filter(function(it){
    return it.startsWith('generic/');
  });
  localStorage.setItem('cached_list_generic_interventions', JSON.stringify(generic_interventions_list));
  return generic_interventions_list;
});
out$.list_generic_positive_interventions = list_generic_positive_interventions = memoizeSingleAsync(async function(){
  var cached_generic_positive_interventions, interventions_list, generic_positive_interventions_list, this$ = this;
  cached_generic_positive_interventions = localStorage.getItem('cached_list_generic_positive_interventions');
  if (cached_generic_positive_interventions != null) {
    return JSON.parse(cached_generic_positive_interventions);
  }
  interventions_list = (await goal_utils.get_goal_intervention_info()).interventions.map(function(it){
    return it.name;
  });
  generic_positive_interventions_list = interventions_list.filter(function(it){
    return it.startsWith('generic_positive/');
  });
  localStorage.setItem('cached_list_generic_positive_interventions', JSON.stringify(generic_positive_interventions_list));
  return generic_positive_interventions_list;
});
out$.list_video_interventions = list_video_interventions = memoizeSingleAsync(async function(){
  var cached_video_interventions, interventions_list, video_interventions_list, this$ = this;
  cached_video_interventions = localStorage.getItem('cached_list_video_interventions');
  if (cached_video_interventions != null) {
    return JSON.parse(cached_video_interventions);
  }
  interventions_list = (await goal_utils.get_goal_intervention_info()).interventions.map(function(it){
    return it.name;
  });
  video_interventions_list = interventions_list.filter(function(it){
    return it.startsWith('video/');
  });
  localStorage.setItem('cached_list_video_interventions', JSON.stringify(video_interventions_list));
  return video_interventions_list;
});
/**
 * Lists all available interventions
 * @return {Promise.<Array.<InterventionName>>} The list of available interventions
 */
out$.list_all_interventions = list_all_interventions = async function(){
  var cached_list_all_interventions, interventions_list, interventions_list_extra_text, interventions_list_extra, this$ = this;
  cached_list_all_interventions = localStorage.getItem('cached_list_all_interventions');
  if (cached_list_all_interventions != null) {
    return JSON.parse(cached_list_all_interventions);
  }
  interventions_list = (await goal_utils.get_goal_intervention_info()).interventions.map(function(it){
    return it.name;
  });
  interventions_list_extra_text = localStorage.getItem('extra_list_all_interventions');
  if (interventions_list_extra_text != null) {
    interventions_list_extra = JSON.parse(interventions_list_extra_text);
    interventions_list = unique_concat(interventions_list, interventions_list_extra);
  }
  localStorage.setItem('cached_list_all_interventions', JSON.stringify(interventions_list));
  return interventions_list;
};
out$.clear_extra_interventions_and_cache = clear_extra_interventions_and_cache = function(){
  localStorage.removeItem('extra_get_interventions');
  localStorage.removeItem('extra_list_all_interventions');
  return clear_cache_all_interventions();
};
out$.clear_cache_all_interventions = clear_cache_all_interventions = function(){
  clear_cache_list_all_interventions();
  clear_cache_get_interventions();
};
out$.clear_cache_list_all_interventions = clear_cache_list_all_interventions = function(){
  localStorage.removeItem('cached_list_all_interventions');
};
/**
 * Gets the intervention info for the specified intervention name
 * @param {InterventionName} intervention_name - The name of the intervention
 * @return {Promise.<InterventionInfo>} The intervention info
 */
out$.get_intervention_info = get_intervention_info = async function(intervention_name){
  var all_interventions;
  all_interventions = (await get_interventions());
  return all_interventions[intervention_name];
};
fix_intervention_info = function(intervention_info, goals_satisfied_by_intervention){
  var intervention_name, fix_content_script_options, fix_background_script_options, fix_intervention_parameter, ref$, i$, len$, parameter, res$, x;
  intervention_name = intervention_info.name;
  fix_content_script_options = function(options, intervention_name){
    if (typeof options === 'string') {
      options = {
        path: options
      };
    }
    if (options.code != null) {
      if (options.path == null) {
        options.path = 'content_script_' + Math.floor(Math.random() * 1000000);
      }
    } else {
      if (options.path[0] !== '/') {
        options.path = "/interventions/" + intervention_name + "/" + options.path;
      }
    }
    if (options.run_at == null) {
      options.run_at = 'document_end';
    }
    if (options.all_frames == null) {
      options.all_frames = false;
    }
    return options;
  };
  fix_background_script_options = function(options, intervention_name){
    if (typeof options === 'string') {
      options = {
        path: options
      };
    }
    if (options.code != null) {
      if (options.path == null) {
        options.path = 'background_script_' + Math.floor(Math.random() * 1000000);
      }
    } else {
      if (options.path[0] === '/') {
        options.path = options.path.substr(1);
      } else {
        options.path = "/interventions/" + intervention_name + "/" + options.path;
      }
    }
    return options;
  };
  fix_intervention_parameter = function(parameter, intervention_info){
    var curtype;
    if (parameter.name == null) {
      console.log("warning: missing parameter.name for intervention " + intervention_info.name);
    }
    if (parameter['default'] == null) {
      console.log("warning: missing parameter.default for intervention " + intervention_info.name);
    }
    if (parameter.type == null) {
      parameter.type = 'string';
      return;
    }
    curtype = parameter.type.toLowerCase();
    if (curtype.startsWith('str')) {
      parameter.type = 'string';
      return;
    }
    if (curtype.startsWith('int')) {
      parameter.type = 'int';
      return;
    }
    if (curtype.startsWith('float') || curtype.startsWith('real') || curtype.startsWith('double') || curtype.startsWith('num')) {
      parameter.type = 'float';
      return;
    }
    if (curtype.startsWith('bool')) {
      parameter.type = 'bool';
      return;
    }
    return console.log("warning: invalid parameter.type " + curtype + " for intervention " + intervention_info.name);
  };
  if (intervention_info.displayname == null) {
    intervention_info.displayname = (ref$ = intervention_name.split('/'))[ref$.length - 1].split('_').join(' ');
  }
  if (intervention_info.nomatches == null) {
    intervention_info.nomatches = [];
  }
  if (intervention_info.matches == null) {
    intervention_info.matches = [];
  }
  if (intervention_info.content_scripts == null) {
    intervention_info.content_scripts = [];
  }
  if (intervention_info.background_scripts == null) {
    intervention_info.background_scripts = [];
  }
  if (intervention_info.parameters == null) {
    intervention_info.parameters = [];
  }
  if (intervention_info.categories == null) {
    intervention_info.categories = [];
  }
  if (intervention_info.conflicts == null) {
    intervention_info.conflicts = [];
  }
  if (intervention_info.parameters.filter(function(it){
    return it.name === 'debug';
  }).length === 0) {
    intervention_info.parameters.push({
      name: 'debug',
      description: 'Insert debug console',
      type: 'bool',
      'default': false
    });
  }
  for (i$ = 0, len$ = (ref$ = intervention_info.parameters).length; i$ < len$; ++i$) {
    parameter = ref$[i$];
    fix_intervention_parameter(parameter, intervention_info);
  }
  res$ = {};
  for (i$ = 0, len$ = (ref$ = intervention_info.parameters).length; i$ < len$; ++i$) {
    x = ref$[i$];
    res$[x.name] = x;
  }
  intervention_info.params = res$;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = intervention_info.content_scripts).length; i$ < len$; ++i$) {
    x = ref$[i$];
    res$.push(fix_content_script_options(x, intervention_name));
  }
  intervention_info.content_script_options = res$;
  res$ = [];
  for (i$ = 0, len$ = (ref$ = intervention_info.background_scripts).length; i$ < len$; ++i$) {
    x = ref$[i$];
    res$.push(fix_background_script_options(x, intervention_name));
  }
  intervention_info.background_script_options = res$;
  intervention_info.match_functions = intervention_info.matches.map(function(x){
    var regex;
    if (x.includes('/') || x.includes('\\') || x.includes('*') || x.includes('?')) {
      regex = new RegExp(x);
      return function(str){
        return regex.test(str);
      };
    } else {
      return function(str){
        return url_to_domain(str).includes(x);
      };
    }
  });
  intervention_info.nomatch_functions = intervention_info.nomatches.map(function(x){
    var regex;
    if (x.includes('/') || x.includes('\\') || x.includes('*') || x.includes('?')) {
      regex = new RegExp(x);
      return function(str){
        return regex.test(str);
      };
    } else {
      return function(str){
        return url_to_domain(str).includes(x);
      };
    }
  });
  if (intervention_info.goals == null) {
    if (goals_satisfied_by_intervention != null) {
      intervention_info.goals = goals_satisfied_by_intervention;
    } else {
      intervention_info.goals = [];
    }
  }
  return intervention_info;
};
fix_intervention_name_to_intervention_info_dict = function(intervention_name_to_info, interventions_to_goals){
  var intervention_name, intervention_info, category_to_interventions, i$, ref$, len$, category, seen_conflicts, j$, ref1$, len1$, conflict;
  for (intervention_name in intervention_name_to_info) {
    intervention_info = intervention_name_to_info[intervention_name];
    fix_intervention_info(intervention_info, interventions_to_goals[intervention_name]);
  }
  category_to_interventions = {};
  for (intervention_name in intervention_name_to_info) {
    intervention_info = intervention_name_to_info[intervention_name];
    for (i$ = 0, len$ = (ref$ = intervention_info.categories).length; i$ < len$; ++i$) {
      category = ref$[i$];
      if (category_to_interventions[category] == null) {
        category_to_interventions[category] = [];
      }
      category_to_interventions[category].push(intervention_name);
    }
  }
  for (intervention_name in intervention_name_to_info) {
    intervention_info = intervention_name_to_info[intervention_name];
    seen_conflicts = {};
    for (i$ = 0, len$ = (ref$ = intervention_info.categories).length; i$ < len$; ++i$) {
      category = ref$[i$];
      for (j$ = 0, len1$ = (ref1$ = category_to_interventions[category]).length; j$ < len1$; ++j$) {
        conflict = ref1$[j$];
        if (conflict === intervention_name) {
          continue;
        }
        if (seen_conflicts[conflict]) {
          continue;
        }
        seen_conflicts[conflict] = true;
        intervention_info.conflicts.push(conflict);
      }
    }
  }
  return intervention_name_to_info;
};
/*
export get_interventions = ->>
  #if local_cache_get_interventions?
    #return local_cache_get_interventions
  cached_get_interventions = localStorage.getItem 'cached_get_interventions'
  if cached_get_interventions?
    interventions_to_goals = await goal_utils.get_interventions_to_goals()
    intervention_name_to_info = JSON.parse cached_get_interventions
    fix_intervention_name_to_intervention_info_dict intervention_name_to_info, interventions_to_goals
    return intervention_name_to_info
    #return JSON.parse cached_get_interventions
    #local_cache_get_interventions := JSON.parse cached_get_interventions
    #return local_cache_get_interventions
  interventions_to_goals_promises = goal_utils.get_interventions_to_goals()
  interventions_list = await list_all_interventions()
  output = {}
  extra_get_interventions_text = localStorage.getItem 'extra_get_interventions'
  if extra_get_interventions_text?
    extra_get_interventions = JSON.parse extra_get_interventions_text
    for intervention_name,intervention_info of extra_get_interventions
      output[intervention_name] = intervention_info
  intervention_name_to_info_promises = {[intervention_name, getInterventionInfo(intervention_name)] for intervention_name in interventions_list when not output[intervention_name]?}
  [intervention_name_to_info, interventions_to_goals] = await Promise.all [intervention_name_to_info_promises, interventions_to_goals_promises]
  for intervention_name,intervention_info of intervention_name_to_info
    output[intervention_name] = intervention_info
  localStorage.setItem 'cached_get_interventions', JSON.stringify(output)
  fix_intervention_name_to_intervention_info_dict output, interventions_to_goals
  return output
*/
get_interventions_per_goal = function(){
  var interventions_per_goal;
  if (localStorage.getItem('interventions_per_goal') != null) {
    return localStorage.getItem('interventions_per_goal');
  }
  interventions_per_goal = ['one', 'half_of_defaults', 'all_of_defaults'][Math.floor(Math.random() * 3)];
  localStorage.setItem('interventions_per_goal', interventions_per_goal);
  return interventions_per_goal;
};
get_intervention_choosing_strategy = function(){
  var intervention_choosing_strategy;
  if (localStorage.getItem('intervention_choosing_strategy') != null) {
    return localStorage.getItem('intervention_choosing_strategy');
  }
  intervention_choosing_strategy = 'random';
  localStorage.setItem('intervention_choosing_strategy', intervention_choosing_strategy);
  return intervention_choosing_strategy;
};
select_subset_of_available_interventions = function(intervention_info_list_all){
  var goal_to_intervention_info_list, i$, len$, intervention_info, goal_name, default_enabled_interventions, interventions_per_goal, intervention_info_list, available_default_interventions, num_interventions_chosen, chosen_interventions, intervention_name, intervention_choosing_strategy;
  goal_to_intervention_info_list = {};
  for (i$ = 0, len$ = intervention_info_list_all.length; i$ < len$; ++i$) {
    intervention_info = intervention_info_list_all[i$];
    if (intervention_info.goals == null) {
      continue;
    }
    goal_name = intervention_info.goals[0];
    if (goal_name == null) {
      continue;
    }
    if (goal_to_intervention_info_list[goal_name] == null) {
      goal_to_intervention_info_list[goal_name] = [];
    }
    goal_to_intervention_info_list[goal_name].push(intervention_info);
  }
  default_enabled_interventions = {};
  interventions_per_goal = get_interventions_per_goal();
  for (goal_name in goal_to_intervention_info_list) {
    intervention_info_list = goal_to_intervention_info_list[goal_name];
    available_default_interventions = [];
    for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
      intervention_info = intervention_info_list[i$];
      if (intervention_info.is_default) {
        available_default_interventions.push(intervention_info.name);
      }
    }
    available_default_interventions = shuffled(available_default_interventions);
    num_interventions_chosen = available_default_interventions.length;
    if (interventions_per_goal === 'half_of_defaults') {
      num_interventions_chosen = Math.round(available_default_interventions.length * 0.5);
    }
    if (interventions_per_goal === 'one') {
      num_interventions_chosen = 1;
    }
    chosen_interventions = available_default_interventions.slice(0, num_interventions_chosen);
    for (i$ = 0, len$ = chosen_interventions.length; i$ < len$; ++i$) {
      intervention_name = chosen_interventions[i$];
      default_enabled_interventions[intervention_name] = true;
    }
  }
  for (i$ = 0, len$ = intervention_info_list_all.length; i$ < len$; ++i$) {
    intervention_info = intervention_info_list_all[i$];
    if (default_enabled_interventions[intervention_info.name] == null) {
      default_enabled_interventions[intervention_info.name] = false;
    }
  }
  intervention_choosing_strategy = get_intervention_choosing_strategy();
  return [default_enabled_interventions, interventions_per_goal, intervention_choosing_strategy];
};
/**
 * Gets the intervention info for all interventions, in the form of an object mapping intervention names to intervention info
 * @return {Promise.<Object.<InterventionName, InterventionInfo>>} Object mapping intervention names to intervention info
 */
out$.get_interventions = get_interventions = async function(){
  var cached_get_interventions, interventions_to_goals, intervention_name_to_info, interventions_list, output, intervention_info_list, i$, len$, intervention_info, extra_get_interventions_text, extra_get_interventions, intervention_name;
  cached_get_interventions = localStorage.getItem('cached_get_interventions');
  interventions_to_goals = (await goal_utils.get_interventions_to_goals());
  if (cached_get_interventions != null) {
    intervention_name_to_info = JSON.parse(cached_get_interventions);
    fix_intervention_name_to_intervention_info_dict(intervention_name_to_info, interventions_to_goals);
    return intervention_name_to_info;
  }
  interventions_list = (await list_all_interventions());
  output = {};
  intervention_info_list = (await goal_utils.get_goal_intervention_info()).interventions;
  for (i$ = 0, len$ = intervention_info_list.length; i$ < len$; ++i$) {
    intervention_info = intervention_info_list[i$];
    output[intervention_info.name] = intervention_info;
  }
  extra_get_interventions_text = localStorage.getItem('extra_get_interventions');
  if (extra_get_interventions_text != null) {
    extra_get_interventions = JSON.parse(extra_get_interventions_text);
    for (intervention_name in extra_get_interventions) {
      intervention_info = extra_get_interventions[intervention_name];
      output[intervention_name] = intervention_info;
    }
  }
  localStorage.setItem('cached_get_interventions', JSON.stringify(output));
  fix_intervention_name_to_intervention_info_dict(output, interventions_to_goals);
  return output;
};
/*
export get_interventions = ->>
  #if local_cache_get_interventions?
    #return local_cache_get_interventions
  cached_get_interventions = localStorage.getItem 'cached_get_interventions'
  interventions_to_goals = await goal_utils.get_interventions_to_goals()
  if cached_get_interventions?
    intervention_name_to_info = JSON.parse cached_get_interventions
    fix_intervention_name_to_intervention_info_dict intervention_name_to_info, interventions_to_goals
    return intervention_name_to_info
    #return JSON.parse cached_get_interventions
    #local_cache_get_interventions := JSON.parse cached_get_interventions
    #return local_cache_get_interventions
  interventions_list = await list_all_interventions()
  output = {}
  intervention_info_list = (await goal_utils.get_goal_intervention_info()).interventions
  default_enabled_interventions = {}
  cached_default_enabled_interventions = localStorage.getItem('default_interventions_on_install_cached')
  if cached_default_enabled_interventions?
    default_enabled_interventions = JSON.parse(cached_default_enabled_interventions)
  else
    [default_enabled_interventions, interventions_per_goal, intervention_choosing_strategy] = select_subset_of_available_interventions(intervention_info_list)
    localStorage.setItem('default_interventions_on_install_cached', JSON.stringify(default_enabled_interventions))
    # log the enabled one
    await log_utils.add_log_interventions {
      type: 'default_interventions_on_install'
      interventions_per_goal: interventions_per_goal
      intervention_choosing_strategy: intervention_choosing_strategy
      enabled_interventions: default_enabled_interventions
      #enabled_goals: {} # incorrect value
    }
  for intervention_info in intervention_info_list
    intervention_info.is_default = (default_enabled_interventions[intervention_info.name] == true)
    output[intervention_info.name] = intervention_info
  extra_get_interventions_text = localStorage.getItem 'extra_get_interventions'
  if extra_get_interventions_text?
    extra_get_interventions = JSON.parse extra_get_interventions_text
    for intervention_name,intervention_info of extra_get_interventions
      output[intervention_name] = intervention_info
  localStorage.setItem 'cached_get_interventions', JSON.stringify(output)
  fix_intervention_name_to_intervention_info_dict output, interventions_to_goals
  return output
*/
out$.clear_cache_get_interventions = clear_cache_get_interventions = function(){
  localStorage.removeItem('cached_get_interventions');
};
out$.list_enabled_interventions_for_location = list_enabled_interventions_for_location = async function(location){
  var available_interventions, enabled_interventions;
  available_interventions = (await list_available_interventions_for_location(location));
  enabled_interventions = (await get_enabled_interventions());
  return available_interventions.filter(function(x){
    return enabled_interventions[x];
  });
};
/*
export list_all_enabled_interventions_for_location_with_override = (location) ->>
  # TODO this no longer works on new days. need to persist enabled interventions across days
  override_enabled_interventions = localStorage.getItem('override_enabled_interventions_once')
  if override_enabled_interventions?
    #localStorage.removeItem('override_enabled_interventions_once')
    return as_array(JSON.parse(override_enabled_interventions))
  available_interventions = await list_available_interventions_for_location(location)
  enabled_interventions = await intervention_manager.get_most_recent_enabled_interventions()
  return available_interventions.filter((x) -> enabled_interventions[x])
*/
out$.list_all_enabled_interventions_for_location = list_all_enabled_interventions_for_location = async function(location){
  var available_interventions, enabled_interventions;
  available_interventions = (await list_available_interventions_for_location(location));
  enabled_interventions = (await intervention_manager.get_currently_enabled_interventions());
  return available_interventions.filter(function(x){
    return enabled_interventions[x];
  });
};
out$.list_enabled_nonconflicting_interventions_for_location = list_enabled_nonconflicting_interventions_for_location = async function(location){
  var available_interventions, enabled_interventions, all_interventions, enabled_interventions_for_location, output, output_set, i$, len$, intervention_name, intervention_info, keep_enabled, j$, ref$, len1$, conflict;
  available_interventions = (await list_available_interventions_for_location(location));
  enabled_interventions = (await get_enabled_interventions_with_override_for_visit());
  all_interventions = (await get_interventions());
  enabled_interventions_for_location = available_interventions.filter(function(x){
    return enabled_interventions[x];
  });
  output = [];
  output_set = {};
  for (i$ = 0, len$ = enabled_interventions_for_location.length; i$ < len$; ++i$) {
    intervention_name = enabled_interventions_for_location[i$];
    intervention_info = all_interventions[intervention_name];
    keep_enabled = true;
    for (j$ = 0, len1$ = (ref$ = intervention_info.conflicts).length; j$ < len1$; ++j$) {
      conflict = ref$[j$];
      if (output_set[conflict] != null) {
        keep_enabled = false;
      }
    }
    if (keep_enabled) {
      output.push(intervention_name);
      output_set[intervention_name] = true;
    }
  }
  return output;
};
out$.list_available_interventions_for_location = list_available_interventions_for_location = async function(location){
  var all_interventions, possible_interventions, intervention_name, intervention_info, blacklisted, i$, ref$, len$, func, matches;
  all_interventions = (await get_interventions());
  possible_interventions = [];
  for (intervention_name in all_interventions) {
    intervention_info = all_interventions[intervention_name];
    blacklisted = false;
    for (i$ = 0, len$ = (ref$ = intervention_info.nomatch_functions).length; i$ < len$; ++i$) {
      func = ref$[i$];
      if (func(location)) {
        blacklisted = true;
        break;
      }
    }
    if (blacklisted) {
      continue;
    }
    matches = false;
    if (intervention_info.matches_all != null) {
      matches = true;
    } else {
      for (i$ = 0, len$ = (ref$ = intervention_info.match_functions).length; i$ < len$; ++i$) {
        func = ref$[i$];
        if (func(location)) {
          matches = true;
          break;
        }
      }
    }
    if (matches) {
      possible_interventions.push(intervention_name);
    }
  }
  return possible_interventions;
};
out$.filter_interventions_by_temporary_difficulty = filter_interventions_by_temporary_difficulty = function(intervention_list, all_interventions){
  var difficulty;
  difficulty = localStorage.getItem('temporary_difficulty');
  if (difficulty == null) {
    return intervention_list;
  }
  return filter_interventions_to_best_match_difficulty(intervention_list, difficulty, all_interventions);
};
out$.filter_interventions_to_best_match_difficulty = filter_interventions_to_best_match_difficulty = function(intervention_list, difficulty, all_interventions){
  var difficulties, target_difficulty_idx, easiest_allowed_difficulty_idx, output, i$, len$, intervention_name, intervention_info, cur_difficulty, cur_difficulty_idx;
  console.log('filter_interventions_to_best_match_difficulty');
  console.log(intervention_list);
  console.log(difficulty);
  console.log(all_interventions);
  if (difficulty == null) {
    return intervention_list;
  }
  difficulties = ['hard', 'medium', 'easy'];
  target_difficulty_idx = difficulties.indexOf(difficulty);
  if (target_difficulty_idx === -1) {
    return intervention_list;
  }
  easiest_allowed_difficulty_idx = target_difficulty_idx;
  while (easiest_allowed_difficulty_idx < difficulties.length) {
    output = [];
    for (i$ = 0, len$ = intervention_list.length; i$ < len$; ++i$) {
      intervention_name = intervention_list[i$];
      intervention_info = all_interventions[intervention_name];
      if ((intervention_info != null ? intervention_info.difficulty : void 8) == null) {
        continue;
      }
      cur_difficulty = intervention_info.difficulty;
      cur_difficulty_idx = difficulties.indexOf(cur_difficulty);
      if (cur_difficulty_idx === -1) {
        continue;
      }
      if (cur_difficulty_idx < target_difficulty_idx) {
        continue;
      }
      if (cur_difficulty_idx > easiest_allowed_difficulty_idx) {
        continue;
      }
      output.push(intervention_name);
    }
    easiest_allowed_difficulty_idx += 1;
    if (output.length > 0) {
      return output;
    }
  }
  return intervention_list;
};
out$.set_temporary_difficulty = set_temporary_difficulty = async function(difficulty){
  localStorage.setItem('temporary_difficulty', difficulty);
  setvar_experiment('temporary_difficulty', difficulty);
};
out$.set_asknext_time = set_asknext_time = async function(asknext_time){
  localStorage.setItem('asknext_time', asknext_time);
  setvar_experiment('asknext_time', asknext_time);
};
/*
export get_enabled_intervention_for_goal_by_difficulty = (goal, difficulty) ->>
  all_interventions = await get_interventions()
  enabled_interventions = await get_enabled_interventions()
  intervention_list = await list_all_interventions()
  available_interventions = []
  for intervention_name in intervention_list
    if not enabled_interventions[intervention_name]
      continue
    intervention_info = all_interventions[intervention_name]
    if not intervention_info?goals?indexOf?
      continue
    if intervention_info.goals.indexOf(goal) == -1
      continue
    if 
    available_interventions.push(intervention_name)
  return available_interventions
*/
out$.get_manually_managed_interventions_localstorage = get_manually_managed_interventions_localstorage = async function(){
  var manually_managed_interventions_str, manually_managed_interventions;
  manually_managed_interventions_str = localStorage.getItem('manually_managed_interventions');
  if (manually_managed_interventions_str == null) {
    manually_managed_interventions = {};
  } else {
    manually_managed_interventions = JSON.parse(manually_managed_interventions_str);
  }
  return manually_managed_interventions;
};
out$.get_manually_managed_interventions = get_manually_managed_interventions = get_manually_managed_interventions_localstorage;
/*
export get_most_recent_manually_enabled_interventions = ->>
  enabled_interventions = await intervention_manager.get_most_recent_enabled_interventions()
  manually_managed_interventions = await get_manually_managed_interventions()
  output = {}
  for intervention_name,is_enabled of enabled_interventions
    output[intervention_name] = is_enabled and manually_managed_interventions[intervention_name]
  return output

export get_most_recent_manually_disabled_interventions = ->>
  enabled_interventions = await intervention_manager.get_most_recent_enabled_interventions()
  manually_managed_interventions = await get_manually_managed_interventions()
  output = {}
  for intervention_name,is_enabled of enabled_interventions
    output[intervention_name] = (!is_enabled) and manually_managed_interventions[intervention_name]
  return output
*/
out$.set_manually_managed_interventions = set_manually_managed_interventions = async function(manually_managed_interventions){
  localStorage.setItem('manually_managed_interventions', JSON.stringify(manually_managed_interventions));
};
out$.set_intervention_manually_managed = set_intervention_manually_managed = async function(intervention_name){
  var manually_managed_interventions;
  manually_managed_interventions = (await get_manually_managed_interventions());
  if (manually_managed_interventions[intervention_name]) {
    return;
  }
  manually_managed_interventions[intervention_name] = true;
  return (await set_manually_managed_interventions(manually_managed_interventions));
};
out$.set_intervention_automatically_managed = set_intervention_automatically_managed = async function(intervention_name){
  var manually_managed_interventions;
  manually_managed_interventions = (await get_manually_managed_interventions());
  if (!manually_managed_interventions[intervention_name]) {
    return;
  }
  manually_managed_interventions[intervention_name] = false;
  return (await set_manually_managed_interventions(manually_managed_interventions));
};
out$.list_available_interventions_for_enabled_goals = list_available_interventions_for_enabled_goals = async function(){
  var interventions_to_goals, enabled_goals, output, output_set, intervention_name, goal_names, i$, len$, goal_name;
  interventions_to_goals = (await goal_utils.get_interventions_to_goals());
  enabled_goals = (await goal_utils.get_enabled_goals());
  output = [];
  output_set = {};
  for (intervention_name in interventions_to_goals) {
    goal_names = interventions_to_goals[intervention_name];
    for (i$ = 0, len$ = goal_names.length; i$ < len$; ++i$) {
      goal_name = goal_names[i$];
      if (enabled_goals[goal_name] != null && output_set[intervention_name] == null) {
        output.push(intervention_name);
        output_set[intervention_name] = true;
      }
    }
  }
  return output;
};
out$.list_available_interventions_for_goal = list_available_interventions_for_goal = async function(goal_name){
  var goal_info;
  goal_info = (await goal_utils.get_goal_info(goal_name));
  if (goal_info != null && goal_info.interventions != null) {
    return goal_info.interventions;
  } else {
    return [];
  }
};
out$.list_enabled_interventions_for_goal = list_enabled_interventions_for_goal = async function(goal_name){
  var enabled_interventions, available_interventions_for_goal;
  enabled_interventions = (await get_enabled_interventions());
  available_interventions_for_goal = (await list_available_interventions_for_goal(goal_name));
  return available_interventions_for_goal.filter(function(it){
    return enabled_interventions[it];
  });
};
cast_to_bool = function(parameter_value){
  if (typeof parameter_value !== 'string') {
    return Boolean(parameter_value);
  }
  if (parameter_value.toLowerCase() === 'false') {
    return false;
  }
  return true;
};
cast_to_type = function(parameter_value, type_name){
  if (type_name === 'string') {
    return parameter_value.toString();
  }
  if (type_name === 'int') {
    return parseInt(parameter_value);
  }
  if (type_name === 'float') {
    return parseFloat(parameter_value);
  }
  if (type_name === 'bool') {
    return cast_to_bool(parameter_value);
  }
  return parameter_value;
};
out$.set_intervention_parameter = set_intervention_parameter = async function(intervention_name, parameter_name, parameter_value){
  return (await setkey_dictdict('intervention_to_parameters', intervention_name, parameter_name, parameter_value));
};
get_intervention_parameter_type = async function(intervention_name, parameter_name){
  var interventions, intervention_info, parameter_type;
  interventions = (await get_interventions());
  intervention_info = interventions[intervention_name];
  parameter_type = intervention_info.params[parameter_name].type;
  return parameter_type;
};
out$.get_intervention_parameter_default = get_intervention_parameter_default = async function(intervention_name, parameter_name){
  var interventions, intervention_info, parameter_type, parameter_value;
  interventions = (await get_interventions());
  intervention_info = interventions[intervention_name];
  parameter_type = intervention_info.params[parameter_name].type;
  parameter_value = intervention_info.params[parameter_name]['default'];
  return cast_to_type(parameter_value, parameter_type);
};
out$.get_intervention_parameters_default = get_intervention_parameters_default = async function(intervention_name){
  var interventions, intervention_info, x;
  interventions = (await get_interventions());
  intervention_info = interventions[intervention_name];
  return (await (async function(){
    var i$, ref$, len$, resultObj$ = {};
    for (i$ = 0, len$ = (ref$ = intervention_info.parameters).length; i$ < len$; ++i$) {
      x = ref$[i$];
      resultObj$[x.name] = cast_to_type(x['default'], x.type);
    }
    return resultObj$;
  }()));
};
out$.get_intervention_parameter = get_intervention_parameter = async function(intervention_name, parameter_name){
  var result, parameter_type;
  result = (await getkey_dictdict('intervention_to_parameters', intervention_name, parameter_name));
  parameter_type = (await get_intervention_parameter_type(intervention_name, parameter_name));
  if (result != null) {
    return cast_to_type(result, parameter_type);
  }
  return (await get_intervention_parameter_default(intervention_name, parameter_name));
};
out$.get_intervention_parameters = get_intervention_parameters = async function(intervention_name){
  var results, default_parameters, interventions, intervention_info, output, k, v, parameter_value, ref$, parameter_type;
  results = (await getdict_for_key_dictdict('intervention_to_parameters', intervention_name));
  default_parameters = (await get_intervention_parameters_default(intervention_name));
  interventions = (await get_interventions());
  intervention_info = interventions[intervention_name];
  output = {};
  for (k in default_parameters) {
    v = default_parameters[k];
    parameter_value = (ref$ = results[k]) != null
      ? ref$
      : default_parameters[k];
    parameter_type = intervention_info.params[k].type;
    output[k] = cast_to_type(parameter_value, parameter_type);
  }
  return output;
};
/**
 * Returns a dictionary with keys being the intervention, values being the number of sessions.
 * NOTE: These interventions are not necessarily enabled by the user.
 */
out$.get_number_sessions_for_each_intervention = get_number_sessions_for_each_intervention = async function(domain){
  var session_id_to_interventions, interventions, id, intervention, intervention_name;
  session_id_to_interventions = (await getdict_for_key_dictdict('interventions_active_for_domain_and_session', domain));
  interventions = {};
  for (id in session_id_to_interventions) {
    intervention = session_id_to_interventions[id];
    intervention_name = intervention.substr(2, intervention.length - 4);
    if (interventions[intervention_name] != null) {
      interventions[intervention_name]++;
    } else {
      interventions[intervention_name] = 1;
    }
  }
  return interventions;
};
out$.get_seconds_spent_on_domain_for_each_intervention = get_seconds_spent_on_domain_for_each_intervention = async function(domain){
  var session_id_to_interventions, session_id_to_seconds, intervention_to_session_lengths, session_id, interventions, intervention, seconds_spent, output, session_lengths;
  session_id_to_interventions = (await getdict_for_key_dictdict('interventions_active_for_domain_and_session', domain));
  session_id_to_seconds = (await getdict_for_key_dictdict('seconds_on_domain_per_session', domain));
  intervention_to_session_lengths = {};
  for (session_id in session_id_to_interventions) {
    interventions = session_id_to_interventions[session_id];
    interventions = JSON.parse(interventions);
    if (interventions.length !== 1) {
      continue;
    }
    intervention = interventions[0];
    seconds_spent = session_id_to_seconds[session_id];
    if (seconds_spent == null) {
      continue;
    }
    if (intervention_to_session_lengths[intervention] == null) {
      intervention_to_session_lengths[intervention] = [];
    }
    intervention_to_session_lengths[intervention].push(seconds_spent);
  }
  output = {};
  for (intervention in intervention_to_session_lengths) {
    session_lengths = intervention_to_session_lengths[intervention];
    output[intervention] = median(session_lengths);
  }
  return output;
};
out$.get_seconds_spent_for_each_session_per_intervention = get_seconds_spent_for_each_session_per_intervention = async function(domain){
  var session_id_to_interventions, session_id_to_seconds, intervention_to_session_lengths, session_id, interventions, intervention, seconds_spent, output, session_lengths;
  session_id_to_interventions = (await getdict_for_key_dictdict('interventions_active_for_domain_and_session', domain));
  session_id_to_seconds = (await getdict_for_key_dictdict('seconds_on_domain_per_session', domain));
  intervention_to_session_lengths = {};
  for (session_id in session_id_to_interventions) {
    interventions = session_id_to_interventions[session_id];
    interventions = JSON.parse(interventions);
    if (interventions.length !== 1) {
      continue;
    }
    intervention = interventions[0];
    seconds_spent = session_id_to_seconds[session_id];
    if (seconds_spent == null) {
      continue;
    }
    if (intervention_to_session_lengths[intervention] == null) {
      intervention_to_session_lengths[intervention] = [];
    }
    intervention_to_session_lengths[intervention].push(seconds_spent);
  }
  output = {};
  for (intervention in intervention_to_session_lengths) {
    session_lengths = intervention_to_session_lengths[intervention];
    output[intervention] = session_lengths;
  }
  return output;
};
out$.get_seconds_saved_per_session_for_each_intervention_for_goal = get_seconds_saved_per_session_for_each_intervention_for_goal = async function(goal_name){
  var goal_info, output, domain, intervention_names, intervention_to_seconds_per_session, baseline_session_time, i$, len$, intervention, seconds_per_session, time_saved;
  goal_info = (await goal_utils.get_goal_info(goal_name));
  output = {};
  if (goal_info.interventions == null) {
    return output;
  }
  domain = goal_info.domain;
  intervention_names = goal_info.interventions;
  intervention_to_seconds_per_session = (await get_seconds_spent_on_domain_for_each_intervention(domain));
  baseline_session_time = (await get_baseline_session_time_on_domain(domain));
  for (i$ = 0, len$ = intervention_names.length; i$ < len$; ++i$) {
    intervention = intervention_names[i$];
    seconds_per_session = intervention_to_seconds_per_session[intervention];
    if (seconds_per_session == null) {
      output[intervention] = NaN;
      continue;
    }
    time_saved = baseline_session_time - seconds_per_session;
    output[intervention] = time_saved;
  }
  return output;
};
out$.get_seconds_spent_per_session_for_each_intervention_for_goal = get_seconds_spent_per_session_for_each_intervention_for_goal = async function(goal_name){
  var goal_info, domain, intervention_names, session_id_to_interventions, session_id_to_seconds, intervention_to_seconds_per_session, baseline_session_time, output, i$, len$, intervention, seconds_per_session;
  goal_info = (await goal_utils.get_goal_info(goal_name));
  domain = goal_info.domain;
  intervention_names = goal_info.interventions;
  session_id_to_interventions = (await getdict_for_key_dictdict('interventions_active_for_domain_and_session', domain));
  session_id_to_seconds = (await getdict_for_key_dictdict('seconds_on_domain_per_session', domain));
  intervention_to_seconds_per_session = (await get_seconds_spent_on_domain_for_each_intervention(domain));
  baseline_session_time = (await get_baseline_session_time_on_domain(domain));
  output = {};
  for (i$ = 0, len$ = intervention_names.length; i$ < len$; ++i$) {
    intervention = intervention_names[i$];
    seconds_per_session = intervention_to_seconds_per_session[intervention];
    if (seconds_per_session == null) {
      output[intervention] = NaN;
      continue;
    }
    output[intervention] = seconds_per_session;
  }
  return output;
};
/*
# only kept for legacy compatibility purposes, will be removed, do not use
# replacement: get_seconds_saved_per_session_for_each_intervention_for_goal
export get_effectiveness_of_all_interventions_for_goal = (goal_name) ->>
  goal_info = await goal_utils.get_goal_info(goal_name)
  domain = goal_info.domain
  intervention_names = goal_info.interventions
  session_id_to_interventions = await getdict_for_key_dictdict('interventions_active_for_domain_and_session', domain)
  session_id_to_seconds = await getdict_for_key_dictdict('seconds_on_domain_per_session', domain)
  intervention_to_seconds_per_session = await get_seconds_spent_on_domain_for_each_intervention(domain)
  output = {}
  for intervention,seconds_per_session of intervention_to_seconds_per_session
    minutes_per_session = seconds_per_session / 60
    output[intervention] = {
      progress: minutes_per_session
      units: 'minutes'
      message: "#{minutes_per_session} minutes"
    }
  for intervention in intervention_names
    if not output[intervention]?
      output[intervention] = {
        progress: NaN
        units: 'minutes'
        message: 'no data'
      }
  return output
*/
out$.get_goals_and_interventions = get_goals_and_interventions = async function(){
  var intervention_name_to_info, enabled_interventions, enabled_goals, all_goals, all_goals_list, manually_managed_interventions, goal_to_interventions, intervention_name, intervention_info, i$, ref$, len$, goalname, list_of_goals_and_interventions, list_of_goals, current_item, j$, len1$, intervention, this$ = this;
  intervention_name_to_info = (await get_interventions());
  enabled_interventions = (await get_enabled_interventions());
  enabled_goals = (await goal_utils.get_enabled_goals());
  all_goals = (await goal_utils.get_goals());
  all_goals_list = (await goal_utils.list_all_goals());
  manually_managed_interventions = (await get_manually_managed_interventions());
  goal_to_interventions = {};
  for (intervention_name in intervention_name_to_info) {
    intervention_info = intervention_name_to_info[intervention_name];
    for (i$ = 0, len$ = (ref$ = intervention_info.goals).length; i$ < len$; ++i$) {
      goalname = ref$[i$];
      if (goal_to_interventions[goalname] == null) {
        goal_to_interventions[goalname] = [];
      }
      goal_to_interventions[goalname].push(intervention_info);
    }
  }
  list_of_goals_and_interventions = [];
  list_of_goals = prelude.sort(as_array(all_goals_list));
  for (i$ = 0, len$ = list_of_goals.length; i$ < len$; ++i$) {
    goalname = list_of_goals[i$];
    current_item = {
      goal: all_goals[goalname]
    };
    current_item.enabled = enabled_goals[goalname] === true;
    if (goal_to_interventions[goalname] == null) {
      current_item.interventions = [];
    } else {
      current_item.interventions = prelude.sortBy(fn$, goal_to_interventions[goalname]);
    }
    for (j$ = 0, len1$ = (ref$ = current_item.interventions).length; j$ < len1$; ++j$) {
      intervention = ref$[j$];
      intervention.enabled_goals = [];
      intervention.enabled = enabled_interventions[intervention.name] === true;
      intervention.automatic = manually_managed_interventions[intervention.name] !== true;
    }
    list_of_goals_and_interventions.push(current_item);
  }
  return list_of_goals_and_interventions;
  function fn$(it){
    return it.name;
  }
};
out$.get_nonpositive_goals_and_interventions = get_nonpositive_goals_and_interventions = async function(){
  var list_of_goals_and_interventions;
  list_of_goals_and_interventions = (await get_goals_and_interventions());
  return list_of_goals_and_interventions.filter(function(it){
    return !it.goal.is_positive;
  });
};
/**
 * Gets the time in milliseconds since the intervention was most recently given.
 * If this intervention corresponds to a generic intervention, then we choose
 * the most recent intervention across the generic one. 
 * Returns -1 if the intervention has not been used yet.
 */
out$.get_time_since_intervention = get_time_since_intervention = async function(intervention_name){
  var name, intervention, time;
  name = intervention_name;
  intervention = (await get_intervention_info(intervention_name));
  console.log(intervention.generic_intervention);
  if (intervention.generic_intervention != null) {
    name = intervention.generic_intervention;
  }
  time = (await getkey_dict('time_intervention_most_recently_seen', name));
  if (time != null) {
    return Date.now() - time;
  }
  return 60 * 60 * 1000 * 24 * 365;
};
/**
 * Currently, novelty is just the time since the intervention was last used.
 * TODO: Consider some other function of that time to better represent the novelty curve. [Currently assuming linear]
 * @param intervention_names list of strings
 * @return dictionary {<intervention_name>: novelty}
 */
out$.get_novelty = get_novelty = async function(intervention_names){
  var novelty, i$, len$, intervention_name;
  novelty = {};
  for (i$ = 0, len$ = intervention_names.length; i$ < len$; ++i$) {
    intervention_name = intervention_names[i$];
    novelty[intervention_name] = (await get_time_since_intervention(intervention_name));
  }
  return novelty;
};
/*
export get_goals_and_interventions = ->>
  intervention_name_to_info = await get_interventions()
  enabled_interventions = await get_enabled_interventions()
  enabled_goals = await goal_utils.get_enabled_goals()
  all_goals = await goal_utils.get_goals()
  manually_managed_interventions = await get_manually_managed_interventions()
  goal_to_interventions = {}
  for intervention_name,intervention_info of intervention_name_to_info
    for goal in intervention_info.goals
      goalname = goal.name
      if not goal_to_interventions[goalname]?
        goal_to_interventions[goalname] = []
      goal_to_interventions[goalname].push intervention_info
  list_of_goals_and_interventions = []
  list_of_goals = prelude.sort as_array(enabled_goals)
  for goalname in list_of_goals
    current_item = {goal: all_goals[goalname]}
    current_item.interventions = prelude.sort-by (.name), goal_to_interventions[goalname]
    for intervention in current_item.interventions
      intervention.enabled_goals = []
      #if intervention.goals?
      #  intervention.enabled_goals = [goal for goal in intervention.goals when enabled_goals[goal.name]]
      intervention.enabled = (enabled_interventions[intervention.name] == true)
      intervention.automatic = (manually_managed_interventions[intervention.name] != true)
    list_of_goals_and_interventions.push current_item
  return list_of_goals_and_interventions
*/
out$.choose_intervention_for_difficulty_level_and_goal = choose_intervention_for_difficulty_level_and_goal = async function(difficulty, goal){
  var available_interventions, all_interventions, intervention_name_to_load, i$, len$, intervention_name, intervention_info, intervention_list, output;
  available_interventions = (await intervention_selection_algorithms.one_random_intervention_per_enabled_goal());
  all_interventions = (await get_interventions());
  intervention_name_to_load = null;
  for (i$ = 0, len$ = available_interventions.length; i$ < len$; ++i$) {
    intervention_name = available_interventions[i$];
    intervention_info = all_interventions[intervention_name];
    if (intervention_info.goals != null) {
      if (intervention_info.goals.indexOf(goal) !== -1) {
        intervention_name_to_load = intervention_name;
        break;
      }
    }
  }
  all_interventions = (await get_interventions());
  intervention_list = (await list_enabled_interventions_for_goal(goal));
  output = filter_interventions_to_best_match_difficulty(intervention_list, difficulty, all_interventions);
  return output[Math.floor(Math.random() * output.length)];
};
out$.choose_intervention_for_each_difficulty_level_and_goal = choose_intervention_for_each_difficulty_level_and_goal = async function(goal){
  var difficulty_levels, output, i$, len$, difficulty;
  difficulty_levels = ['hard', 'medium', 'easy'];
  output = {};
  for (i$ = 0, len$ = difficulty_levels.length; i$ < len$; ++i$) {
    difficulty = difficulty_levels[i$];
    output[difficulty] = (await choose_intervention_for_difficulty_level_and_goal(difficulty, goal));
  }
  return output;
};
intervention_manager = __webpack_require__(/*! libs_backend/intervention_manager */ "./src/libs_backend/intervention_manager.ls");
goal_utils = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls");
log_utils = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls");
intervention_selection_algorithms = __webpack_require__(/*! libs_backend/intervention_selection_algorithms */ "./src/libs_backend/intervention_selection_algorithms.ls");
gexport_module('intervention_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=intervention_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/intervention_vars_backend.js":
/*!*******************************************************!*\
  !*** ./src/libs_backend/intervention_vars_backend.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  getkey_dictdict,
  setkey_dictdict
} = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls")

async function setvar_intervention_synced_backend(intervention_name, key, val) {
  await setkey_dictdict('intervention_vars_synced', intervention_name, key, val)
}

async function setvar_intervention_unsynced_backend(intervention_name, key, val) {
  await setkey_dictdict('intervention_vars_unsynced', intervention_name, key, val)
}

async function getvar_intervention_synced_backend(intervention_name, key) {
  return await getkey_dictdict('intervention_vars_synced', intervention_name, key)
}

async function getvar_intervention_unsynced_backend(intervention_name, key) {
  return await getkey_dictdict('intervention_vars_unsynced', intervention_name, key)
}

module.exports = {
  setvar_intervention_synced_backend,
  setvar_intervention_unsynced_backend,
  getvar_intervention_synced_backend,
  getvar_intervention_unsynced_backend,
}


/***/ }),

/***/ "./src/libs_backend/localization_utils_backend.js":
/*!********************************************************!*\
  !*** ./src/libs_backend/localization_utils_backend.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

async function record_unlocalized_string(text) {
  let unlocalized_strings_num_encounters = localStorage.getItem('unlocalized_strings_num_encounters');
  let unlocalized_strings_times_encountered = localStorage.getItem('unlocalized_strings_times_encountered');
  if (unlocalized_strings_num_encounters != null) {
    unlocalized_strings_num_encounters = JSON.parse(unlocalized_strings_num_encounters);
  } else {
    unlocalized_strings_num_encounters = {};
  }
  if (unlocalized_strings_times_encountered != null) {
    unlocalized_strings_times_encountered = JSON.parse(unlocalized_strings_times_encountered);
  } else {
    unlocalized_strings_times_encountered = {};
  }
  unlocalized_strings_times_encountered[text] = Date.now();
  if (unlocalized_strings_num_encounters[text] != null) {
    unlocalized_strings_num_encounters[text] += 1;
  } else {
    unlocalized_strings_num_encounters[text] = 1;
  }
  localStorage.setItem('unlocalized_strings_num_encounters', JSON.stringify(unlocalized_strings_num_encounters));
  localStorage.setItem('unlocalized_strings_times_encountered', JSON.stringify(unlocalized_strings_times_encountered));
  return;
}

async function record_localized_string(text) {
  let localized_strings_num_encounters = localStorage.getItem('localized_strings_num_encounters');
  let localized_strings_times_encountered = localStorage.getItem('localized_strings_times_encountered');
  if (localized_strings_num_encounters != null) {
    localized_strings_num_encounters = JSON.parse(localized_strings_num_encounters);
  } else {
    localized_strings_num_encounters = {};
  }
  if (localized_strings_times_encountered != null) {
    localized_strings_times_encountered = JSON.parse(localized_strings_times_encountered);
  } else {
    localized_strings_times_encountered = {};
  }
  localized_strings_times_encountered[text] = Date.now();
  if (localized_strings_num_encounters[text] != null) {
    localized_strings_num_encounters[text] += 1;
  } else {
    localized_strings_num_encounters[text] = 1;
  }
  localStorage.setItem('localized_strings_num_encounters', JSON.stringify(localized_strings_num_encounters));
  localStorage.setItem('localized_strings_times_encountered', JSON.stringify(localized_strings_times_encountered));
  return;
}

module.exports = {
  record_unlocalized_string,
  record_localized_string
}


/***/ }),

/***/ "./src/libs_backend/log_sync_utils.ls":
/*!********************************************!*\
  !*** ./src/libs_backend/log_sync_utils.ls ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, get_log_names, getInterventionLogCollection, get_current_collections, list_collections_to_sync, getCollection, get_user_id, get_install_id, post_json, sleep, gexport, gexport_module, chrome_manifest, habitlab_version, developer_mode, unofficial_version, start_syncing_all_data, stop_syncing_all_data, upload_log_item_to_server, sync_unsynced_logs, log_syncing_active, start_syncing_all_logs, stop_syncing_all_logs, make_item_synced_in_collection, upload_collection_item_to_server, sync_unsynced_items_in_db_collection, db_syncing_active, start_syncing_all_db_collections, stop_syncing_all_db_collections, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_backend/log_utils */ "./src/libs_backend/log_utils.ls"), get_log_names = ref$.get_log_names, getInterventionLogCollection = ref$.getInterventionLogCollection;
ref$ = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls"), get_current_collections = ref$.get_current_collections, list_collections_to_sync = ref$.list_collections_to_sync, getCollection = ref$.getCollection;
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_user_id = ref$.get_user_id, get_install_id = ref$.get_install_id;
post_json = __webpack_require__(/*! libs_backend/ajax_utils */ "./src/libs_backend/ajax_utils.js").post_json;
sleep = __webpack_require__(/*! libs_common/common_libs */ "./src/libs_common/common_libs.ls").sleep;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
if ((typeof chrome != 'undefined' && chrome !== null ? (ref$ = chrome.runtime) != null ? ref$.getManifest : void 8 : void 8) != null) {
  chrome_manifest = chrome.runtime.getManifest();
  habitlab_version = chrome_manifest.version;
  developer_mode = chrome_manifest.update_url == null;
  unofficial_version = chrome.runtime.id !== 'obghclocpdgcekcognpkblghkedcpdgd';
} else {
  habitlab_version = 'test';
  developer_mode = true;
  unofficial_version = true;
}
out$.start_syncing_all_data = start_syncing_all_data = function(){
  if (localStorage.getItem('allow_logging') !== 'true') {
    dlog('logging disabled, not syncing data');
    return;
  }
  start_syncing_all_logs();
  return start_syncing_all_db_collections();
};
out$.stop_syncing_all_data = stop_syncing_all_data = function(){
  stop_syncing_all_db_collections();
  return stop_syncing_all_logs();
};
upload_log_item_to_server = async function(name, data){
  var logging_server_url, collection, upload_successful, response, e;
  if (localStorage.getItem('local_logging_server') === 'true') {
    logging_server_url = 'http://localhost:5000/';
  } else {
    logging_server_url = "";
  }
  collection = (await getInterventionLogCollection(name));
  data = import$({}, data);
  data.logname = name;
  upload_successful = true;
  try {
    response = (await post_json(logging_server_url + 'addtolog', data));
    if (response.success) {
      (await collection.where('id').equals(data.id).modify({
        synced: 1
      }));
    } else {
      upload_successful = false;
      dlog('response from server was not successful in upload_log_item_to_server');
      dlog(response);
      dlog(data);
    }
  } catch (e$) {
    e = e$;
    upload_successful = false;
    dlog('error thrown in upload_log_item_to_server');
    dlog(e);
    dlog(data);
    dlog(name);
  }
  return upload_successful;
};
out$.sync_unsynced_logs = sync_unsynced_logs = async function(name){
  var collection, num_unsynced, unsynced_items, all_successful, i$, len$, x, item_upload_success;
  collection = (await getInterventionLogCollection(name));
  num_unsynced = (await collection.where('synced').equals(0).count());
  if (num_unsynced === 0) {
    return true;
  }
  dlog('syncing logs ' + name + ' num_unsynced is: ' + num_unsynced);
  unsynced_items = (await collection.where('synced').equals(0).toArray());
  all_successful = true;
  for (i$ = 0, len$ = unsynced_items.length; i$ < len$; ++i$) {
    x = unsynced_items[i$];
    item_upload_success = (await upload_log_item_to_server(name, x));
    if (!item_upload_success) {
      all_successful = false;
      return false;
    }
  }
  return all_successful;
};
log_syncing_active = false;
out$.start_syncing_all_logs = start_syncing_all_logs = async function(){
  var log_names, i$, len$, logname, all_successful;
  if (log_syncing_active) {
    dlog('log_syncing already active');
    return;
  }
  log_syncing_active = true;
  while (log_syncing_active) {
    log_names = (await get_log_names());
    for (i$ = 0, len$ = log_names.length; i$ < len$; ++i$) {
      logname = log_names[i$];
      if (!log_syncing_active) {
        return;
      }
      all_successful = (await sync_unsynced_logs(logname));
      if (!all_successful) {
        dlog('error during logs syncing, pausing 120 seconds: ' + logname);
        (await sleep(120000));
      }
    }
    (await sleep(1000));
  }
};
out$.stop_syncing_all_logs = stop_syncing_all_logs = function(){
  return log_syncing_active = false;
};
make_item_synced_in_collection = async function(collection_name, item){
  var collection, schema, primary_key, query;
  collection = (await getCollection(collection_name));
  schema = get_current_collections()[collection_name];
  primary_key = schema.split(',')[0];
  if (primary_key === 'key') {
    query = item.key;
  } else if (primary_key === '[key+key2]') {
    query = [item.key, item.key2];
  } else {
    throw new Error('collection has primary key that we do not handle: ' + collection_name);
  }
  return (await collection.where(primary_key).equals(query).and(function(x){
    return x.timestamp === item.timestamp;
  }).modify({
    synced: 1
  }));
};
upload_collection_item_to_server = async function(name, data){
  var logging_server_url, collection, upload_successful, response, e;
  if (localStorage.getItem('local_logging_server') === 'true') {
    logging_server_url = 'http://localhost:5000/';
  } else {
    logging_server_url = "";
  }
  collection = (await getCollection(name));
  data = import$({}, data);
  data.userid = (await get_user_id());
  data.install_id = (await get_install_id());
  data.collection = name;
  data.habitlab_version = habitlab_version;
  if (developer_mode) {
    data.developer_mode = true;
  }
  if (unofficial_version) {
    data.unofficial_version = chrome.runtime.id;
  }
  upload_successful = true;
  try {
    response = (await post_json(logging_server_url + 'sync_collection_item', data));
    if (response.success) {
      (await make_item_synced_in_collection(name, data));
    } else {
      upload_successful = false;
      dlog('response from server was not successful in upload_collection_item_to_server');
      dlog(response);
      dlog(data);
    }
  } catch (e$) {
    e = e$;
    dlog('error thrown in upload_collection_item_to_server');
    dlog(e);
    upload_successful = false;
  }
  return upload_successful;
};
out$.sync_unsynced_items_in_db_collection = sync_unsynced_items_in_db_collection = async function(name){
  var collection, num_unsynced, unsynced_items, all_successful, i$, len$, x, item_upload_success;
  collection = (await getCollection(name));
  num_unsynced = (await collection.where('synced').equals(0).count());
  if (num_unsynced === 0) {
    return true;
  }
  dlog('syncing db items ' + name + ' num_unsynced is: ' + num_unsynced);
  unsynced_items = (await collection.where('synced').equals(0).toArray());
  all_successful = true;
  for (i$ = 0, len$ = unsynced_items.length; i$ < len$; ++i$) {
    x = unsynced_items[i$];
    item_upload_success = (await upload_collection_item_to_server(name, x));
    if (!item_upload_success) {
      all_successful = false;
      return false;
    }
  }
  return all_successful;
};
db_syncing_active = false;
out$.start_syncing_all_db_collections = start_syncing_all_db_collections = async function(){
  var collection_names, infrequently_synced, sync_nums, i$, len$, collection_name, all_successful;
  if (db_syncing_active) {
    dlog('db_syncing already active');
    return;
  }
  db_syncing_active = true;
  collection_names = list_collections_to_sync();
  infrequently_synced = ['seconds_on_domain_per_day', 'seconds_on_domain_per_session', 'custom_measurements_each_day', 'visits_to_domain_per_day'];
  sync_nums = {};
  for (i$ = 0, len$ = infrequently_synced.length; i$ < len$; ++i$) {
    collection_name = infrequently_synced[i$];
    sync_nums[collection_name] = 120;
  }
  while (db_syncing_active) {
    for (i$ = 0, len$ = collection_names.length; i$ < len$; ++i$) {
      collection_name = collection_names[i$];
      if (!db_syncing_active) {
        return;
      }
      if (infrequently_synced.includes(collection_name)) {
        sync_nums[collection_name] += 1;
        if (sync_nums[collection_name] < 120) {
          continue;
        } else {
          sync_nums[collection_name] = 0;
        }
      }
      all_successful = (await sync_unsynced_items_in_db_collection(collection_name));
      if (!all_successful) {
        dlog('error during collection syncing, pausing 1200 seconds: ' + collection_name);
        (await sleep(1200000));
      }
    }
    (await sleep(1000));
  }
};
out$.stop_syncing_all_db_collections = stop_syncing_all_db_collections = function(){
  return db_syncing_active = false;
};
gexport_module('log_sync_utils', function(it){
  return eval(it);
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
//# sourceMappingURL=log_sync_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/log_utils.ls":
/*!***************************************!*\
  !*** ./src/libs_backend/log_utils.ls ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, memoize, memoizeSingleAsync, gexport, gexport_module, get_days_since_epoch, get_user_id, get_install_id, sleep, dexie, generate_random_id, chrome_manifest, habitlab_version, developer_mode, unofficial_version, get_db_major_version_interventionlogdb, get_db_minor_version_interventionlogdb, delete_db_if_outdated_interventionlogdb, get_current_schema_interventionlogdb, get_current_dbver_interventionlogdb, get_interventions_seen_today, get_log_names, intervention_logdb_cache, clear_intervention_logdb_cache, getInterventionLogDb, seen_interventions_cache, check_if_intervention_has_been_seen_and_record_as_seen_if_not, check_if_intervention_has_been_seen, getInterventionLogDb_uncached, deleteInterventionLogDb, getInterventionLogCollection, add_log_history, add_log_goals, log_goal_suggestion, log_goal_suggestion_action, add_log_interventions, add_log_enabledisable, add_log_habitlab_disabled, add_log_habitlab_enabled, add_log_feedback, addtolog, getlog, clearlog, get_num_impressions, get_num_impressions_for_days_before_today, get_num_impressions_today, get_num_actions, get_num_actions_for_days_before_today, get_num_actions_today, log_pageview, log_pagenav, log_pageclick, log_impression_internal, log_intervention_suggested_internal, log_intervention_suggestion_action_internal, log_disable_internal, log_action_internal, log_upvote_internal, log_downvote_internal, log_feedback_internal, intervention_utils, goal_utils, db_utils, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls"), memoize = ref$.memoize, memoizeSingleAsync = ref$.memoizeSingleAsync;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_user_id = ref$.get_user_id, get_install_id = ref$.get_install_id;
sleep = __webpack_require__(/*! libs_common/common_libs */ "./src/libs_common/common_libs.ls").sleep;
dexie = __webpack_require__(/*! dexie */ "./node_modules/dexie/dist/dexie.js");
generate_random_id = __webpack_require__(/*! libs_common/generate_random_id */ "./src/libs_common/generate_random_id.ls").generate_random_id;
if ((typeof chrome != 'undefined' && chrome !== null ? (ref$ = chrome.runtime) != null ? ref$.getManifest : void 8 : void 8) != null) {
  chrome_manifest = chrome.runtime.getManifest();
  habitlab_version = chrome_manifest.version;
  developer_mode = chrome_manifest.update_url == null;
  unofficial_version = chrome.runtime.id !== 'obghclocpdgcekcognpkblghkedcpdgd';
} else {
  habitlab_version = 'test';
  developer_mode = true;
  unofficial_version = true;
}
out$.get_db_major_version_interventionlogdb = get_db_major_version_interventionlogdb = function(){
  return '8';
};
out$.get_db_minor_version_interventionlogdb = get_db_minor_version_interventionlogdb = function(){
  return '1';
};
out$.delete_db_if_outdated_interventionlogdb = delete_db_if_outdated_interventionlogdb = async function(){
  if (localStorage.getItem('db_minor_version_interventionlogdb') !== get_db_minor_version_interventionlogdb()) {
    localStorage.setItem('db_minor_version_interventionlogdb', get_db_minor_version_interventionlogdb());
  }
  if (localStorage.getItem('db_major_version_interventionlogdb') !== get_db_major_version_interventionlogdb()) {
    (await deleteInterventionLogDb());
    localStorage.removeItem('current_schema_interventionlogdb');
    localStorage.setItem('db_major_version_interventionlogdb', get_db_major_version_interventionlogdb());
  }
};
out$.get_current_schema_interventionlogdb = get_current_schema_interventionlogdb = function(){
  var result;
  result = localStorage.getItem('current_schema_interventionlogdb');
  if (result == null) {
    return {};
  }
  return JSON.parse(result);
};
out$.get_current_dbver_interventionlogdb = get_current_dbver_interventionlogdb = function(){
  var result;
  result = localStorage.getItem('current_dbver_interventionlogdb');
  if (result == null) {
    return 0;
  }
  return parseInt(result);
};
out$.get_interventions_seen_today = get_interventions_seen_today = async function(){
  var interventions, enabled, invns, i$, len$, intervention, result, ref$, key, combined;
  interventions = (await intervention_utils.list_all_interventions());
  enabled = (await intervention_utils.get_enabled_interventions());
  invns = [];
  for (i$ = 0, len$ = interventions.length; i$ < len$; ++i$) {
    intervention = interventions[i$];
    result = (await get_num_impressions_today(intervention));
    if (result > 0) {
      invns.push(intervention);
    }
  }
  for (i$ = 0, len$ = (ref$ = Object.keys(enabled)).length; i$ < len$; ++i$) {
    key = ref$[i$];
    if (enabled[key] === false) {
      delete enabled[key];
    }
  }
  combined = Array.from(new Set(invns.concat(enabled)));
  combined.pop();
  return combined;
};
out$.get_log_names = get_log_names = async function(){
  var interventions_list, logs_list;
  interventions_list = (await intervention_utils.list_all_interventions());
  logs_list = ['goals', 'interventions', 'feedback', 'pages', 'enabledisable', 'history'].map(function(it){
    return 'logs/' + it;
  });
  return interventions_list.concat(logs_list);
};
intervention_logdb_cache = null;
out$.clear_intervention_logdb_cache = clear_intervention_logdb_cache = function(){
  if (intervention_logdb_cache != null) {
    intervention_logdb_cache.close();
  }
  return intervention_logdb_cache = null;
};
out$.getInterventionLogDb = getInterventionLogDb = async function(){
  var output;
  if (intervention_logdb_cache != null && intervention_logdb_cache.isOpen()) {
    return intervention_logdb_cache;
  }
  output = (await getInterventionLogDb_uncached());
  intervention_logdb_cache = output;
  return intervention_logdb_cache;
};
seen_interventions_cache = localStorage.getItem('seen_interventions_cache');
if (seen_interventions_cache != null) {
  seen_interventions_cache = JSON.parse(seen_interventions_cache);
} else {
  seen_interventions_cache = {};
}
out$.check_if_intervention_has_been_seen_and_record_as_seen_if_not = check_if_intervention_has_been_seen_and_record_as_seen_if_not = async function(intervention_name){
  var intervention_log_db, intervention_log_collection, intervention_seen, num_items_in_log, cur_epoch;
  if (seen_interventions_cache[intervention_name]) {
    return true;
  }
  seen_interventions_cache[intervention_name] = true;
  intervention_log_db = (await getInterventionLogDb());
  intervention_log_collection = intervention_log_db[intervention_name];
  intervention_seen = false;
  if (intervention_log_collection != null) {
    num_items_in_log = (await intervention_log_collection.count());
    if (num_items_in_log > 0) {
      intervention_seen = true;
    }
  }
  if (intervention_seen) {
    return true;
  }
  seen_interventions_cache[intervention_name] = true;
  localStorage.setItem('seen_interventions_cache', JSON.stringify(seen_interventions_cache));
  cur_epoch = get_days_since_epoch();
  (await db_utils.setvar('last_epoch_new_intervention_seen', cur_epoch));
  return false;
};
out$.check_if_intervention_has_been_seen = check_if_intervention_has_been_seen = async function(intervention_name){
  var intervention_log_db, intervention_log_collection, num_items_in_log;
  if (seen_interventions_cache[intervention_name]) {
    return true;
  }
  intervention_log_db = (await getInterventionLogDb());
  intervention_log_collection = intervention_log_db[intervention_name];
  if (intervention_log_collection == null) {
    return false;
  }
  num_items_in_log = (await intervention_log_collection.count());
  return num_items_in_log > 0;
};
getInterventionLogDb_uncached = async function(){
  var log_names, db, dbver, prev_schema, stores_to_create, i$, len$, logname, new_schema, res$, k, v, realdb;
  (await delete_db_if_outdated_interventionlogdb());
  log_names = (await get_log_names());
  db = new dexie('interventionlog', {
    autoOpen: false
  });
  dbver = get_current_dbver_interventionlogdb();
  prev_schema = get_current_schema_interventionlogdb();
  stores_to_create = {};
  for (i$ = 0, len$ = log_names.length; i$ < len$; ++i$) {
    logname = log_names[i$];
    if (prev_schema[logname] == null) {
      stores_to_create[logname] = '++id,[type+day],type,day,itemid,synced';
    }
  }
  res$ = {};
  for (k in prev_schema) {
    v = prev_schema[k];
    res$[k] = v;
  }
  new_schema = res$;
  if (Object.keys(stores_to_create).length > 0) {
    db.version(dbver).stores(prev_schema);
    dbver += 1;
    for (k in stores_to_create) {
      v = stores_to_create[k];
      new_schema[k] = v;
    }
    db.on('ready', function(){
      localStorage.setItem('current_schema_interventionlogdb', JSON.stringify(new_schema));
      return localStorage.setItem('current_dbver_interventionlogdb', dbver);
    });
    db.on('versionchange', function(){
      intervention_logdb_cache = null;
      db.close();
      return intervention_logdb_cache = null;
    });
  }
  db.version(dbver).stores(new_schema);
  realdb = (await db.open());
  return realdb;
};
out$.deleteInterventionLogDb = deleteInterventionLogDb = async function(){
  var db;
  localStorage.removeItem('current_schema_interventionlogdb');
  localStorage.removeItem('current_dbver_interventionlogdb');
  db = new dexie('interventionlog');
  (await db['delete']());
};
out$.getInterventionLogCollection = getInterventionLogCollection = async function(name){
  var db;
  db = (await getInterventionLogDb());
  return db[name];
};
out$.add_log_history = add_log_history = async function(data){
  var history_id;
  data = import$({}, data);
  if (data.id != null) {
    history_id = data.id;
    data.history_id = history_id;
    delete data.id;
  }
  return (await addtolog('logs/history', data));
};
out$.add_log_goals = add_log_goals = async function(data){
  data = import$({}, data);
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/goals', data));
};
out$.log_goal_suggestion = log_goal_suggestion = async function(data){
  data = import$({}, data);
  data.type = 'goal_suggestion';
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/goals', data));
};
out$.log_goal_suggestion_action = log_goal_suggestion_action = async function(data){
  data = import$({}, data);
  data.type = 'goal_suggestion_action';
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/goals', data));
};
out$.add_log_interventions = add_log_interventions = async function(data){
  data = import$({}, data);
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/interventions', data));
};
out$.add_log_enabledisable = add_log_enabledisable = async function(data){
  data = import$({}, data);
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/enabledisable', data));
};
out$.add_log_habitlab_disabled = add_log_habitlab_disabled = async function(data){
  data = import$({}, data);
  data.type = 'disabled';
  return (await add_log_enabledisable(data));
};
out$.add_log_habitlab_enabled = add_log_habitlab_enabled = async function(data){
  data = import$({}, data);
  data.type = 'enabled';
  return (await add_log_enabledisable(data));
};
out$.add_log_feedback = add_log_feedback = async function(data){
  data = import$({}, data);
  if (data.enabled_interventions == null) {
    data.enabled_interventions = (await intervention_utils.get_enabled_interventions());
  }
  if (data.enabled_goals == null) {
    data.enabled_goals = (await goal_utils.get_enabled_goals());
  }
  return (await addtolog('logs/feedback', data));
};
out$.addtolog = addtolog = async function(name, data){
  var collection, result;
  data = import$({}, data);
  if (data.type == null) {
    data.type = 'general';
  }
  data.userid = (await get_user_id());
  data.install_id = (await get_install_id());
  data.day = get_days_since_epoch();
  data.synced = 0;
  data.timestamp = Date.now();
  data.localtime = new Date().toString();
  data.itemid = generate_random_id();
  data.log_major_ver = get_db_major_version_interventionlogdb();
  data.log_minor_ver = get_db_minor_version_interventionlogdb();
  data.habitlab_version = habitlab_version;
  if (developer_mode) {
    data.developer_mode = true;
  }
  if (unofficial_version) {
    data.unofficial_version = chrome.runtime.id;
  }
  collection = (await getInterventionLogCollection(name));
  result = (await collection.add(data));
  return data;
};
out$.getlog = getlog = async function(name){
  var collection, result;
  collection = (await getInterventionLogCollection(name));
  result = (await collection.toArray());
  return result;
};
out$.clearlog = clearlog = async function(name){
  var collection, num_deleted;
  collection = (await getInterventionLogCollection(name));
  num_deleted = (await collection['delete']());
};
out$.get_num_impressions = get_num_impressions = async function(name){
  var collection, num_impressions;
  collection = (await getInterventionLogCollection(name));
  num_impressions = (await collection.where('type').equals('impression').count());
  return num_impressions;
};
out$.get_num_impressions_for_days_before_today = get_num_impressions_for_days_before_today = async function(name, days_before_today){
  var collection, day, num_impressions;
  collection = (await getInterventionLogCollection(name));
  day = get_days_since_epoch() - days_before_today;
  num_impressions = (await collection.where('[type+day]').equals(['impression', day]).count());
  return num_impressions;
};
out$.get_num_impressions_today = get_num_impressions_today = async function(name){
  return (await get_num_impressions_for_days_before_today(name, 0));
};
out$.get_num_actions = get_num_actions = async function(name){
  var collection, num_actions;
  collection = (await getInterventionLogCollection(name));
  num_actions = (await collection.where('type').equals('action').count());
  return num_actions;
};
out$.get_num_actions_for_days_before_today = get_num_actions_for_days_before_today = async function(name, days_before_today){
  var collection, day, num_actions;
  collection = (await getInterventionLogCollection(name));
  day = get_days_since_epoch() - days_before_today;
  num_actions = (await collection.where('[type+day]').equals(['action', day]).count());
  return num_actions;
};
out$.get_num_actions_today = get_num_actions_today = async function(name){
  return (await get_num_actions_for_days_before_today(name, 0));
};
out$.get_num_actions = get_num_actions = async function(name){
  var collection, day, num_actions;
  collection = (await getInterventionLogCollection(name));
  day = get_days_since_epoch();
  num_actions = (await collection.where('[type+day]').equals(['action', day]).count());
  return num_actions;
};
out$.log_pageview = log_pageview = async function(data){
  var pagepath;
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'view';
  pagepath = window.location.pathname;
  if (window.location.search.length > 0) {
    pagepath += window.location.search;
  }
  if (window.location.hash.length > 0) {
    pagepath += window.location.hash;
  }
  data.page = pagepath;
  return (await addtolog('logs/pages', data));
};
out$.log_pagenav = log_pagenav = async function(data){
  var pagepath;
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'nav';
  pagepath = window.location.pathname;
  if (window.location.search.length > 0) {
    pagepath += window.location.search;
  }
  if (window.location.hash.length > 0) {
    pagepath += window.location.hash;
  }
  data.page = pagepath;
  return (await addtolog('logs/pages', data));
};
out$.log_pageclick = log_pageclick = async function(data){
  var pagepath;
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'click';
  pagepath = window.location.pathname;
  if (window.location.search.length > 0) {
    pagepath += window.location.search;
  }
  if (window.location.hash.length > 0) {
    pagepath += window.location.hash;
  }
  data.page = pagepath;
  return (await addtolog('logs/pages', data));
};
out$.log_impression_internal = log_impression_internal = async function(name, data){
  var intervention_info;
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'impression';
  data.intervention = name;
  (await check_if_intervention_has_been_seen_and_record_as_seen_if_not(name));
  intervention_info = (await intervention_utils.get_intervention_info(name));
  if (intervention_info.generic_intervention != null) {
    name = intervention_info.generic_intervention;
  }
  (await db_utils.setkey_dict('time_intervention_most_recently_seen', name, Date.now()));
  return (await addtolog(name, data));
};
out$.log_intervention_suggested_internal = log_intervention_suggested_internal = async function(name, data){
  var cur_epoch, intervention_info;
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'suggested';
  data.intervention = name;
  (await check_if_intervention_has_been_seen_and_record_as_seen_if_not(name));
  cur_epoch = get_days_since_epoch();
  (await db_utils.setvar('last_epoch_intervention_suggested', cur_epoch));
  intervention_info = (await intervention_utils.get_intervention_info(name));
  if (intervention_info.generic_intervention != null) {
    name = intervention_info.generic_intervention;
  }
  (await db_utils.setkey_dict('time_intervention_most_recently_seen', name, Date.now()));
  return (await addtolog(name, data));
};
out$.log_intervention_suggestion_action_internal = log_intervention_suggestion_action_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'suggestion_action';
  data.intervention = name;
  return (await addtolog(name, data));
};
out$.log_disable_internal = log_disable_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'disable';
  data.intervention = name;
  return (await addtolog(name, data));
};
out$.log_action_internal = log_action_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'action';
  data.intervention = name;
  return (await addtolog(name, data));
};
out$.log_upvote_internal = log_upvote_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'upvote';
  data.intervention = name;
  return (await addtolog(name, data));
};
out$.log_downvote_internal = log_downvote_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'downvote';
  data.intervention = name;
  return (await addtolog(name, data));
};
out$.log_feedback_internal = log_feedback_internal = async function(name, data){
  if (data != null) {
    data = import$({}, data);
  } else {
    data = {};
  }
  data.type = 'feedback';
  data.intervention = name;
  return (await addtolog(name, data));
};
intervention_utils = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls");
goal_utils = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls");
db_utils = __webpack_require__(/*! libs_backend/db_utils */ "./src/libs_backend/db_utils.ls");
gexport_module('log_utils_backend', function(it){
  return eval(it);
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
//# sourceMappingURL=log_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/logging_enabled_utils.ls":
/*!***************************************************!*\
  !*** ./src/libs_backend/logging_enabled_utils.ls ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var post_json, ref$, get_user_id, get_install_id, chrome_manifest, habitlab_version, developer_mode, unofficial_version, get_basic_client_data, send_logging_enabled, send_logging_disabled, send_feature_option, send_feature_enabled, send_feature_disabled, out$ =  true && exports || this;
post_json = __webpack_require__(/*! libs_backend/ajax_utils */ "./src/libs_backend/ajax_utils.js").post_json;
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_user_id = ref$.get_user_id, get_install_id = ref$.get_install_id;
if ((typeof chrome != 'undefined' && chrome !== null ? (ref$ = chrome.runtime) != null ? ref$.getManifest : void 8 : void 8) != null) {
  chrome_manifest = chrome.runtime.getManifest();
  habitlab_version = chrome_manifest.version;
  developer_mode = chrome_manifest.update_url == null;
  unofficial_version = chrome.runtime.id !== 'obghclocpdgcekcognpkblghkedcpdgd';
} else {
  habitlab_version = 'test';
  developer_mode = true;
  unofficial_version = true;
}
out$.get_basic_client_data = get_basic_client_data = async function(){
  var data;
  data = {};
  data.client_timestamp = Date.now();
  data.client_localtime = new Date().toString();
  data.user_id = (await get_user_id());
  data.install_id = (await get_install_id());
  data.browser = navigator.userAgent;
  data.language = navigator.language;
  data.languages = navigator.languages;
  data.version = habitlab_version;
  data.devmode = developer_mode;
  data.chrome_runtime_id = chrome.runtime.id;
  if (unofficial_version) {
    data.unofficial_version = chrome.runtime.id;
  }
  return data;
};
out$.send_logging_enabled = send_logging_enabled = async function(options){
  var data, k, v;
  options = options != null
    ? options
    : {};
  data = (await get_basic_client_data());
  data.logging_enabled = true;
  for (k in options) {
    v = options[k];
    data[k] = v;
  }
};
out$.send_logging_disabled = send_logging_disabled = async function(options){
  var data, k, v;
  options = options != null
    ? options
    : {};
  data = (await get_basic_client_data());
  data.logging_enabled = false;
  for (k in options) {
    v = options[k];
    data[k] = v;
  }
};
out$.send_feature_option = send_feature_option = async function(options){
  var data, k, v;
  options = options != null
    ? options
    : {};
  data = (await get_basic_client_data());
  for (k in options) {
    v = options[k];
    data[k] = v;
  }
};
out$.send_feature_enabled = send_feature_enabled = async function(options){
  var data, k, v;
  options = options != null
    ? options
    : {};
  data = (await get_basic_client_data());
  data.feature_enabled = true;
  for (k in options) {
    v = options[k];
    data[k] = v;
  }
};
out$.send_feature_disabled = send_feature_disabled = async function(options){
  var data, k, v;
  options = options != null
    ? options
    : {};
  data = (await get_basic_client_data());
  data.feature_enabled = false;
  for (k in options) {
    v = options[k];
    data[k] = v;
  }
};
//# sourceMappingURL=logging_enabled_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/multi_armed_bandit.ls":
/*!************************************************!*\
  !*** ./src/libs_backend/multi_armed_bandit.ls ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var multi_armed_bandit_thompson, get_multi_armed_bandit_algorithm, out$ =  true && exports || this;
multi_armed_bandit_thompson = __webpack_require__(/*! libs_backend/multi_armed_bandit_thompson */ "./src/libs_backend/multi_armed_bandit_thompson.ls");
out$.get_multi_armed_bandit_algorithm = get_multi_armed_bandit_algorithm = function(algorithm_name, algorithm_options){
  if (algorithm_name === 'thompson') {
    return multi_armed_bandit_thompson;
  }
  throw new Error("unknown algorithm name in get_multi_armed_bandit_algorithm " + algorithm_name);
};
//# sourceMappingURL=multi_armed_bandit.ls.map


/***/ }),

/***/ "./src/libs_backend/multi_armed_bandit_thompson.ls":
/*!*********************************************************!*\
  !*** ./src/libs_backend/multi_armed_bandit_thompson.ls ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, as_array, bandits, get_seconds_spent_for_each_session_per_intervention, list_enabled_interventions_for_goal, get_goals, ThompsonMAB, train_multi_armed_bandit_for_goal, intervention_utils, intervention_manager, goal_progress, __get__, __set__, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
as_array = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls").as_array;
bandits = __webpack_require__(/*! percipio */ "./node_modules/percipio/src/index.js").bandits;
ref$ = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls"), get_seconds_spent_for_each_session_per_intervention = ref$.get_seconds_spent_for_each_session_per_intervention, list_enabled_interventions_for_goal = ref$.list_enabled_interventions_for_goal;
get_goals = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls").get_goals;
/**
 * This algorithm recommends interventions using the Generalized Thompson Sampling Algorithm.
 * This Thompson Sampling Algorithm draws inspiration from:
 * Daniel J. Russo, Benjamin Van Roy, Abbas Kazerouni, Ian
 * Osband and Zheng Wen (2018), “A Tutorial on Thompson Sampling”, Foundations and
 * Trends in Machine Learning: Vol. 11, No. 1, pp 1–96. DOI: 10.1561/2200000070.
 * This Thompson Sampling is designed solely for handling a multi-armbed-bandit problem with TIME observations.
 * Currently, we will train the algorithm with all previous sessions on each instance of the extension
 * TODO: Investigate whether this will cause a performance bottleneck and rewrite the algorithm to 
 * maintain the posterior and only train with one new instance each time.
 */
out$.ThompsonMAB = ThompsonMAB = (function(){
  /**
   * Instantiates Thompson Multi Armed Bandit with Prior Distribution Parameters.
   * Note, our observations are time, so we can assume that our observations are log-Gaussian distributed.
   * For each arm (intervention), we will have (mu, sigma) parameters.
   * We will choose our prior parameters to be $$\mu_i=-1/2$$ and $$\sigma_i^2=1$$ so $$E[\theta_i]=1$$
   * for each intervention $$i$$.
   * We will also assume that our sigma_tilde (Gaussian Noise) is 1. TODO: Investigate this assumption.
   * @param arms_list: a list of intervention names.
   * @param sampling_factor: coefficient that represents degree to which the Thompson Sampling is considered
   * relative to novelty factor. If higher than novelty factor, sampling factor is considered more.
   * @param novelty_factor: coefficient that represents degree to which the novelty of an intervention
   * is considered relative to the sampling_factor for recommending an intervention.
   */
  ThompsonMAB.displayName = 'ThompsonMAB';
  var prototype = ThompsonMAB.prototype, constructor = ThompsonMAB;
  function ThompsonMAB(arms_list, sampling_factor, novelty_factor){
    var mu, sigma, i$, ref$, len$, intervention_name, gaussian;
    this.arms_list = arms_list;
    this.sampling_factor = sampling_factor;
    this.novelty_factor = novelty_factor;
    if (!(this.sampling_factor != null)) {
      this.sampling_factor = 1;
    }
    if (!(this.novelty_factor != null)) {
      this.novelty_factor = 0;
    }
    this.sigma_tilde = 1;
    mu = -1 / 2;
    sigma = 1;
    this.posterior_params = {};
    for (i$ = 0, len$ = (ref$ = this.arms_list).length; i$ < len$; ++i$) {
      intervention_name = ref$[i$];
      this.posterior_params[intervention_name] = [mu, sigma];
    }
    gaussian = __webpack_require__(/*! gaussian */ "./node_modules/gaussian/lib/gaussian.js");
    this.norm_distribution = gaussian(0, 1);
  }
  /**
   * Learns this new observation and updates the posterior.
   * @param arm: name of intervention.
   * @param observation: time spent with that intervention.
   */
  ThompsonMAB.prototype.learn = function(arm, observation){
    var intervention_name, old_std, old_mean, old_precision, noise_precision, new_precision, new_mean, new_std;
    if (observation <= 0) {
      observation = 1;
    }
    intervention_name = arm;
    old_std = this.posterior_params[intervention_name][1];
    old_mean = this.posterior_params[intervention_name][0];
    old_precision = 1.0 / Math.pow(old_std, 2);
    noise_precision = 1.0 / Math.pow(this.sigma_tilde, 2);
    new_precision = old_precision + noise_precision;
    new_mean = (noise_precision * (Math.log(observation) + 0.5 / noise_precision) + old_precision * old_mean) / new_precision;
    new_std = Math.sqrt(1.0 / new_precision);
    return this.posterior_params[intervention_name] = [new_mean, new_std];
  };
  /**
   * @return dictionary of {intervention_name: time}
   */
  ThompsonMAB.prototype.sample_times = function(){
    var dictionary, i$, ref$, len$, intervention_name, params, omean, std, Z;
    dictionary = {};
    for (i$ = 0, len$ = (ref$ = this.arms_list).length; i$ < len$; ++i$) {
      intervention_name = ref$[i$];
      params = this.posterior_params[intervention_name];
      omean = params[0];
      std = params[1];
      Z = this.norm_distribution.ppf(Math.random());
      dictionary[intervention_name] = Math.exp(omean + std * Z);
    }
    return dictionary;
  };
  /**
   * @param dictionary: {intervention_name: number}
   * @return normalized dictionary.
   */
  ThompsonMAB.prototype.normalize = function(dictionary){
    var total, key;
    total = 0;
    for (key in dictionary) {
      total += dictionary[key];
    }
    for (key in dictionary) {
      dictionary[key] /= total;
    }
    return dictionary;
  };
  /**
    * Based on our posterior parameters, recommend which intervention to choose to minimize time spent.
    * @param novelty: dictionary formatted like {<intervention_name>: <novelty>} 
    * where novelty is the time since that intervention was used. Optional.
    * @return: the name of the intervention we recommend.
    */
  ThompsonMAB.prototype.predict = function(novelty){
    var sample, best_intervention, i$, ref$, len$, intervention_name, novelty_value, reward;
    sample = this.normalize(this.sample_times());
    if (novelty != null) {
      novelty = this.normalize(novelty);
    }
    best_intervention = {};
    for (i$ = 0, len$ = (ref$ = this.arms_list).length; i$ < len$; ++i$) {
      intervention_name = ref$[i$];
      novelty_value = 0;
      if (novelty != null) {
        novelty_value = novelty[intervention_name];
      }
      reward = -1 * this.sampling_factor * sample[intervention_name] + this.novelty_factor * novelty_value;
      if (best_intervention.intervention_name == null || best_intervention.reward < reward) {
        best_intervention.intervention_name = intervention_name;
        best_intervention.reward = reward;
      }
    }
    return best_intervention.intervention_name;
  };
  return ThompsonMAB;
}());
/**
 * Trains predictor for choosing which intervention to use given a goal using Thompson Sampling.
 * Each sample is the session length using an intervention.
 * @param sample_coefficient, novelty_coefficient: see ThompsonMAB
 * @return A predictor for which intervention to choose.
 */
out$.train_multi_armed_bandit_for_goal = train_multi_armed_bandit_for_goal = async function(goal_name, intervention_names, sample_coefficient, novelty_coefficient){
  var bandit, goals, intervention_times, intervention_name, i$, ref$, len$, time;
  bandit = new ThompsonMAB(intervention_names, sample_coefficient, novelty_coefficient);
  if (intervention_names == null) {
    intervention_names = (await intervention_utils.list_enabled_interventions_for_goal(goal_name));
  }
  goals = (await get_goals());
  intervention_times = (await intervention_utils.get_seconds_spent_for_each_session_per_intervention(goals[goal_name].domain));
  for (intervention_name in intervention_times) {
    for (i$ = 0, len$ = (ref$ = intervention_times[intervention_name]).length; i$ < len$; ++i$) {
      time = ref$[i$];
      bandit.learn(intervention_name, time);
    }
  }
  return bandit;
};
intervention_utils = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls");
intervention_manager = __webpack_require__(/*! libs_backend/intervention_manager */ "./src/libs_backend/intervention_manager.ls");
goal_progress = __webpack_require__(/*! libs_backend/goal_progress */ "./src/libs_backend/goal_progress.ls");
out$.__get__ = __get__ = function(name){
  return eval(name);
};
out$.__set__ = __set__ = function(name, val){
  return eval(name + ' = val');
};
gexport_module('multi_armed_bandit_thompson', function(it){
  return eval(it);
});
//# sourceMappingURL=multi_armed_bandit_thompson.ls.map


/***/ }),

/***/ "./src/libs_backend/notification_timer.js":
/*!************************************************!*\
  !*** ./src/libs_backend/notification_timer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  get_num_enabled_goals
} = __webpack_require__ (/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls")
const {
  get_num_goals_met_yesterday
} = __webpack_require__ (/*! libs_backend/goal_progress */ "./src/libs_backend/goal_progress.ls")

document.addEventListener('DOMContentLoaded', function () {
  if (Notification.permission !== "granted")
    Notification.requestPermission();
});

function make_notification(num_met, num_goals) {
  if (Notification.permission !== "granted")
    Notification.requestPermission();
  else {
    var notification = new Notification('HabitLab Goal Checkup', {
      icon: chrome.extension.getURL('icons/icon_128.png'),
      body: "You met " + num_met + " out of " + num_goals + " goal(s)."
    });
    notification.onclick = function () {
      chrome.tabs.create({url: chrome.extension.getURL('index.html?tag=goals-met-over-time')});
    };
  }
}

var prev_date = new Date();

/*
  Function: Recurring Goal Completion Check
  -----------------------------------------
  Function that repeatedly checks every minute if the time now signifies that the date has changed. If it has, make a notification on how many goals the user met the previous day.
*/
setInterval(async function() {
  var cur_date = new Date();
  if (cur_date.getDate() !== prev_date.getDate()) {
    //new day
    if (localStorage.getItem('allow_daily_goal_notifications') == 'false') {
      return
    }
    var num_goals_total = await get_num_enabled_goals();
    var num_goals_met = await get_num_goals_met_yesterday();
    make_notification(num_goals_met, num_goals_total);
  }
  prev_date = cur_date;
}, 60000)



/***/ }),

/***/ "./src/libs_backend/notification_utils_backend.js":
/*!********************************************************!*\
  !*** ./src/libs_backend/notification_utils_backend.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

let notification_id_to_notification = {};

async function make_notification_backend(info, tab_id) {
  let title = info.title;
  if (title) {
    delete info.title;
  }
  let notification = new Notification(title, info);
  let notification_id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  notification_id_to_notification[notification_id] = notification;
  if (typeof tab_id !== "undefined" && tab_id !== null) {
    notification_onclick_backend(notification_id, function() {
      chrome.tabs.sendMessage(tab_id, {
        type: 'notification_onclick',
        data: {notification_id: notification_id}
      });
    });
  }
  return notification_id;
}

function notification_onclick_backend(notification_id, callback) {
  let notification = notification_id_to_notification[notification_id];
  notification.onclick = callback;
}

function close_notification_backend(notification_id) {
  let notification = notification_id_to_notification[notification_id];
  let close_notification_func = notification.close.bind(notification);
  close_notification_func();
  delete notification_id_to_notification[notification_id];
}

module.exports = {
  make_notification_backend,
  notification_onclick_backend,
  close_notification_backend
}

/***/ }),

/***/ "./src/libs_backend/persistent_storage_utils.js":
/*!******************************************************!*\
  !*** ./src/libs_backend/persistent_storage_utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var temporary_variables = {}

async function set_var(key, val) {
  temporary_variables[key] = val;
}

async function get_var(key) {
  return temporary_variables[key];
}

module.exports = {
  set_var,
  get_var
}

/***/ }),

/***/ "./src/libs_backend/require_remote_utils.ls":
/*!**************************************************!*\
  !*** ./src/libs_backend/require_remote_utils.ls ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var remoteget, ref$, gexport, gexport_module, add_remote_library_async, hash_string, hash_string_to_libname, require_remote_async, out$ =  true && exports || this;
remoteget = __webpack_require__(/*! libs_backend/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls").remoteget;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.add_remote_library_async = add_remote_library_async = async function(libname, url){
  var library_contents, libname_mapping;
  library_contents = (await remoteget(url));
  libname_mapping = {};
  libname_mapping[libname] = 'data:text/javascript;base64,' + btoa(unescape(encodeURIComponent(library_contents)));
  SystemJS.config({
    map: libname_mapping
  });
};
hash_string = function(s){
  var hash, i, char, l;
  hash = 0;
  i = 0;
  char = 0;
  l = s.length;
  if (l === 0) {
    return hash;
  }
  while (i < l) {
    char = s.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash | 0;
    i += 1;
  }
  return hash;
};
hash_string_to_libname = function(s){
  var hash, x;
  hash = hash_string(s);
  return (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = hash.toString()).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push('abcdefghij'[parseInt(x)]);
    }
    return results$;
  }()).join('');
};
out$.require_remote_async = require_remote_async = async function(url){
  var libname;
  if (!url.includes('://')) {
    url = 'https://unpkg.com/' + url;
  }
  libname = hash_string_to_libname(url);
  (await add_remote_library_async(libname, url));
  return (await SystemJS['import'](libname));
};
gexport_module('require_remote_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=require_remote_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/screenshot_utils.ls":
/*!**********************************************!*\
  !*** ./src/libs_backend/screenshot_utils.ls ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, get_active_tab_info, list_currently_loaded_interventions, get_user_id, get_goals, get_enabled_goals, get_interventions, get_enabled_interventions, as_array, get_screenshot_as_base64, get_data_for_feedback, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
ref$ = __webpack_require__(/*! libs_backend/background_common */ "./src/libs_backend/background_common.ls"), get_active_tab_info = ref$.get_active_tab_info, list_currently_loaded_interventions = ref$.list_currently_loaded_interventions, get_user_id = ref$.get_user_id;
ref$ = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls"), get_goals = ref$.get_goals, get_enabled_goals = ref$.get_enabled_goals;
ref$ = __webpack_require__(/*! libs_backend/intervention_utils */ "./src/libs_backend/intervention_utils.ls"), get_interventions = ref$.get_interventions, get_enabled_interventions = ref$.get_enabled_interventions;
as_array = __webpack_require__(/*! libs_common/collection_utils */ "./src/libs_common/collection_utils.ls").as_array;
out$.get_screenshot_as_base64 = get_screenshot_as_base64 = async function(){
  var data_url;
  data_url = (await new Promise(function(it){
    return chrome.tabs.captureVisibleTab(chrome.windows.WINDOW_ID_CURRENT, {}, it);
  }));
  return data_url;
};
out$.get_data_for_feedback = get_data_for_feedback = async function(){
  var data, goal_name, ref$, goal_info;
  data = {};
  data.background_url = window.location.href;
  data.browser = navigator.userAgent;
  data.language = navigator.language;
  data.languages = navigator.languages;
  data.extra = {};
  data.extra.user_id = (await get_user_id());
  data.extra.tab_info = (await get_active_tab_info());
  data.url = data.extra.tab_info.url;
  data.loaded_interventions = (await list_currently_loaded_interventions());
  data.extra.interventions = JSON.parse(JSON.stringify((await get_interventions())));
  data.extra.goals = JSON.parse(JSON.stringify((await get_goals())));
  for (goal_name in ref$ = data.extra.goals) {
    goal_info = ref$[goal_name];
    if (goal_info.icon != null) {
      delete goal_info.icon;
    }
  }
  data.enabled_interventions = as_array((await get_enabled_interventions()));
  data.enabled_goals = as_array((await get_enabled_goals()));
  data.extra.manifest = chrome.runtime.getManifest();
  data.devmode = data.extra.manifest.update_url == null;
  data.version = data.extra.manifest.version;
  data.chrome_runtime_id = chrome.runtime.id;
  data.extra.client_timestamp = Date.now();
  data.extra.client_localtime = new Date().toString();
  return data;
};
gexport_module('screenshot_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=screenshot_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/session_utils.ls":
/*!*******************************************!*\
  !*** ./src/libs_backend/session_utils.ls ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, url_to_domain, tab_id_to_prev2_url_visited, tab_id_to_prev1_url_visited, past_navigation_events_list, tab_id_to_current_session_id, get_session_id_from_tab_id, session_id_counter, add_tab_navigation_event, session_id_to_data, set_session_data_sync, set_session_data, get_session_data_sync, get_session_data, is_on_same_domain_and_same_tab_sync, is_on_same_domain_and_same_tab, is_on_same_domain_sync, is_on_same_domain, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
tab_id_to_prev2_url_visited = {};
tab_id_to_prev1_url_visited = {};
past_navigation_events_list = [];
tab_id_to_current_session_id = {};
out$.get_session_id_from_tab_id = get_session_id_from_tab_id = async function(tab_id){
  return tab_id_to_current_session_id[tab_id] != null;
};
session_id_counter = 0;
out$.add_tab_navigation_event = add_tab_navigation_event = function(tab_id, url){
  if (tab_id_to_prev1_url_visited[tab_id] != null) {
    tab_id_to_prev2_url_visited[tab_id] = tab_id_to_prev1_url_visited[tab_id];
  }
  tab_id_to_prev1_url_visited[tab_id] = url;
  while (past_navigation_events_list.length > 1) {
    past_navigation_events_list.shift();
  }
  past_navigation_events_list.push([tab_id, url]);
  if (tab_id_to_current_session_id[tab_id] == null) {
    session_id_counter = session_id_counter + 1;
    tab_id_to_current_session_id[tab_id] = session_id_counter;
  } else {
    if (!is_on_same_domain_and_same_tab_sync(tab_id)) {
      session_id_counter = session_id_counter + 1;
      tab_id_to_current_session_id[tab_id] = session_id_counter;
    }
  }
};
session_id_to_data = {};
set_session_data_sync = function(session_id, key, val){
  if (session_id_to_data[session_id] == null) {
    session_id_to_data[session_id] = {};
  }
  session_id_to_data[key] = val;
};
out$.set_session_data = set_session_data = async function(session_id, key, val){
  set_session_data_sync(session_id, key, val);
};
get_session_data_sync = function(session_id, key){
  var session_data;
  session_data = session_id_to_data[session_id];
  if (session_data != null) {
    return session_data[key];
  }
  return null;
};
out$.get_session_data = get_session_data = async function(session_id, key){
  return get_session_data_sync(session_id, key);
};
/*
export is_on_same_domain_and_same_tab = (tab_id) ->>
  current_url = tab_id_to_prev1_url_visited[tab_id]
  prev_url = tab_id_to_prev2_url_visited[tab_id]
  if not prev_url? or not current_url?
    return false
  current_domain = url_to_domain current_url
  prev_domain = url_to_domain prev_url
  return prev_domain == current_domain
*/
is_on_same_domain_and_same_tab_sync = function(tab_id){
  var current_tab_id_and_url, prev_tab_id_and_url, current_url, prev_url, current_tab_id, prev_tab_id, current_domain, prev_domain;
  current_tab_id_and_url = past_navigation_events_list[1];
  prev_tab_id_and_url = past_navigation_events_list[0];
  if (current_tab_id_and_url == null || prev_tab_id_and_url == null) {
    return false;
  }
  current_url = current_tab_id_and_url[1];
  prev_url = prev_tab_id_and_url[1];
  if (current_url == null || prev_url == null) {
    return false;
  }
  current_tab_id = current_tab_id_and_url[0];
  prev_tab_id = prev_tab_id_and_url[0];
  current_domain = url_to_domain(current_url);
  prev_domain = url_to_domain(prev_url);
  return current_domain === prev_domain && current_tab_id === prev_tab_id;
};
out$.is_on_same_domain_and_same_tab = is_on_same_domain_and_same_tab = async function(tab_id){
  return is_on_same_domain_and_same_tab_sync(tab_id);
};
is_on_same_domain_sync = function(tab_id){
  var current_tab_id_and_url, prev_tab_id_and_url, current_url, prev_url, current_domain, prev_domain;
  current_tab_id_and_url = past_navigation_events_list[1];
  prev_tab_id_and_url = past_navigation_events_list[0];
  if (current_tab_id_and_url == null || prev_tab_id_and_url == null) {
    return false;
  }
  current_url = current_tab_id_and_url[1];
  prev_url = prev_tab_id_and_url[1];
  if (current_url == null || prev_url == null) {
    return false;
  }
  current_domain = url_to_domain(current_url);
  prev_domain = url_to_domain(prev_url);
  return current_domain === prev_domain;
};
out$.is_on_same_domain = is_on_same_domain = async function(tab_id){
  return is_on_same_domain_sync(tab_id);
};
gexport_module('session_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=session_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/streak_utils.ls":
/*!******************************************!*\
  !*** ./src/libs_backend/streak_utils.ls ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var get_duolingo_streak, get_codeacademy_streak, get_goal_target, get_progress_on_goal_days_before_today, get_streak;
get_duolingo_streak = __webpack_require__(/*! libs_backend/duolingo_utils */ "./src/libs_backend/duolingo_utils.js").get_duolingo_streak;
get_codeacademy_streak = __webpack_require__(/*! libs_backend/codeacademy_utils */ "./src/libs_backend/codeacademy_utils.js").get_codeacademy_streak;
get_goal_target = __webpack_require__(/*! libs_backend/goal_utils */ "./src/libs_backend/goal_utils.ls").get_goal_target;
get_progress_on_goal_days_before_today = __webpack_require__(/*! libs_backend/goal_progress */ "./src/libs_backend/goal_progress.ls").get_progress_on_goal_days_before_today;
/**
 * Returns the length  of the streak for the given goal
 * @param {<GoalInfo>} goal_info of the goal 
 * @return {Promise.<Number>} length of streak
 */
get_streak = async function(goal_info){
  var goal_name, target, streak, streak_continuing, progress_info;
  goal_name = goal_info.name;
  if (goal_name === 'duolingo/complete_lesson_each_day') {
    return (await get_duolingo_streak());
  } else if (goal_name === 'codeacademy/practice_each_day') {
    return (await get_codeacademy_streak());
  } else {
    target = (await get_goal_target(goal_name));
    streak = 0;
    streak_continuing = true;
    while (streak_continuing) {
      progress_info = (await get_progress_on_goal_days_before_today(goal_name, streak));
      if (goal_info.is_positive === progress_info.progress >= target) {
        streak += 1;
      } else {
        streak_continuing = false;
      }
    }
    return streak;
  }
};
module.exports = {
  get_streak: get_streak
};
//# sourceMappingURL=streak_utils.ls.map


/***/ }),

/***/ "./src/libs_backend/systemjs.js":
/*!**************************************!*\
  !*** ./src/libs_backend/systemjs.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  if (!window.systemjs_fetch) {
    var {systemjsget, remoteget} = __webpack_require__(/*! libs_backend/cacheget_utils */ "./src/libs_backend/cacheget_utils.ls");
    var chrome_base_url = chrome.runtime.getURL('');
    var is_local_package = function(input) {
      for (var prefix of ['bower_components', 'bundles', 'components', 'frontend_utils', 'generated_libs', 'goals', 'intervention_utils', 'jspm_packages', 'libs_backend', 'libs_common', 'libs_frontend', 'modules_custom']) {
        if (input.startsWith(chrome_base_url + prefix + '/')) {
          return true;
        }
      }
      return false;
    }
    window.systemjs_fetch = function(input, init) {
      if (input.startsWith(chrome_base_url)) {
        if (is_local_package(input)) {
          return systemjsget(input).then(function(text) {
            return new Response(text);
          });
        } else {
          var npm_package_name = input.replace(chrome_base_url, '');
          var url = 'https://unpkg.com/' + npm_package_name;
          return remoteget(url).then(function(text) {
            return new Response(text);
          })
        }
      }
      return fetch(input, init);
    }
  }
})();

if (!window.SystemJS) {
  __webpack_require__(/*! script-loader!jspm_packages/system.js */ "./node_modules/script-loader/index.js!./src/jspm_packages/system.js")
  __webpack_require__(/*! ../systemjs_paths.js */ "./src/systemjs_paths.js")
  __webpack_require__(/*! ../../jspm.config.js */ "./jspm.config.js")
  __webpack_require__(/*! ../../jspm_config_backend.js */ "./jspm_config_backend.js");
  SystemJS.import_multi = function(libs_list, callback) {
    if (callback) {
      Promise.all(libs_list.map(lib_name => SystemJS.import(lib_name))).then(function(args) {
        callback(...args);
      });
    } else {
      return Promise.all(libs_list.map(lib_name => SystemJS.import(lib_name)));
    }
  }
}


/***/ }),

/***/ "./src/libs_backend/tab_utils.js":
/*!***************************************!*\
  !*** ./src/libs_backend/tab_utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Closes the selected tab
 * @return {Promise.<undefined>} No return value, promise resolves once tab is closed
 */
async function close_selected_tab() {
  let tabs = await new Promise(function(cb) {
    chrome.tabs.query({active: true, windowId: chrome.windows.WINDOW_ID_CURRENT}, cb)
  })
  if (tabs[0] != null) {
    chrome.tabs.remove(tabs[0].id)
  }
  return
}

/**
* Closes the tab with the specified tab id
* @param {number} tab_id - The id of the tab
*/
async function close_tab_with_id(tab_id) {
  chrome.tabs.remove(tab_id)
  return
}

/**
* Opens the specified URL in a new tab
* @param {string} url - The URL we want to open in a new tab
*/
async function open_url_in_new_tab(url) {
  let tab = await new Promise(function(cb) {
    chrome.tabs.create({url: url}, cb)
  })
  return
}

/**
* Gets the tab id for the selected tab
* @return {Promise.<number>} The id of the selected tab
*/
async function get_selected_tab_id() {
  let tabs = await new Promise(function(cb) {
    chrome.tabs.query({active: true, windowId: chrome.windows.WINDOW_ID_CURRENT}, cb)
  })
  if (tabs[0] != null) {
    return tabs[0].id
  }
  return
}

module.exports = {
  close_selected_tab,
  close_tab_with_id,
  open_url_in_new_tab,
  get_selected_tab_id,
}

/***/ }),

/***/ "./src/libs_common/array_utils.ls":
/*!****************************************!*\
  !*** ./src/libs_common/array_utils.ls ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var unique, unique_concat, out$ =  true && exports || this;
out$.unique = unique = function(arr){
  var output, seen, i$, len$, x;
  output = [];
  seen = {};
  for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
    x = arr[i$];
    if (seen[x] != null) {
      continue;
    }
    seen[x] = true;
    output.push(x);
  }
  return output;
};
out$.unique_concat = unique_concat = function(){
  var array_list, res$, i$, to$, output, seen, len$, arr, j$, len1$, x;
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  array_list = res$;
  output = [];
  seen = {};
  for (i$ = 0, len$ = array_list.length; i$ < len$; ++i$) {
    arr = array_list[i$];
    for (j$ = 0, len1$ = arr.length; j$ < len1$; ++j$) {
      x = arr[j$];
      if (seen[x] != null) {
        continue;
      }
      seen[x] = true;
      output.push(x);
    }
  }
  return output;
};
//# sourceMappingURL=array_utils.ls.map


/***/ }),

/***/ "./src/libs_common/badges_utils.ls":
/*!*****************************************!*\
  !*** ./src/libs_common/badges_utils.ls ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, memoize, list_all_badge_info, get_minutes_saved_to_badges, get_badge_for_minutes_saved, get_timesaved_badge_that_should_be_awarded, get_all_badges_earned_for_minutes_saved, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
memoize = __webpack_require__(/*! libs_common/memoize */ "./src/libs_common/memoize.ls").memoize;
out$.list_all_badge_info = list_all_badge_info = function(){
  var output, i$, len$, badge_info, ref$;
  output = [
    {
      minutes_saved: 10,
      name: 'Mile Run',
      message: 'That is enough time to run a mile!',
      icon: 'run.svg'
    }, {
      minutes_saved: 20,
      name: 'Nap Time',
      message: 'That is enough time to fit in a quick nap!',
      icon: 'nap.svg'
    }, {
      minutes_saved: 40,
      name: 'Workout',
      message: 'That is enough time for a workout!',
      icon: 'workout.svg'
    }, {
      minutes_saved: 60,
      name: 'Hike',
      message: 'That is enough time for a hike!',
      icon: 'hike.svg'
    }, {
      minutes_saved: 2 * 60,
      name: 'Harry Potter',
      message: 'That is enough time to watch the first Harry Potter movie!',
      icon: 'wizard.svg'
    }, {
      minutes_saved: 3 * 60,
      name: 'Museum',
      message: 'That is enough time to go to go explore a museum!',
      icon: 'museum.svg'
    }, {
      minutes_saved: 4 * 60,
      name: 'Surfing',
      message: 'That is enough time to go to the beach for some surfing!',
      icon: 'surfing.svg'
    }, {
      minutes_saved: 5 * 60,
      name: 'Skydiving',
      message: 'That is enough time for a skydiving expedition!',
      icon: 'skydiving.svg'
    }
  ];
  for (i$ = 0, len$ = output.length; i$ < len$; ++i$) {
    badge_info = output[i$];
    if (badge_info.icon != null) {
      badge_info.img_url = chrome.extension.getURL("icons/badges/" + badge_info.icon);
    }
    badge_info.type = 'minutes_saved';
    if (badge_info.minutes_saved != null) {
      if (59 < (ref$ = badge_info.minutes_saved) && ref$ < 61) {
        badge_info.time_message = '1 hour';
      } else if (badge_info.minutes_saved > 61) {
        badge_info.time_message = Math.round(badge_info.minutes_saved / 60) + " hours";
      } else {
        badge_info.time_message = badge_info.minutes_saved + " minutes";
      }
    }
  }
  return output;
};
out$.get_minutes_saved_to_badges = get_minutes_saved_to_badges = memoize(function(){
  var output, i$, ref$, len$, badge_info;
  output = {};
  for (i$ = 0, len$ = (ref$ = list_all_badge_info()).length; i$ < len$; ++i$) {
    badge_info = ref$[i$];
    output[badge_info.minutes_saved] = badge_info;
  }
  return output;
});
out$.get_badge_for_minutes_saved = get_badge_for_minutes_saved = function(minutes_saved){
  var minutes_saved_to_badges;
  minutes_saved_to_badges = get_minutes_saved_to_badges();
  return minutes_saved_to_badges[minutes_saved];
};
out$.get_timesaved_badge_that_should_be_awarded = get_timesaved_badge_that_should_be_awarded = function(seconds_saved, seconds_saved_prev){
  var i$, ref$, len$, badge_info, ref1$;
  for (i$ = 0, len$ = (ref$ = list_all_badge_info()).length; i$ < len$; ++i$) {
    badge_info = ref$[i$];
    if (seconds_saved_prev < (ref1$ = badge_info.minutes_saved * 60) && ref1$ <= seconds_saved) {
      return badge_info;
    }
  }
};
out$.get_all_badges_earned_for_minutes_saved = get_all_badges_earned_for_minutes_saved = function(minutes_saved){
  var output, i$, ref$, len$, badge_info;
  output = [];
  for (i$ = 0, len$ = (ref$ = list_all_badge_info()).length; i$ < len$; ++i$) {
    badge_info = ref$[i$];
    if (badge_info.minutes_saved <= minutes_saved) {
      output.push(badge_info);
    }
  }
  return output;
};
gexport_module('badges_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=badges_utils.ls.map


/***/ }),

/***/ "./src/libs_common/collection_utils.ls":
/*!*********************************************!*\
  !*** ./src/libs_common/collection_utils.ls ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var as_array, as_dictset, remove_key_from_localstorage_dict, remove_keys_from_localstorage_dict, remove_keys_matching_patternfunc_from_localstorage_dict, add_key_val_to_localstorage_dict, add_dict_to_localstorage_dict, remove_item_from_localstorage_list, remove_items_from_localstorage_list, remove_items_matching_patternfunc_from_localstorage_list, add_item_to_localstorage_list, out$ =  true && exports || this;
out$.as_array = as_array = function(data){
  var k, v;
  if (Array.isArray(data)) {
    return data;
  }
  return (function(){
    var ref$, results$ = [];
    for (k in ref$ = data) {
      v = ref$[k];
      if (v === true) {
        results$.push(k);
      }
    }
    return results$;
  }());
};
out$.as_dictset = as_dictset = function(data){
  var k;
  if (Array.isArray(data)) {
    return (function(){
      var i$, ref$, len$, resultObj$ = {};
      for (i$ = 0, len$ = (ref$ = data).length; i$ < len$; ++i$) {
        k = ref$[i$];
        resultObj$[k] = true;
      }
      return resultObj$;
    }());
  }
  return data;
};
out$.remove_key_from_localstorage_dict = remove_key_from_localstorage_dict = function(dictname, key){
  var dict_text, dict;
  dict_text = localStorage.getItem(dictname);
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  if (dict[key] != null) {
    delete dict[key];
  }
  localStorage.setItem(dictname, JSON.stringify(dict));
};
out$.remove_keys_from_localstorage_dict = remove_keys_from_localstorage_dict = function(dictname, key_list){
  var dict_text, dict, i$, len$, key;
  dict_text = localStorage.getItem(dictname);
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  for (i$ = 0, len$ = key_list.length; i$ < len$; ++i$) {
    key = key_list[i$];
    if (dict[key] != null) {
      delete dict[key];
    }
  }
  localStorage.setItem(dictname, JSON.stringify(dict));
};
out$.remove_keys_matching_patternfunc_from_localstorage_dict = remove_keys_matching_patternfunc_from_localstorage_dict = function(dictname, patternfunc){
  var dict_text, dict, keys_to_remove, i$, len$, key;
  dict_text = localStorage.getItem(dictname);
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  keys_to_remove = Object.keys(dict).filter(patternfunc);
  for (i$ = 0, len$ = keys_to_remove.length; i$ < len$; ++i$) {
    key = keys_to_remove[i$];
    if (dict[key] != null) {
      delete dict[key];
    }
  }
  localStorage.setItem(dictname, JSON.stringify(dict));
};
out$.add_key_val_to_localstorage_dict = add_key_val_to_localstorage_dict = function(dictname, key, val){
  var dict_text, dict;
  dict_text = localStorage.getItem(dictname);
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  dict[key] = val;
  localStorage.setItem(dictname, JSON.stringify(dict));
};
out$.add_dict_to_localstorage_dict = add_dict_to_localstorage_dict = function(dictname, dict_to_add){
  var dict_text, dict, key, val;
  dict_text = localStorage.getItem(dictname);
  if (dict_text != null) {
    dict = JSON.parse(dict_text);
  } else {
    dict = {};
  }
  for (key in dict_to_add) {
    val = dict_to_add[key];
    dict[key] = val;
  }
  localStorage.setItem(dictname, JSON.stringify(dict));
};
out$.remove_item_from_localstorage_list = remove_item_from_localstorage_list = function(listname, item){
  var list_text, list;
  list_text = localStorage.getItem(listname);
  if (list_text != null) {
    list = JSON.parse(list_text);
  } else {
    list = [];
  }
  list = list.filter(function(it){
    return it !== item;
  });
  return localStorage.setItem(listname, JSON.stringify(list));
};
out$.remove_items_from_localstorage_list = remove_items_from_localstorage_list = function(listname, item_list){
  var list_text, list;
  list_text = localStorage.getItem(listname);
  if (list_text != null) {
    list = JSON.parse(list_text);
  } else {
    list = [];
  }
  list = list.filter(function(it){
    return item_list.indexOf(it) === -1;
  });
  return localStorage.setItem(listname, JSON.stringify(list));
};
out$.remove_items_matching_patternfunc_from_localstorage_list = remove_items_matching_patternfunc_from_localstorage_list = function(listname, patternfunc){
  var list_text, list;
  list_text = localStorage.getItem(listname);
  if (list_text != null) {
    list = JSON.parse(list_text);
  } else {
    list = [];
  }
  list = list.filter(function(it){
    return !patternfunc(it);
  });
  return localStorage.setItem(listname, JSON.stringify(list));
};
out$.add_item_to_localstorage_list = add_item_to_localstorage_list = function(listname, item){
  var list_text, list;
  list_text = localStorage.getItem(listname);
  if (list_text != null) {
    list = JSON.parse(list_text);
  } else {
    list = [];
  }
  if (list.indexOf(item) === -1) {
    list.push(item);
  }
  return localStorage.setItem(listname, JSON.stringify(list));
};
//# sourceMappingURL=collection_utils.ls.map


/***/ }),

/***/ "./src/libs_common/common_libs.ls":
/*!****************************************!*\
  !*** ./src/libs_common/common_libs.ls ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var sleep, once_true, run_only_one_at_a_time, run_every_timeperiod, out$ =  true && exports || this;
out$.sleep = sleep = async function(time){
  return new Promise(function(it){
    return setTimeout(it, time);
  });
};
out$.once_true = once_true = async function(condition, callback){
  var current_result;
  current_result = condition();
  while (!current_result) {
    current_result = condition();
    (await sleep(100));
  }
  if (callback != null) {
    callback();
  }
};
out$.run_only_one_at_a_time = run_only_one_at_a_time = function(func){
  var is_running;
  is_running = false;
  return function(){
    if (is_running) {
      return;
    }
    is_running = true;
    return func(function(){
      return is_running = false;
    });
  };
};
out$.run_every_timeperiod = run_every_timeperiod = function(func, timeperiod){
  var last_run_time;
  last_run_time = Date.now();
  func();
  return setInterval(function(){
    var cur_time;
    cur_time = Date.now();
    if (last_run_time + timeperiod < cur_time) {
      last_run_time = cur_time;
      return func();
    }
  }, 1000);
};
//# sourceMappingURL=common_libs.ls.map


/***/ }),

/***/ "./src/libs_common/css_files_cached.js":
/*!*********************************************!*\
  !*** ./src/libs_common/css_files_cached.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {"bower_components/sweetalert2/dist/sweetalert2.css":"body.swal2-in{overflow-y:hidden}body.swal2-iosfix{position:fixed;left:0;right:0}.swal2-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:fixed;top:0;left:0;bottom:0;right:0;padding:10px;background-color:transparent;z-index:1060}.swal2-container:not(.swal2-in){pointer-events:none}.swal2-container.swal2-fade{-webkit-transition:background-color .1s;transition:background-color .1s}.swal2-container.swal2-in{background-color:rgba(0,0,0,.4)}.swal2-modal{background-color:#fff;font-family:Verdana, Geneva, Tahoma'Helvetica Neue',Helvetica,Arial,sans-serif;border-radius:5px;box-sizing:border-box;text-align:center;margin:auto;overflow-x:hidden;overflow-y:auto;display:none;position:relative}.swal2-modal:focus{outline:0}.swal2-modal.swal2-loading{overflow-y:hidden}.swal2-modal .swal2-title{color:#595959;font-size:30px;text-align:center;font-weight:600;text-transform:none;position:relative;margin:0 0 .4em;padding:0;display:block}.swal2-modal .swal2-spacer{height:10px;color:transparent;border:0}.swal2-modal .swal2-styled{border:0;border-radius:3px;box-shadow:none;color:#fff;cursor:pointer;font-size:17px;font-weight:500;margin:0 5px;padding:10px 32px}.swal2-modal .swal2-styled:not(.swal2-loading)[disabled]{opacity:.4;cursor:no-drop}.swal2-modal .swal2-styled.swal2-loading{box-sizing:border-box;border:4px solid transparent;border-color:transparent;width:40px;height:40px;padding:0;margin:-2px 30px;vertical-align:top;background-color:transparent!important;color:transparent;cursor:default;border-radius:100%;-webkit-animation:rotate-loading 1.5s linear 0s infinite normal;animation:rotate-loading 1.5s linear 0s infinite normal;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-modal :not(.swal2-styled).swal2-loading::after{display:inline-block;content:'';margin-left:5px;vertical-align:-1px;height:6px;width:6px;border:3px solid #999;border-right-color:transparent;border-radius:50%;-webkit-animation:rotate-loading 1.5s linear 0s infinite normal;animation:rotate-loading 1.5s linear 0s infinite normal}.swal2-modal .swal2-image{margin:20px auto;max-width:100%}.swal2-modal .swal2-close{font-size:36px;line-height:36px;font-family:serif;position:absolute;top:5px;right:13px;cursor:pointer;color:#ccc;-webkit-transition:color .1s ease;transition:color .1s ease}.swal2-modal .swal2-close:hover{color:#d55}.swal2-modal>.swal2-checkbox,.swal2-modal>.swal2-file,.swal2-modal>.swal2-input,.swal2-modal>.swal2-radio,.swal2-modal>.swal2-select,.swal2-modal>.swal2-textarea{display:none}.swal2-modal .swal2-content{font-size:18px;text-align:center;font-weight:300;position:relative;float:none;margin:0;padding:0;line-height:normal;color:#545454}.swal2-modal .swal2-checkbox,.swal2-modal .swal2-file,.swal2-modal .swal2-input,.swal2-modal .swal2-radio,.swal2-modal .swal2-select,.swal2-modal .swal2-textarea{margin:20px auto}.swal2-modal .swal2-file,.swal2-modal .swal2-input,.swal2-modal .swal2-textarea{width:100%;box-sizing:border-box;border-radius:3px;border:1px solid #d9d9d9;font-size:18px;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);-webkit-transition:border-color box-shadow .3s;transition:border-color box-shadow .3s}.swal2-modal .swal2-file.swal2-inputerror,.swal2-modal .swal2-input.swal2-inputerror,.swal2-modal .swal2-textarea.swal2-inputerror{border-color:#f06e57}.swal2-modal .swal2-file:focus,.swal2-modal .swal2-input:focus,.swal2-modal .swal2-textarea:focus{outline:0;box-shadow:0 0 3px #c4e6f5;border:1px solid #b4dbed}.swal2-modal .swal2-file:focus::-webkit-input-placeholder,.swal2-modal .swal2-input:focus::-webkit-input-placeholder,.swal2-modal .swal2-textarea:focus::-webkit-input-placeholder{-webkit-transition:opacity .3s .03s ease;transition:opacity .3s .03s ease;opacity:.8}.swal2-modal .swal2-file:focus::-moz-placeholder,.swal2-modal .swal2-input:focus::-moz-placeholder,.swal2-modal .swal2-textarea:focus::-moz-placeholder{-webkit-transition:opacity .3s .03s ease;transition:opacity .3s .03s ease;opacity:.8}.swal2-modal .swal2-file:focus:-ms-input-placeholder,.swal2-modal .swal2-input:focus:-ms-input-placeholder,.swal2-modal .swal2-textarea:focus:-ms-input-placeholder{-webkit-transition:opacity .3s .03s ease;transition:opacity .3s .03s ease;opacity:.8}.swal2-modal .swal2-file:focus::placeholder,.swal2-modal .swal2-input:focus::placeholder,.swal2-modal .swal2-textarea:focus::placeholder{-webkit-transition:opacity .3s .03s ease;transition:opacity .3s .03s ease;opacity:.8}.swal2-modal .swal2-file::-webkit-input-placeholder,.swal2-modal .swal2-input::-webkit-input-placeholder,.swal2-modal .swal2-textarea::-webkit-input-placeholder{color:#e6e6e6}.swal2-modal .swal2-file::-moz-placeholder,.swal2-modal .swal2-input::-moz-placeholder,.swal2-modal .swal2-textarea::-moz-placeholder{color:#e6e6e6}.swal2-modal .swal2-file:-ms-input-placeholder,.swal2-modal .swal2-input:-ms-input-placeholder,.swal2-modal .swal2-textarea:-ms-input-placeholder{color:#e6e6e6}.swal2-modal .swal2-file::placeholder,.swal2-modal .swal2-input::placeholder,.swal2-modal .swal2-textarea::placeholder{color:#e6e6e6}.swal2-modal .swal2-range input{float:left;width:80%}.swal2-modal .swal2-range output{float:right;width:20%;font-size:20px;font-weight:600;text-align:center}.swal2-modal .swal2-range input,.swal2-modal .swal2-range output{height:43px;line-height:43px;vertical-align:middle;margin:20px auto;padding:0}.swal2-modal .swal2-input{height:43px;padding:0 12px}.swal2-modal .swal2-input[type=number]{max-width:150px}.swal2-modal .swal2-file{font-size:20px}.swal2-modal .swal2-textarea{height:108px;padding:12px}.swal2-modal .swal2-select{color:#545454;font-size:inherit;padding:5px 10px;min-width:40%;max-width:100%}.swal2-modal .swal2-radio{border:0}.swal2-modal .swal2-radio label:not(:first-child){margin-left:20px}.swal2-modal .swal2-radio input,.swal2-modal .swal2-radio span{vertical-align:middle}.swal2-modal .swal2-radio input{margin:0 3px 0 0}.swal2-modal .swal2-checkbox{color:#545454}.swal2-modal .swal2-checkbox input,.swal2-modal .swal2-checkbox span{vertical-align:middle}.swal2-modal .swal2-validationerror{background-color:#f0f0f0;margin:0 -20px;overflow:hidden;padding:10px;color:gray;font-size:16px;font-weight:300;display:none}.swal2-modal .swal2-validationerror::before{content:'!';display:inline-block;width:24px;height:24px;border-radius:50%;background-color:#ea7d7d;color:#fff;line-height:24px;text-align:center;margin-right:10px}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}.swal2-icon{width:80px;height:80px;border:4px solid transparent;border-radius:50%;margin:20px auto 30px;padding:0;position:relative;box-sizing:content-box;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon.swal2-error{border-color:#f27474}.swal2-icon.swal2-error .x-mark{position:relative;display:block}.swal2-icon.swal2-error .line{position:absolute;height:5px;width:47px;background-color:#f27474;display:block;top:37px;border-radius:2px}.swal2-icon.swal2-error .line.left{-webkit-transform:rotate(45deg);transform:rotate(45deg);left:17px}.swal2-icon.swal2-error .line.right{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);right:16px}.swal2-icon.swal2-warning{font-family:Verdana, Geneva, Tahoma'Helvetica Neue',Helvetica,Arial,sans-serif;color:#f8bb86;border-color:#facea8;font-size:60px;line-height:80px;text-align:center}.swal2-icon.swal2-info{font-family:Verdana, Geneva, Tahomasans-serif;color:#3fc3ee;border-color:#9de0f6;font-size:60px;line-height:80px;text-align:center}.swal2-icon.swal2-question{font-family:Verdana, Geneva, Tahoma'Helvetica Neue',Helvetica,Arial,sans-serif;color:#87adbd;border-color:#c9dae1;font-size:60px;line-height:80px;text-align:center}.swal2-icon.swal2-success{border-color:#a5dc86}.swal2-icon.swal2-success::after,.swal2-icon.swal2-success::before{content:'';border-radius:50%;position:absolute;width:60px;height:120px;background:#fff;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal2-icon.swal2-success::before{border-radius:120px 0 0 120px;top:-7px;left:-33px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:60px 60px;transform-origin:60px 60px}.swal2-icon.swal2-success::after{border-radius:0 120px 120px 0;top:-11px;left:30px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:0 60px;transform-origin:0 60px}.swal2-icon.swal2-success .placeholder{width:80px;height:80px;border:4px solid rgba(165,220,134,.2);border-radius:50%;box-sizing:content-box;position:absolute;left:-4px;top:-4px;z-index:2}.swal2-icon.swal2-success .fix{width:7px;height:90px;background-color:#fff;position:absolute;left:28px;top:8px;z-index:1;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal2-icon.swal2-success .line{height:5px;background-color:#a5dc86;display:block;border-radius:2px;position:absolute;z-index:2}.swal2-icon.swal2-success .line.tip{width:25px;left:14px;top:46px;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal2-icon.swal2-success .line.long{width:47px;right:8px;top:38px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal2-progresssteps{font-weight:600;margin:0 0 20px;padding:0}.swal2-progresssteps li{display:inline-block;position:relative}.swal2-progresssteps .swal2-progresscircle{background:#3085d6;border-radius:2em;color:#fff;height:2em;line-height:2em;text-align:center;width:2em;z-index:20}.swal2-progresssteps .swal2-progresscircle:first-child{margin-left:0}.swal2-progresssteps .swal2-progresscircle:last-child{margin-right:0}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep{background:#3085d6}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep~.swal2-progresscircle{background:#add8e6}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep~.swal2-progressline{background:#add8e6}.swal2-progresssteps .swal2-progressline{background:#3085d6;height:.4em;margin:0 -1px;z-index:10}[class^=swal2]{-webkit-tap-highlight-color:transparent}@-webkit-keyframes showSweetAlert{0%{-webkit-transform:scale(.7);transform:scale(.7)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes showSweetAlert{0%{-webkit-transform:scale(.7);transform:scale(.7)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}100%{-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes hideSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{-webkit-transform:scale(.5);transform:scale(.5);opacity:0}}@keyframes hideSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{-webkit-transform:scale(.5);transform:scale(.5);opacity:0}}.swal2-show{-webkit-animation:showSweetAlert .3s;animation:showSweetAlert .3s}.swal2-show.swal2-noanimation{-webkit-animation:none;animation:none}.swal2-hide{-webkit-animation:hideSweetAlert .15s forwards;animation:hideSweetAlert .15s forwards}.swal2-hide.swal2-noanimation{-webkit-animation:none;animation:none}@-webkit-keyframes animate-success-tip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}100%{width:25px;left:14px;top:45px}}@keyframes animate-success-tip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}100%{width:25px;left:14px;top:45px}}@-webkit-keyframes animate-success-long{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}100%{width:47px;right:8px;top:38px}}@keyframes animate-success-long{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}100%{width:47px;right:8px;top:38px}}@-webkit-keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}100%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}100%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}.animate-success-tip{-webkit-animation:animate-success-tip .75s;animation:animate-success-tip .75s}.animate-success-long{-webkit-animation:animate-success-long .75s;animation:animate-success-long .75s}.swal2-success.animate::after{-webkit-animation:rotatePlaceholder 4.25s ease-in;animation:rotatePlaceholder 4.25s ease-in}@-webkit-keyframes animate-error-icon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}100%{-webkit-transform:rotateX(0);transform:rotateX(0);opacity:1}}@keyframes animate-error-icon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}100%{-webkit-transform:rotateX(0);transform:rotateX(0);opacity:1}}.animate-error-icon{-webkit-animation:animate-error-icon .5s;animation:animate-error-icon .5s}@-webkit-keyframes animate-x-mark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}100%{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}@keyframes animate-x-mark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}100%{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}.animate-x-mark{-webkit-animation:animate-x-mark .5s;animation:animate-x-mark .5s}@-webkit-keyframes pulse-warning{0%{border-color:#f8d486}100%{border-color:#f8bb86}}@keyframes pulse-warning{0%{border-color:#f8d486}100%{border-color:#f8bb86}}.pulse-warning{-webkit-animation:pulse-warning .75s infinite alternate;animation:pulse-warning .75s infinite alternate}@-webkit-keyframes rotate-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}","modules_custom/jquery.terminal/css/jquery.terminal.min.css":"/*!\n *       __ _____                     ________                              __\n *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /\n *  __ / // // // // // _  // _// // / / // _  // _//     // //  \\/ // _ \\/ /\n * /  / // // // // // ___// / / // / / // ___// / / / / // // /\\  // // / /__\n * \\___//____ \\\\___//____//_/ _\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\__\\_\\___/\n *           \\/              /____/                              version 0.10.12\n * http://terminal.jcubic.pl\n *\n * This file is part of jQuery Terminal.\n *\n * Copyright (c) 2011-2016 Jakub Jankiewicz <http://jcubic.pl>\n * Released under the MIT license\n *\n * Date: Thu, 16 Jun 2016 09:24:01 +0000\n */.cmd .format,.cmd .prompt,.cmd .prompt div,.terminal .terminal-output .format,.terminal .terminal-output div div{display:inline-block}.cmd,.terminal h1,.terminal h2,.terminal h3,.terminal h4,.terminal h5,.terminal h6,.terminal pre{margin:0}.terminal h1,.terminal h2,.terminal h3,.terminal h4,.terminal h5,.terminal h6{line-height:1.2em}.cmd .clipboard{position:absolute;height:16px;left:-6px;width:5px;background:0 0;border:0;color:transparent;outline:0;padding:0;resize:none;z-index:0;overflow:hidden}.terminal .error{color:red}.terminal{padding:10px;position:relative;overflow:auto}.cmd{padding:0;height:1.3em;position:relative}.cmd .cursor.blink,.cmd .inverted,.terminal .inverted{background-color:#aaa;color:#000}.cmd .cursor.blink{-webkit-animation:terminal-blink 1s infinite steps(1,start);-moz-animation:terminal-blink 1s infinite steps(1,start);-ms-animation:terminal-blink 1s infinite steps(1,start);animation:terminal-blink 1s infinite steps(1,start)}@-webkit-keyframes terminal-blink{0%,100%{background-color:#000;color:#aaa}50%{background-color:#bbb;color:#000}}@-ms-keyframes terminal-blink{0%,100%{background-color:#000;color:#aaa}50%{background-color:#bbb;color:#000}}@-moz-keyframes terminal-blink{0%,100%{background-color:#000;color:#aaa}50%{background-color:#bbb;color:#000}}@keyframes terminal-blink{0%,100%{background-color:#000;color:#aaa}50%{background-color:#bbb;color:#000}}.cmd .prompt,.terminal .terminal-output div div{display:block;line-height:14px;height:auto}.cmd .prompt{float:left}.cmd,.terminal{font-family:monospace;color:#aaa;background-color:#000;font-size:12px;line-height:14px}.terminal-output>div{min-height:14px}.terminal .terminal-output div span{display:inline-block}.cmd span{float:left}.cmd div,.cmd span,.terminal h1,.terminal h2,.terminal h3,.terminal h4,.terminal h5,.terminal h6,.terminal pre,.terminal td,.terminal-output a,.terminal-output span{-webkit-touch-callout:initial;-webkit-user-select:initial;-khtml-user-select:initial;-moz-user-select:initial;-ms-user-select:initial;user-select:initial}.terminal,.terminal-output,.terminal-output div{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@-moz-document url-prefix(){.terminal,.terminal-output,.terminal-output div{-webkit-touch-callout:initial;-webkit-user-select:initial;-khtml-user-select:initial;-moz-user-select:initial;-ms-user-select:initial;user-select:initial}}.terminal table{border-collapse:collapse}.terminal td{border:1px solid #aaa}.cmd .prompt span::-moz-selection,.cmd div::-moz-selection,.cmd>span::-moz-selection,.terminal .terminal-output div div a::-moz-selection,.terminal .terminal-output div div::-moz-selection,.terminal .terminal-output div span::-moz-selection,.terminal h1::-moz-selection,.terminal h2::-moz-selection,.terminal h3::-moz-selection,.terminal h4::-moz-selection,.terminal h5::-moz-selection,.terminal h6::-moz-selection,.terminal pre::-moz-selection,.terminal td::-moz-selection{background-color:#aaa;color:#000}.cmd .prompt span::selection,.cmd div::selection,.cmd>span::selection,.terminal .terminal-output div div a::selection,.terminal .terminal-output div div::selection,.terminal .terminal-output div span::selection,.terminal h1::selection,.terminal h2::selection,.terminal h3::selection,.terminal h4::selection,.terminal h5::selection,.terminal h6::selection,.terminal pre::selection,.terminal td::selection{background-color:#aaa;color:#000}.terminal .terminal-output div.error,.terminal .terminal-output div.error div{color:red}.tilda{position:fixed;top:0;left:0;width:100%;z-index:1100}.clear{clear:both}.terminal a{color:#0f60ff}.terminal a:hover{color:red}"};

/***/ }),

/***/ "./src/libs_common/css_packages.ls":
/*!*****************************************!*\
  !*** ./src/libs_common/css_packages.ls ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  'swal': 'bower_components/sweetalert2/dist/sweetalert2.css',
  'swal2': 'bower_components/sweetalert2/dist/sweetalert2.css',
  'sweetalert': 'bower_components/sweetalert2/dist/sweetalert2.css',
  'sweetalert2': 'bower_components/sweetalert2/dist/sweetalert2.css',
  'jquery.terminal': 'modules_custom/jquery.terminal/css/jquery.terminal.min.css',
  'jquery.pagepiling': 'modules_custom/jquery.pagepiling/jquery.pagepiling.css'
};
//# sourceMappingURL=css_packages.ls.map


/***/ }),

/***/ "./src/libs_common/domain_utils.ls":
/*!*****************************************!*\
  !*** ./src/libs_common/domain_utils.ls ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, gexport, gexport_module, url_to_domain, domain_to_url, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.url_to_domain = url_to_domain = function(url){
  var domain;
  if (url.indexOf("://") > -1) {
    domain = url.split('/')[2];
  } else {
    domain = url.split('/')[0];
  }
  return domain;
};
out$.domain_to_url = domain_to_url = function(domain){
  return "http://" + url_to_domain(domain) + '/';
};
gexport_module('domain_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=domain_utils.ls.map


/***/ }),

/***/ "./src/libs_common/function_signatures.ls":
/*!************************************************!*\
  !*** ./src/libs_common/function_signatures.ls ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var lib_name_to_func_names_and_signatures, func_name_to_signature, lib_name, funcs, func_name, func_signature, list_functions_in_lib, list_libs, get_function_signature, out$ =  true && exports || this;
lib_name_to_func_names_and_signatures = {
  log_utils: {
    addtolog: ['name', 'data'],
    getlog: 'name',
    clearlog: 'name',
    add_log_habitlab_disabled: ['data'],
    add_log_interventions: ['data'],
    log_impression_internal: ['name', 'data'],
    log_intervention_suggested_internal: ['name', 'data'],
    log_intervention_suggestion_action_internal: ['name', 'data'],
    log_disable_internal: ['name', 'data'],
    log_action_internal: ['name', 'data'],
    log_upvote_internal: ['name', 'data'],
    log_downvote_internal: ['name', 'data'],
    log_feedback_internal: ['name', 'data']
  },
  db_utils: {
    addtolist: ['name', 'data'],
    getlist: 'name',
    clearlist: 'name',
    getvar: 'key',
    setvar: ['key', 'val'],
    addtovar: ['key', 'val'],
    getkey_dictdict: ['name', 'key', 'key2'],
    getdict_for_key_dictdict: ['name', 'key'],
    getdict_for_key2_dictdict: ['name', 'key2']
  },
  intervention_first_impression_utils_backend: {
    show_firstimpression_message_for_intervention: 'intervention_name'
  },
  intervention_utils: {
    set_intervention_enabled: 'name',
    set_intervention_disabled: 'name',
    set_intervention_disabled_permanently: 'name',
    get_intervention_info: 'intervention_name',
    intervention_first_seen_power_enabledisable: ['intervention', 'is_enabled', 'url'],
    get_enabled_interventions: [],
    record_intensity_level_for_intervention: ['intervention_name', 'generic_name', 'intensity'],
    choose_intervention_for_each_difficulty_level_and_goal: ['goal_name'],
    set_temporary_difficulty: 'difficulty',
    set_asknext_time: 'asknext_time'
  },
  tab_utils: {
    close_selected_tab: [],
    open_url_in_new_tab: 'url',
    get_selected_tab_id: [],
    close_tab_with_id: 'tab_id'
  },
  history_utils: {
    get_pages_visited_today: [],
    get_pages_visited_all_time: [],
    get_work_pages_visited_today: [],
    get_productivity_classifications: []
  },
  goal_utils: {
    get_goals: [],
    get_goal_target: ['goal_name'],
    set_goal_target: ['goal_name', 'target_value'],
    get_all_goal_targets: [],
    list_goal_info_for_enabled_goals: [],
    get_random_positive_goal: [],
    get_random_uncompleted_positive_goal: [],
    get_positive_enabled_goals: [],
    get_positive_enabled_uncompleted_goals: [],
    get_goal_info: ['goal_name'],
    get_goal_statement: ['goal_info'],
    accept_domain_as_goal_and_record: ['domain'],
    reject_domain_as_goal_and_record: ['domain']
  },
  goal_progress: {
    get_progress_on_enabled_goals_this_week: [],
    get_whether_goal_achieved_today: []
  },
  gamification_utils: {
    get_num_times_intervention_used: ['intervention_name'],
    get_intervention_level: ['intervention_name'],
    get_time_saved_total: [],
    get_time_saved_total_with_intervention: ['intervention_name'],
    baseline_time_per_session_for_domain: ['domain'],
    record_seconds_saved_and_get_rewards: ['seconds', 'intervention_name', 'domain']
  },
  disable_habitlab_utils: {
    disable_habitlab: [],
    enable_habitlab: [],
    is_habitlab_enabled: []
  },
  session_utils: {
    is_on_same_domain_and_same_tab: 'tab_id',
    is_on_same_domain: 'tab_id'
  },
  screenshot_utils: {
    get_screenshot_as_base64: [],
    get_data_for_feedback: []
  },
  fetch_page_utils: {
    fetch_page_text: 'url'
  },
  ajax_utils: {
    post_json: ['url', 'data']
  },
  cacheget_utils: {
    localget: 'url',
    localget_json: 'url',
    localget_base64: 'url',
    remoteget: 'url',
    remoteget_json: 'url',
    remoteget_base64: 'url',
    systemjsget: 'url'
  },
  favicon_utils: {
    get_favicon_data_for_domain: 'domain'
  },
  debug_console_utils: {
    open_debug_page_for_tab_id: 'tab_id'
  },
  notification_utils_backend: {
    make_notification_backend: ['info', 'tab_id'],
    close_notification_backend: 'notification_id'
  },
  persistent_storage_utils: {
    set_var: ['key', 'val'],
    get_var: 'key'
  },
  localization_utils_backend: {
    record_unlocalized_string: 'text',
    record_localized_string: 'text'
  },
  duolingo_utils: {
    get_duolingo_username: [],
    get_duolingo_info: [],
    get_duolingo_info_for_user: 'username',
    get_duolingo_is_logged_in: [],
    wait_until_user_is_logged_in: 'timeout'
  },
  streak_utils: {
    get_streak: 'goal_info'
  },
  intervention_vars_backend: {
    getvar_intervention_synced_backend: ['intervention_name', 'key'],
    setvar_intervention_synced_backend: ['intervention_name', 'key', 'val'],
    getvar_intervention_unsynced_backend: ['intervention_name', 'key'],
    setvar_intervention_unsynced_backend: ['intervention_name', 'key', 'val']
  },
  goal_vars_backend: {
    getvar_goal_synced_backend: ['goal_name', 'key'],
    setvar_goal_synced_backend: ['goal_name', 'key', 'val'],
    getvar_goal_unsynced_backend: ['goal_name', 'key'],
    setvar_goal_unsynced_backend: ['goal_name', 'key', 'val']
  },
  intervention_feedback_utils: {
    upvote_intervention: 'intervention_name',
    downvote_intervention: 'intervention_name',
    add_feedback_for_intervention: ['intervention_name', 'feedback_data'],
    get_num_upvotes_for_intervention: 'intervention_name',
    get_num_downvotes_for_intervention: 'intervention_name',
    get_feedback_for_intervention: 'intervention_name'
  },
  intervention_session_vars_backend: {
    get_intervention_session_var_backend: ['intervention_name', 'session_id', 'key'],
    set_intervention_session_var_backend: ['intervention_name', 'session_id', 'key', 'val']
  }
};
func_name_to_signature = {};
for (lib_name in lib_name_to_func_names_and_signatures) {
  funcs = lib_name_to_func_names_and_signatures[lib_name];
  for (func_name in funcs) {
    func_signature = funcs[func_name];
    func_name_to_signature[func_name] = func_signature;
  }
}
out$.list_functions_in_lib = list_functions_in_lib = function(lib_name){
  return Object.keys(lib_name_to_func_names_and_signatures[lib_name]);
};
out$.list_libs = list_libs = function(){
  return Object.keys(lib_name_to_func_names_and_signatures);
};
out$.get_function_signature = get_function_signature = function(func_name){
  return func_name_to_signature[func_name];
};
//# sourceMappingURL=function_signatures.ls.map


/***/ }),

/***/ "./src/libs_common/generate_random_id.ls":
/*!***********************************************!*\
  !*** ./src/libs_common/generate_random_id.ls ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var generate_random_id;
generate_random_id = function(){
  var output, i$, i;
  output = 'TRI-';
  for (i$ = 0; i$ < 4; ++i$) {
    i = i$;
    output += '0123456789'[Math.floor(Math.random() * 10)];
  }
  output += '-';
  for (i$ = 0; i$ < 4; ++i$) {
    i = i$;
    output += 'abcdefghijklmnopqrstuvwxyz'[Math.floor(Math.random() * 26)];
  }
  return output;
};
module.exports = {
  generate_random_id: generate_random_id
};
//# sourceMappingURL=generate_random_id.ls.map


/***/ }),

/***/ "./src/libs_common/gexport.ls":
/*!************************************!*\
  !*** ./src/libs_common/gexport.ls ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var gexport, gexport_module, out$ =  true && exports || this;
out$.gexport = gexport = function(vardict){
  var k, v;
  if (window.global_exports == null) {
    console.log('calling gexport but global_exports is not defined');
    return;
  }
  for (k in vardict) {
    v = vardict[k];
    window.global_exports[k] = v;
  }
};
out$.gexport_module = gexport_module = function(module_name, eval_func){
  if (window.global_exports == null) {
    return;
  }
  window.global_exports['eval_' + module_name] = eval_func;
  if (window.global_exports.gexport_eval_funcs == null) {
    window.global_exports.gexport_eval_funcs = {};
  }
  return window.global_exports.gexport_eval_funcs[module_name] = eval_func;
};
//# sourceMappingURL=gexport.ls.map


/***/ }),

/***/ "./src/libs_common/global_exports_post.js":
/*!************************************************!*\
  !*** ./src/libs_common/global_exports_post.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function gexport_item(pagename, str) {
  const eval_page = window[`eval_${pagename}`]
  if (!eval_page) {
    console.log(`gexport_item for ${str} failed as eval_${pagename} is not defined`)
    return
  }
  eval_page(`gexport({'${str}': ${str}})`)
  window[str] = window.global_exports[str]
}

function gexport_finish_exporting_modules() {
  for (let k of Object.keys(window.global_exports)) {
    window[k] = window.global_exports[k]
  }
  if (!window.global_exports.gexport_eval_funcs) {
    return
  }
  for (let pagename of Object.keys(window.global_exports.gexport_eval_funcs)) {
    const eval_page = window.global_exports.gexport_eval_funcs[pagename]
    const exports_page = eval_page('module.exports')
    window[`exports_${pagename}`] = exports_page
    for (let k of Object.keys(exports_page)) {
      window[k] = exports_page[k]
    }
    window[`gexport_item_${pagename}`] = (str) => gexport_item(pagename, str)
  }
}

window.gexport_all = gexport_finish_exporting_modules


/***/ }),

/***/ "./src/libs_common/intervention_info.ls":
/*!**********************************************!*\
  !*** ./src/libs_common/intervention_info.ls ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var intervention_info_cached, set_intervention, get_goal_name, get_intervention, goal_info_cached, set_goal_info, get_goal_info, tab_id_cached, set_tab_id, get_tab_id, is_new_session_cached, set_is_new_session, get_is_new_session, is_preview_mode_cached, set_is_preview_mode, get_is_preview_mode, is_suggestion_mode_cached, set_is_suggestion_mode, get_is_suggestion_mode, is_suggestion_mode_optout_cached, set_is_suggestion_mode_optout, get_is_suggestion_mode_optout, is_previously_seen_cached, set_is_previously_seen, get_is_previously_seen, session_id_cached, set_session_id, get_session_id, out$ =  true && exports || this;
intervention_info_cached = null;
out$.set_intervention = set_intervention = function(new_intervention_info){
  return intervention_info_cached = new_intervention_info;
};
/**
 * Gets the name of the current goal
 * @return {string} The current goal name
 */
out$.get_goal_name = get_goal_name = function(){
  return get_intervention().goals[0];
};
out$.get_intervention = get_intervention = function(){
  if (intervention_info_cached != null) {
    return intervention_info_cached;
  }
  if (typeof intervention != 'undefined' && intervention !== null) {
    return intervention;
  }
};
goal_info_cached = null;
out$.set_goal_info = set_goal_info = function(new_goal_info){
  return goal_info_cached = new_goal_info;
};
out$.get_goal_info = get_goal_info = function(){
  if (goal_info_cached != null) {
    return goal_info_cached;
  }
  if (typeof goal_info != 'undefined' && goal_info !== null) {
    return goal_info;
  }
};
tab_id_cached = null;
out$.set_tab_id = set_tab_id = function(new_tab_id){
  return tab_id_cached = new_tab_id;
};
out$.get_tab_id = get_tab_id = function(){
  if (tab_id_cached != null) {
    return tab_id_cached;
  }
  if (typeof tab_id != 'undefined' && tab_id !== null) {
    return tab_id;
  }
};
is_new_session_cached = null;
out$.set_is_new_session = set_is_new_session = function(new_is_new_session){
  return is_new_session_cached = new_is_new_session;
};
out$.get_is_new_session = get_is_new_session = function(){
  if (is_new_session_cached != null) {
    return is_new_session_cached;
  }
  if (typeof is_new_session != 'undefined' && is_new_session !== null) {
    return is_new_session;
  }
  return false;
};
is_preview_mode_cached = null;
out$.set_is_preview_mode = set_is_preview_mode = function(new_is_preview_mode){
  return is_preview_mode_cached = new_is_preview_mode;
};
out$.get_is_preview_mode = get_is_preview_mode = function(){
  if (is_preview_mode_cached != null) {
    return is_preview_mode_cached;
  }
  if (typeof is_preview_mode != 'undefined' && is_preview_mode !== null) {
    return is_preview_mode;
  }
  return false;
};
is_suggestion_mode_cached = null;
out$.set_is_suggestion_mode = set_is_suggestion_mode = function(new_is_suggestion_mode){
  return is_suggestion_mode_cached = new_is_suggestion_mode;
};
out$.get_is_suggestion_mode = get_is_suggestion_mode = function(){
  if (is_suggestion_mode_cached != null) {
    return is_suggestion_mode_cached;
  }
  if (typeof is_suggestion_mode != 'undefined' && is_suggestion_mode !== null) {
    return is_suggestion_mode;
  }
  return false;
};
is_suggestion_mode_optout_cached = null;
out$.set_is_suggestion_mode_optout = set_is_suggestion_mode_optout = function(new_is_suggestion_mode_optout){
  return is_suggestion_mode_optout_cached = new_is_suggestion_mode_optout;
};
out$.get_is_suggestion_mode_optout = get_is_suggestion_mode_optout = function(){
  if (is_suggestion_mode_optout_cached != null) {
    return is_suggestion_mode_optout_cached;
  }
  if (typeof is_suggestion_mode_optout != 'undefined' && is_suggestion_mode_optout !== null) {
    return is_suggestion_mode_optout;
  }
  return false;
};
is_previously_seen_cached = null;
out$.set_is_previously_seen = set_is_previously_seen = function(new_is_previously_seen){
  return is_previously_seen_cached = new_is_previously_seen;
};
out$.get_is_previously_seen = get_is_previously_seen = function(){
  if (is_previously_seen_cached != null) {
    return is_previously_seen_cached;
  }
  if (typeof is_previously_seen != 'undefined' && is_previously_seen !== null) {
    return is_previously_seen;
  }
  return false;
};
session_id_cached = null;
out$.set_session_id = set_session_id = function(new_session_id){
  return session_id_cached = new_session_id;
};
out$.get_session_id = get_session_id = function(){
  if (session_id_cached != null) {
    return session_id_cached;
  }
  if (typeof session_id != 'undefined' && session_id !== null) {
    return session_id;
  }
};
//# sourceMappingURL=intervention_info.ls.map


/***/ }),

/***/ "./src/libs_common/localstorage_utils.ls":
/*!***********************************************!*\
  !*** ./src/libs_common/localstorage_utils.ls ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var localstorage_getbool, localstorage_setbool, localstorage_getint, localstorage_setint, localstorage_getfloat, localstorage_setfloat, localstorage_getjson, localstorage_setjson, localstorage_getstring, localstorage_setstring, out$ =  true && exports || this;
out$.localstorage_getbool = localstorage_getbool = function(key){
  return localStorage.getItem(key) === 'true';
};
out$.localstorage_setbool = localstorage_setbool = function(key, val){
  if (val) {
    localStorage.setItem(key, 'true');
  } else {
    localStorage.setItem(key, 'false');
  }
};
out$.localstorage_getint = localstorage_getint = function(key){
  var val;
  val = localStorage.getItem(key);
  if (val != null) {
    return parseInt(val);
  }
  return null;
};
out$.localstorage_setint = localstorage_setint = function(key, val){
  localStorage.setItem(key, val);
};
out$.localstorage_getfloat = localstorage_getfloat = function(key){
  var val;
  val = localStorage.getItem(key);
  if (val != null) {
    return parseFloat(val);
  }
  return null;
};
out$.localstorage_setfloat = localstorage_setfloat = function(key, val){
  localStorage.setItem(key, val);
};
out$.localstorage_getjson = localstorage_getjson = function(key){
  var val;
  val = localStorage.getItem(key);
  if (val != null) {
    return JSON.parse(val);
  }
  return null;
};
out$.localstorage_setjson = localstorage_setjson = function(key, val){
  localStorage.setItem(key, JSON.stringify(val));
};
out$.localstorage_getstring = localstorage_getstring = function(key){
  return localStorage.getItem(key);
};
out$.localstorage_setstring = localstorage_setstring = function(key, val){
  return localStorage.setItem(key, val);
};
//# sourceMappingURL=localstorage_utils.ls.map


/***/ }),

/***/ "./src/libs_common/math_utils.js":
/*!***************************************!*\
  !*** ./src/libs_common/math_utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function median(values) {
  if ( !Array.isArray(values) ) {
    throw new TypeError('You need to pass an Array not ' + typeof values )
  }
  if ( values.length == 1 ) {
    return values[0]
  }
  values.sort( function sortValues (a, b) {
    return a - b
  })
  var half = Math.floor(values.length / 2)
  if ( values.length % 2 )
    return values[half]
  else
    return ( values[half - 1] + values[half] ) / 2.0
}

module.exports.median = median;


/***/ }),

/***/ "./src/libs_common/measurement_utils.ls":
/*!**********************************************!*\
  !*** ./src/libs_common/measurement_utils.ls ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ref$, getkey_dictdict, setkey_dictdict, addtokey_dictdict, get_days_since_epoch, gexport, gexport_module, set_measurement, set_measurement_for_days_before_today, increment_measurement, add_to_measurement, add_to_measurement_days_before_today, get_measurement, get_measurement_for_days_before_today, out$ =  true && exports || this;
ref$ = __webpack_require__(/*! libs_common/db_utils */ "./src/libs_backend/db_utils.ls"), getkey_dictdict = ref$.getkey_dictdict, setkey_dictdict = ref$.setkey_dictdict, addtokey_dictdict = ref$.addtokey_dictdict;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.set_measurement = set_measurement = async function(measurement_name, new_value){
  return (await set_measurement_for_days_before_today(measurement_name, 0, new_value));
};
out$.set_measurement_for_days_before_today = set_measurement_for_days_before_today = async function(measurement_name, days_ago, new_value){
  var current_day;
  current_day = get_days_since_epoch();
  return (await setkey_dictdict('custom_measurements_each_day', measurement_name, current_day - days_ago, new_value));
};
out$.increment_measurement = increment_measurement = async function(measurement_name){
  return (await add_to_measurement(measurement_name, 1));
};
out$.add_to_measurement = add_to_measurement = async function(measurement_name, amount_to_add){
  var current_day;
  current_day = get_days_since_epoch();
  return (await addtokey_dictdict('custom_measurements_each_day', measurement_name, current_day, amount_to_add));
};
out$.add_to_measurement_days_before_today = add_to_measurement_days_before_today = async function(measurement_name, days_ago, amount_to_add){
  var current_day;
  current_day = get_days_since_epoch();
  return (await addtokey_dictdict('custom_measurements_each_day', measurement_name, current_day - days_ago, amount_to_add));
};
out$.get_measurement = get_measurement = async function(measurement_name){
  return (await get_measurement_for_days_before_today(measurement_name, 0));
};
out$.get_measurement_for_days_before_today = get_measurement_for_days_before_today = async function(measurement_name, days_ago){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('custom_measurements_each_day', measurement_name, current_day - days_ago));
  return result != null ? result : 0;
};
gexport_module('measurement_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=measurement_utils.ls.map


/***/ }),

/***/ "./src/libs_common/memoize.ls":
/*!************************************!*\
  !*** ./src/libs_common/memoize.ls ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeSingleAsync, memoize, out$ =  true && exports || this;
out$.memoizeSingleAsync = memoizeSingleAsync = function(func){
  var cached_promise;
  cached_promise = null;
  return function(){
    var result;
    if (cached_promise != null) {
      return cached_promise;
    }
    result = func();
    cached_promise = result;
    return result;
  };
};
out$.memoize = memoize = function(func){
  var memo, slice;
  memo = {};
  slice = Array.prototype.slice;
  return function(){
    var args;
    args = slice.call(arguments);
    if (memo[args] != null) {
      return memo[args];
    } else {
      return memo[args] = func.apply(this, args);
    }
  };
};
//# sourceMappingURL=memoize.ls.map


/***/ }),

/***/ "./src/libs_common/promise_utils.js":
/*!******************************************!*\
  !*** ./src/libs_common/promise_utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

async function promise_all_object(object) {
  let keys = Object.keys(object)
  let value_promises = []
  for (let key of keys) {
    value_promises.push(object[key])
  }
  let values = await Promise.all(value_promises)
  let output = {}
  for (let i = 0; i < keys.length; ++i) {
    let key = keys[i]
    let value = values[i]
    output[key] = value
  }
  return output
}

module.exports = {
  promise_all_object
}


/***/ }),

/***/ "./src/libs_common/time_spent_utils.ls":
/*!*********************************************!*\
  !*** ./src/libs_common/time_spent_utils.ls ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var moment, prelude, ref$, getkey_dictdict, getdict_for_key_dictdict, getdict_for_key2_dictdict, getCollection, setkey_dict, getkey_dict, url_to_domain, get_days_since_epoch, get_session_id, gexport, gexport_module, get_seconds_spent_on_all_domains_today, get_seconds_spent_on_all_domains_days_before_today, get_seconds_spent_on_domain_all_days, get_seconds_spent_on_domain_days_before_today, get_seconds_spent_on_domain_today, get_minutes_spent_on_domain_today, get_seconds_spent_on_current_domain_today, get_visits_to_domain_today, get_visits_to_domain_days_before_today, get_visits_to_current_domain_today, get_new_session_id_for_domain, get_seconds_spent_on_current_domain_in_session, get_seconds_spent_on_domain_in_session, get_seconds_spent_on_current_domain_in_current_session, out$ =  true && exports || this;
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
prelude = __webpack_require__(/*! prelude-ls */ "./node_modules/prelude-ls/lib/index.js");
ref$ = __webpack_require__(/*! libs_common/db_utils */ "./src/libs_backend/db_utils.ls"), getkey_dictdict = ref$.getkey_dictdict, getdict_for_key_dictdict = ref$.getdict_for_key_dictdict, getdict_for_key2_dictdict = ref$.getdict_for_key2_dictdict, getCollection = ref$.getCollection, setkey_dict = ref$.setkey_dict, getkey_dict = ref$.getkey_dict;
url_to_domain = __webpack_require__(/*! libs_common/domain_utils */ "./src/libs_common/domain_utils.ls").url_to_domain;
get_days_since_epoch = __webpack_require__(/*! libs_common/time_utils */ "./src/libs_common/time_utils.ls").get_days_since_epoch;
get_session_id = __webpack_require__(/*! libs_common/intervention_info */ "./src/libs_common/intervention_info.ls").get_session_id;
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.get_seconds_spent_on_all_domains_today = get_seconds_spent_on_all_domains_today = async function(){
  return (await getdict_for_key2_dictdict('seconds_on_domain_per_day', get_days_since_epoch()));
};
out$.get_seconds_spent_on_all_domains_days_before_today = get_seconds_spent_on_all_domains_days_before_today = async function(days_ago){
  return (await getdict_for_key2_dictdict('seconds_on_domain_per_day', get_days_since_epoch() - days_ago));
};
out$.get_seconds_spent_on_domain_all_days = get_seconds_spent_on_domain_all_days = async function(domain){
  var results, today_day_num, output, k, v;
  results = (await getdict_for_key_dictdict('seconds_on_domain_per_day', domain));
  today_day_num = get_days_since_epoch();
  output = {};
  for (k in results) {
    v = results[k];
    output[today_day_num - k] = v;
  }
  return output;
};
out$.get_seconds_spent_on_domain_days_before_today = get_seconds_spent_on_domain_days_before_today = async function(domain, days_ago){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('seconds_on_domain_per_day', domain, current_day - days_ago));
  return result != null ? result : 0;
};
out$.get_seconds_spent_on_domain_today = get_seconds_spent_on_domain_today = async function(domain){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('seconds_on_domain_per_day', domain, current_day));
  return result != null ? result : 0;
};
out$.get_minutes_spent_on_domain_today = get_minutes_spent_on_domain_today = async function(domain){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('seconds_on_domain_per_day', domain, current_day));
  if (result != null) {
    return Math.floor(result / 60.0);
  }
  return 0;
};
/**
* Return seconds spent on current domain today
* @return {integer} seconds spent
*/
out$.get_seconds_spent_on_current_domain_today = get_seconds_spent_on_current_domain_today = async function(){
  var current_domain, result;
  current_domain = window.location.host;
  result = (await get_seconds_spent_on_domain_today(current_domain));
  return result != null ? result : 0;
};
/**
* Return visits to the given domain today
* @param {domain} the doain
* @return {integer} seconds spent
*/
out$.get_visits_to_domain_today = get_visits_to_domain_today = async function(domain){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('visits_to_domain_per_day', domain, current_day));
  return result != null ? result : 0;
};
out$.get_visits_to_domain_days_before_today = get_visits_to_domain_days_before_today = async function(domain, days_ago){
  var current_day, result;
  current_day = get_days_since_epoch();
  result = (await getkey_dictdict('visits_to_domain_per_day', domain, current_day - days_ago));
  return result != null ? result : 0;
};
/**
* Return visits to the given domain today
* @return {integer} seconds spent
*/
out$.get_visits_to_current_domain_today = get_visits_to_current_domain_today = async function(){
  var current_domain, result;
  current_domain = window.location.host;
  result = (await get_visits_to_domain_today(current_domain));
  return result != null ? result : 0;
};
/*
export get_new_session_id_for_domain = (domain) ->>
  collection = await getCollection('seconds_on_domain_per_session')
  all_session_ids_for_domain = await collection.where('key').equals(domain).toArray()
  all_session_ids_for_domain = all_session_ids_for_domain.map (.key2)
  if all_session_ids_for_domain.length == 0
    return 0
  return prelude.maximum(all_session_ids_for_domain) + 1 # this is the day, in epoch time, that the most recent intervention set occurred
*/
out$.get_new_session_id_for_domain = get_new_session_id_for_domain = async function(domain){
  var result;
  result = (await getkey_dict('domain_to_last_session_id', domain));
  if (result == null) {
    (await setkey_dict('domain_to_last_session_id', domain, 0));
    return 0;
  }
  (await setkey_dict('domain_to_last_session_id', domain, result + 1));
  return result + 1;
};
out$.get_seconds_spent_on_current_domain_in_session = get_seconds_spent_on_current_domain_in_session = async function(session_id){
  var current_domain, result;
  current_domain = window.location.host;
  result = (await get_seconds_spent_on_domain_in_session(current_domain, session_id));
  return result != null ? result : 0;
};
out$.get_seconds_spent_on_domain_in_session = get_seconds_spent_on_domain_in_session = async function(domain, session_id){
  var result;
  result = (await getkey_dictdict('seconds_on_domain_per_session', domain, session_id));
  return result != null ? result : 0;
};
/**
* Return seconds spent on current domain this session
* @return {integer} seconds spent
*/
out$.get_seconds_spent_on_current_domain_in_current_session = get_seconds_spent_on_current_domain_in_current_session = async function(){
  var session_id, current_domain, result;
  session_id = get_session_id();
  current_domain = window.location.host;
  result = (await get_seconds_spent_on_domain_in_session(current_domain, session_id));
  return result != null ? result : 0;
};
gexport_module('time_spent_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=time_spent_utils.ls.map


/***/ }),

/***/ "./src/libs_common/time_utils.ls":
/*!***************************************!*\
  !*** ./src/libs_common/time_utils.ls ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var moment, ref$, gexport, gexport_module, get_days_since_epoch, pad_to_two_digits, printable_time_spent_short, printable_time_spent, printable_time_spent_long, out$ =  true && exports || this;
moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
ref$ = __webpack_require__(/*! libs_common/gexport */ "./src/libs_common/gexport.ls"), gexport = ref$.gexport, gexport_module = ref$.gexport_module;
out$.get_days_since_epoch = get_days_since_epoch = function(){
  var start_of_epoch;
  start_of_epoch = moment().year(2016).month(0).date(1).hours(0).minutes(0).seconds(0).milliseconds(0);
  return moment().diff(start_of_epoch, 'days');
};
pad_to_two_digits = function(val){
  var output;
  output = val.toString();
  if (output.length === 1) {
    return '0' + output;
  }
  return output;
};
out$.printable_time_spent_short = printable_time_spent_short = function(seconds){
  var minutes;
  if (seconds < 0) {
    return '00:00';
  }
  minutes = Math.floor(seconds / 60);
  seconds = seconds - minutes * 60;
  return minutes + ':' + pad_to_two_digits(seconds);
};
out$.printable_time_spent = printable_time_spent = function(seconds){
  if (seconds < 60) {
    return seconds + ' seconds';
  }
  return moment().add(seconds, 'seconds').fromNow(true);
};
/**
* Return time spent in hours, minutes, seconds format
* @param {Integer} seconds - seconds spent
* @return {String} 
*/
out$.printable_time_spent_long = printable_time_spent_long = function(seconds){
  var hours, remaining_seconds, minutes, output;
  if (seconds < 0) {
    return '0 seconds';
  }
  hours = Math.floor(seconds / 3600);
  remaining_seconds = seconds - hours * 3600;
  minutes = Math.floor(remaining_seconds / 60);
  remaining_seconds = remaining_seconds - minutes * 60;
  output = [];
  if (hours > 0) {
    if (hours === 1) {
      output.push('1 hour');
    } else {
      output.push(hours + ' hours');
    }
  }
  if (minutes > 0 || hours > 0) {
    if (minutes === 1) {
      output.push('1 minute');
    } else {
      output.push(minutes + ' minutes');
    }
  }
  if (remaining_seconds === 1) {
    output.push('1 second');
  } else if (remaining_seconds >= 0) {
    output.push(remaining_seconds + ' seconds');
  }
  return output.join(' ');
};
gexport_module('time_utils', function(it){
  return eval(it);
});
//# sourceMappingURL=time_utils.ls.map


/***/ }),

/***/ "./src/libs_common/wait_utils.ls":
/*!***************************************!*\
  !*** ./src/libs_common/wait_utils.ls ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wait_token_to_callback, make_wait_token, wait_for_token, finished_waiting, out$ =  true && exports || this;
wait_token_to_callback = {};
out$.make_wait_token = make_wait_token = function(){
  var wait_token;
  for (;;) {
    wait_token = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
    if (!wait_token_to_callback[wait_token]) {
      return wait_token;
    }
  }
};
out$.wait_for_token = wait_for_token = function(wait_token, callback){
  return wait_token_to_callback[wait_token] = callback;
};
out$.finished_waiting = finished_waiting = function(wait_token, data){
  var callback;
  callback = wait_token_to_callback[wait_token];
  delete wait_token_to_callback[wait_token];
  return callback(data);
};
//# sourceMappingURL=wait_utils.ls.map


/***/ }),

/***/ "./src/systemjs_paths.js":
/*!*******************************!*\
  !*** ./src/systemjs_paths.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* edit systemjs_paths_template.js instead of src/systemjs_paths.js (which is generated) */
SystemJS.config({
  baseURL: chrome.extension.getURL('/'),
  packages: {
    'libs_frontend': {
      defaultExtension: 'js',
    },
    'libs_backend': {
      defaultExtension: 'js',
    },
    'libs_common': {
      defaultExtension: 'js',
    },
    'generated_libs/libs_frontend': {
      defaultExtension: 'js',
    },
    'generated_libs/libs_backend': {
      defaultExtension: 'js',
    },
    'components': {
      defaultExtension: 'js',
    },
    'bower_components': {
      defaultExtension: 'js',
    },
    'goals': {
      defaultExtension: 'js',
    },
  },
  meta: {
    '*.html': {
      loader: 'text'
    },
    'data:text/html;base64,*': {
      loader: 'text'
    }
  },
  browserConfig: {
    baseURL: chrome.extension.getURL('/'),
    paths: {
      'npm:': chrome.extension.getURL("/jspm_packages/npm/"),
      'github:': chrome.extension.getURL("/jspm_packages/github/")
    }
  },
  bundles: {
  "bundles/jquery.js": [
    "npm:jquery@3.1.1/dist/jquery.js",
    "npm:jquery@3.1.1.json"
  ],
  "bundles/prettyprintjs.js": [
    "npm:prettyprintjs@0.1.12/index.js",
    "npm:prettyprintjs@0.1.12.json"
  ],
  "bundles/js-yaml.js": [
    "github:nodeca/js-yaml@master/dist/js-yaml.js",
    "github:nodeca/js-yaml@master.json"
  ],
  "bundles/moment.js": [
    "npm:moment@2.17.1/moment.js",
    "npm:moment@2.17.1.json"
  ],
  "bundles/promise-debounce.js": [
    "npm:promise-debounce@1.0.1/index.js",
    "npm:promise-debounce@1.0.1.json"
  ],
  "bundles/shuffled.js": [
    "npm:shuffled@1.0.0/index.js",
    "npm:shuffled@1.0.0.json",
    "npm:shuffle-array@1.0.0/index.js",
    "npm:shuffle-array@1.0.0.json"
  ],
  "bundles/sweetalert2.js": [
    "npm:sweetalert2@6.3.2/dist/sweetalert2.js",
    "npm:sweetalert2@6.3.2.json"
  ],
  "bundles/text.js": [
    "github:systemjs/plugin-text@0.0.8/text.js",
    "github:systemjs/plugin-text@0.0.8.json"
  ],
  "bundles/enable-webcomponents-in-content-scripts.js": [
    "npm:enable-webcomponents-in-content-scripts@1.0.7/index.js",
    "npm:enable-webcomponents-in-content-scripts@1.0.7.json",
    "npm:webcomponentsjs-custom-element-v0@1.0.1/CustomElements.js",
    "npm:webcomponentsjs-custom-element-v0@1.0.1.json"
  ],
  "bundles/underscore.js": [
    "npm:underscore@1.8.3/underscore.js",
    "npm:underscore@1.8.3.json"
  ],
  "bundles/cheerio.js": [
    "npm:cheerio@0.22.0/index.js",
    "npm:cheerio@0.22.0.json",
    "npm:cheerio@0.22.0/package.json",
    "npm:cheerio@0.22.0/lib/cheerio.js",
    "npm:cheerio@0.22.0/lib/static.js",
    "npm:lodash.defaults@4.2.0/index.js",
    "npm:lodash.defaults@4.2.0.json",
    "npm:lodash.merge@4.6.0/index.js",
    "npm:lodash.merge@4.6.0.json",
    "npm:jspm-nodelibs-buffer@0.2.3/global.js",
    "npm:jspm-nodelibs-buffer@0.2.3.json",
    "npm:buffer@5.0.8/index.js",
    "npm:buffer@5.0.8.json",
    "npm:ieee754@1.1.8/index.js",
    "npm:ieee754@1.1.8.json",
    "npm:base64-js@1.2.1/index.js",
    "npm:base64-js@1.2.1.json",
    "npm:cheerio@0.22.0/lib/parse.js",
    "npm:htmlparser2@3.9.2/lib/index.js",
    "npm:htmlparser2@3.9.2.json",
    "npm:htmlparser2@3.9.2/lib/CollectingHandler.js",
    "npm:domutils@1.5.1/index.js",
    "npm:domutils@1.5.1.json",
    "npm:domutils@1.5.1/lib/helpers.js",
    "npm:domutils@1.5.1/lib/legacy.js",
    "npm:domelementtype@1.3.0/index.js",
    "npm:domelementtype@1.3.0.json",
    "npm:domutils@1.5.1/lib/querying.js",
    "npm:domutils@1.5.1/lib/manipulation.js",
    "npm:domutils@1.5.1/lib/traversal.js",
    "npm:domutils@1.5.1/lib/stringify.js",
    "npm:dom-serializer@0.1.0/index.js",
    "npm:dom-serializer@0.1.0.json",
    "npm:entities@1.1.1/index.js",
    "npm:entities@1.1.1.json",
    "npm:entities@1.1.1/lib/decode.js",
    "npm:entities@1.1.1/lib/decode_codepoint.js",
    "npm:entities@1.1.1/maps/decode.json",
    "npm:entities@1.1.1/maps/xml.json",
    "npm:entities@1.1.1/maps/legacy.json",
    "npm:entities@1.1.1/maps/entities.json",
    "npm:entities@1.1.1/lib/encode.js",
    "npm:domelementtype@1.1.3/index.js",
    "npm:domelementtype@1.1.3.json",
    "npm:htmlparser2@3.9.2/lib/ProxyHandler.js",
    "npm:htmlparser2@3.9.2/lib/WritableStream.js",
    "npm:inherits@2.0.3/inherits_browser.js",
    "npm:inherits@2.0.3.json",
    "npm:string_decoder@0.10.31/index.js",
    "npm:string_decoder@0.10.31.json",
    "npm:jspm-nodelibs-string_decoder@0.2.2.json",
    "npm:readable-stream@2.3.3/readable-browser.js",
    "npm:readable-stream@2.3.3.json",
    "npm:jspm-nodelibs-process@0.2.0/process.js",
    "npm:jspm-nodelibs-process@0.2.0.json",
    "npm:readable-stream@2.3.3/lib/_stream_passthrough.js",
    "npm:core-util-is@1.0.2/lib/util.js",
    "npm:core-util-is@1.0.2.json",
    "npm:readable-stream@2.3.3/lib/_stream_transform.js",
    "npm:readable-stream@2.3.3/lib/_stream_duplex.js",
    "npm:readable-stream@2.3.3/lib/_stream_writable.js",
    "npm:readable-stream@2.3.3/lib/internal/streams/destroy.js",
    "npm:process-nextick-args@1.0.7/index.js",
    "npm:process-nextick-args@1.0.7.json",
    "npm:safe-buffer@5.1.1/index.js",
    "npm:safe-buffer@5.1.1.json",
    "npm:readable-stream@2.3.3/lib/internal/streams/stream-browser.js",
    "npm:jspm-nodelibs-events@0.2.0/events.js",
    "npm:jspm-nodelibs-events@0.2.0.json",
    "npm:util-deprecate@1.0.2/browser.js",
    "npm:util-deprecate@1.0.2.json",
    "npm:readable-stream@2.3.3/lib/_stream_readable.js",
    "npm:string_decoder@1.0.3/lib/string_decoder.js",
    "npm:string_decoder@1.0.3.json",
    "npm:readable-stream@2.3.3/lib/internal/streams/BufferList.js",
    "npm:isarray@1.0.0/index.js",
    "npm:isarray@1.0.0.json",
    "npm:stream-browserify@2.0.1/index.js",
    "npm:stream-browserify@2.0.1.json",
    "npm:readable-stream@2.3.3/passthrough.js",
    "npm:readable-stream@2.3.3/transform.js",
    "npm:readable-stream@2.3.3/duplex-browser.js",
    "npm:readable-stream@2.3.3/writable-browser.js",
    "npm:jspm-nodelibs-stream@0.2.0.json",
    "npm:htmlparser2@3.9.2/lib/Parser.js",
    "npm:htmlparser2@3.9.2/lib/Tokenizer.js",
    "npm:htmlparser2@3.9.2/lib/Stream.js",
    "npm:htmlparser2@3.9.2/lib/FeedHandler.js",
    "npm:domhandler@2.3.0/index.js",
    "npm:domhandler@2.3.0.json",
    "npm:domhandler@2.3.0/lib/element.js",
    "npm:domhandler@2.3.0/lib/node.js",
    "npm:css-select@1.2.0/index.js",
    "npm:css-select@1.2.0.json",
    "npm:css-select@1.2.0/lib/compile.js",
    "npm:css-select@1.2.0/lib/pseudos.js",
    "npm:boolbase@1.0.0/index.js",
    "npm:boolbase@1.0.0.json",
    "npm:css-select@1.2.0/lib/attributes.js",
    "npm:nth-check@1.0.1/index.js",
    "npm:nth-check@1.0.1.json",
    "npm:nth-check@1.0.1/compile.js",
    "npm:nth-check@1.0.1/parse.js",
    "npm:css-select@1.2.0/lib/procedure.json",
    "npm:css-select@1.2.0/lib/sort.js",
    "npm:css-select@1.2.0/lib/general.js",
    "npm:css-what@2.1.0/index.js",
    "npm:css-what@2.1.0.json",
    "npm:cheerio@0.22.0/lib/api/forms.js",
    "npm:lodash.map@4.6.0/index.js",
    "npm:lodash.map@4.6.0.json",
    "npm:cheerio@0.22.0/lib/api/css.js",
    "npm:lodash.pick@4.4.0/index.js",
    "npm:lodash.pick@4.4.0.json",
    "npm:cheerio@0.22.0/lib/utils.js",
    "npm:cheerio@0.22.0/lib/api/manipulation.js",
    "npm:lodash.foreach@4.5.0/index.js",
    "npm:lodash.foreach@4.5.0.json",
    "npm:lodash.bind@4.2.1/index.js",
    "npm:lodash.bind@4.2.1.json",
    "npm:lodash.flatten@4.4.0/index.js",
    "npm:lodash.flatten@4.4.0.json",
    "npm:cheerio@0.22.0/lib/api/traversing.js",
    "npm:lodash.reduce@4.6.0/index.js",
    "npm:lodash.reduce@4.6.0.json",
    "npm:lodash.filter@4.6.0/index.js",
    "npm:lodash.filter@4.6.0.json",
    "npm:lodash.reject@4.6.0/index.js",
    "npm:lodash.reject@4.6.0.json",
    "npm:cheerio@0.22.0/lib/api/attributes.js",
    "npm:lodash.some@4.6.0/index.js",
    "npm:lodash.some@4.6.0.json",
    "npm:lodash.assignin@4.2.0/index.js",
    "npm:lodash.assignin@4.2.0.json"
  ],
  "bundles/percipio.js": [
    "npm:percipio@0.1.2/src/index.js",
    "npm:percipio@0.1.2.json",
    "npm:percipio@0.1.2/src/metrics.js",
    "npm:underscore@1.8.3/underscore.js",
    "npm:underscore@1.8.3.json",
    "npm:percipio@0.1.2/src/stats.js",
    "npm:percipio@0.1.2/src/naive_bayes.js",
    "npm:percipio@0.1.2/src/bandits.js"
  ],
  "bundles/livescript15.js": [
    "npm:livescript15@1.5.6/lib/browser.js",
    "npm:livescript15@1.5.6.json",
    "npm:jspm-nodelibs-process@0.2.0/process.js",
    "npm:jspm-nodelibs-process@0.2.0.json",
    "npm:livescript15@1.5.6/lib/index.js",
    "npm:jspm-nodelibs-buffer@0.2.3/global.js",
    "npm:jspm-nodelibs-buffer@0.2.3.json",
    "npm:buffer@5.0.8/index.js",
    "npm:buffer@5.0.8.json",
    "npm:ieee754@1.1.8/index.js",
    "npm:ieee754@1.1.8.json",
    "npm:base64-js@1.2.1/index.js",
    "npm:base64-js@1.2.1.json",
    "npm:jspm-nodelibs-path@0.2.1/path.js",
    "npm:jspm-nodelibs-path@0.2.1.json",
    "npm:livescript15@1.5.6/lib/source-map.js",
    "npm:livescript15@1.5.6/lib/ast.js",
    "npm:livescript15@1.5.6/lib/util.js",
    "npm:prelude-ls@1.1.2/lib/index.js",
    "npm:prelude-ls@1.1.2.json",
    "npm:prelude-ls@1.1.2/lib/Num.js",
    "npm:prelude-ls@1.1.2/lib/Str.js",
    "npm:prelude-ls@1.1.2/lib/Obj.js",
    "npm:prelude-ls@1.1.2/lib/List.js",
    "npm:prelude-ls@1.1.2/lib/Func.js",
    "npm:livescript15@1.5.6/lib/parser.js",
    "npm:jspm-nodelibs-fs@0.2.0/fs.js",
    "npm:jspm-nodelibs-fs@0.2.0.json",
    "npm:livescript15@1.5.6/lib/lexer.js"
  ],
  "bundles/dexie.js": [
    "npm:dexie@1.5.1/dist/dexie.js",
    "npm:dexie@1.5.1.json",
    "npm:jspm-nodelibs-process@0.2.0/process.js",
    "npm:jspm-nodelibs-process@0.2.0.json"
  ],
  "bundles/intervention-editor-libs.js": [
    "npm:list_requires_multi@1.0.2/index.js",
    "npm:list_requires_multi@1.0.2.json",
    "npm:esprima-walk@0.1.0/esprima-walk.js",
    "npm:esprima-walk@0.1.0.json",
    "npm:espree@3.5.1/espree.js",
    "npm:espree@3.5.1.json",
    "npm:espree@3.5.1/lib/visitor-keys.js",
    "npm:espree@3.5.1/package.json",
    "npm:acorn@5.1.2/dist/acorn.js",
    "npm:acorn@5.1.2.json",
    "npm:acorn-jsx@3.0.1/inject.js",
    "npm:acorn-jsx@3.0.1.json",
    "npm:acorn-jsx@3.0.1/xhtml.js",
    "npm:espree@3.5.1/lib/token-translator.js",
    "npm:espree@3.5.1/lib/comment-attachment.js",
    "npm:espree@3.5.1/lib/ast-node-types.js",
    "npm:eslint@4.8.0/lib/api.js",
    "npm:eslint@4.8.0.json",
    "npm:jspm-nodelibs-process@0.2.0/process.js",
    "npm:jspm-nodelibs-process@0.2.0.json",
    "npm:eslint@4.8.0/lib/util/source-code.js",
    "npm:lodash@4.17.10/lodash.js",
    "npm:lodash@4.17.10.json",
    "npm:eslint@4.8.0/lib/ast-utils.js",
    "npm:esutils@2.0.2/lib/utils.js",
    "npm:esutils@2.0.2.json",
    "npm:esutils@2.0.2/lib/keyword.js",
    "npm:esutils@2.0.2/lib/code.js",
    "npm:esutils@2.0.2/lib/ast.js",
    "npm:eslint@4.8.0/lib/util/traverser.js",
    "npm:estraverse@4.2.0/estraverse.js",
    "npm:estraverse@4.2.0.json",
    "npm:estraverse@4.2.0/package.json",
    "npm:eslint@4.8.0/lib/token-store/index.js",
    "npm:eslint@4.8.0/lib/token-store/utils.js",
    "npm:eslint@4.8.0/lib/token-store/padded-token-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/forward-token-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/cursor.js",
    "npm:eslint@4.8.0/lib/token-store/cursors.js",
    "npm:eslint@4.8.0/lib/token-store/skip-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/decorative-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/limit-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/forward-token-comment-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/filter-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/backward-token-cursor.js",
    "npm:eslint@4.8.0/lib/token-store/backward-token-comment-cursor.js",
    "npm:jspm-nodelibs-assert@0.2.0/assert.js",
    "npm:jspm-nodelibs-assert@0.2.0.json",
    "npm:jspm-nodelibs-util@0.2.1/util.js",
    "npm:jspm-nodelibs-util@0.2.1.json",
    "npm:jspm-nodelibs-util@0.2.1/isBufferBrowser.js",
    "npm:eslint@4.8.0/lib/testers/rule-tester.js",
    "npm:eslint@4.8.0/lib/util/source-code-fixer.js",
    "npm:debug@3.1.0/src/browser.js",
    "npm:debug@3.1.0.json",
    "npm:debug@3.1.0/src/debug.js",
    "npm:ms@2.0.0/index.js",
    "npm:ms@2.0.0.json",
    "npm:eslint@4.8.0/lib/config/environments.js",
    "npm:eslint@4.8.0/conf/environments.js",
    "npm:globals@9.18.0/index.js",
    "npm:globals@9.18.0.json",
    "npm:globals@9.18.0/globals.json",
    "npm:eslint@4.8.0/lib/linter.js",
    "npm:eslint@4.8.0/package.json",
    "npm:eslint@4.8.0/lib/timing.js",
    "npm:eslint@4.8.0/lib/rules.js",
    "npm:eslint@4.8.0/lib/rules_all_requires.js",
    "npm:eslint@4.8.0/lib/rules/yoda.js",
    "npm:eslint@4.8.0/lib/rules/yield-star-spacing.js",
    "npm:eslint@4.8.0/lib/rules/wrap-regex.js",
    "npm:eslint@4.8.0/lib/rules/wrap-iife.js",
    "npm:eslint@4.8.0/lib/rules/vars-on-top.js",
    "npm:eslint@4.8.0/lib/rules/valid-typeof.js",
    "npm:eslint@4.8.0/lib/rules/valid-jsdoc.js",
    "npm:doctrine@2.0.0/lib/doctrine.js",
    "npm:doctrine@2.0.0.json",
    "npm:doctrine@2.0.0/lib/utility.js",
    "npm:doctrine@2.0.0/package.json",
    "npm:doctrine@2.0.0/lib/typed.js",
    "npm:isarray@1.0.0/index.js",
    "npm:isarray@1.0.0.json",
    "npm:eslint@4.8.0/lib/rules/use-isnan.js",
    "npm:eslint@4.8.0/lib/rules/unicode-bom.js",
    "npm:eslint@4.8.0/lib/rules/template-tag-spacing.js",
    "npm:eslint@4.8.0/lib/rules/template-curly-spacing.js",
    "npm:eslint@4.8.0/lib/rules/symbol-description.js",
    "npm:eslint@4.8.0/lib/rules/switch-colon-spacing.js",
    "npm:eslint@4.8.0/lib/rules/strict.js",
    "npm:eslint@4.8.0/lib/rules/spaced-comment.js",
    "npm:eslint@4.8.0/lib/rules/space-unary-ops.js",
    "npm:eslint@4.8.0/lib/rules/space-infix-ops.js",
    "npm:eslint@4.8.0/lib/rules/space-in-parens.js",
    "npm:eslint@4.8.0/lib/rules/space-before-function-paren.js",
    "npm:eslint@4.8.0/lib/rules/space-before-blocks.js",
    "npm:eslint@4.8.0/lib/rules/sort-vars.js",
    "npm:eslint@4.8.0/lib/rules/sort-keys.js",
    "npm:natural-compare@1.4.0/index.js",
    "npm:natural-compare@1.4.0.json",
    "npm:eslint@4.8.0/lib/rules/sort-imports.js",
    "npm:eslint@4.8.0/lib/rules/semi.js",
    "npm:eslint@4.8.0/lib/util/fix-tracker.js",
    "npm:eslint@4.8.0/lib/rules/semi-style.js",
    "npm:eslint@4.8.0/lib/rules/semi-spacing.js",
    "npm:eslint@4.8.0/lib/rules/rest-spread-spacing.js",
    "npm:eslint@4.8.0/lib/rules/require-yield.js",
    "npm:eslint@4.8.0/lib/rules/require-jsdoc.js",
    "npm:eslint@4.8.0/lib/rules/require-await.js",
    "npm:eslint@4.8.0/lib/rules/radix.js",
    "npm:eslint@4.8.0/lib/rules/quotes.js",
    "npm:eslint@4.8.0/lib/rules/quote-props.js",
    "npm:eslint@4.8.0/lib/util/keywords.js",
    "npm:eslint@4.8.0/lib/rules/prefer-template.js",
    "npm:eslint@4.8.0/lib/rules/prefer-spread.js",
    "npm:eslint@4.8.0/lib/rules/prefer-rest-params.js",
    "npm:eslint@4.8.0/lib/rules/prefer-reflect.js",
    "npm:eslint@4.8.0/lib/rules/prefer-promise-reject-errors.js",
    "npm:eslint@4.8.0/lib/rules/prefer-numeric-literals.js",
    "npm:eslint@4.8.0/lib/rules/prefer-destructuring.js",
    "npm:eslint@4.8.0/lib/rules/prefer-const.js",
    "npm:eslint@4.8.0/lib/rules/prefer-arrow-callback.js",
    "npm:eslint@4.8.0/lib/rules/padding-line-between-statements.js",
    "npm:eslint@4.8.0/lib/rules/padded-blocks.js",
    "npm:eslint@4.8.0/lib/rules/operator-linebreak.js",
    "npm:eslint@4.8.0/lib/rules/operator-assignment.js",
    "npm:eslint@4.8.0/lib/rules/one-var.js",
    "npm:eslint@4.8.0/lib/rules/one-var-declaration-per-line.js",
    "npm:eslint@4.8.0/lib/rules/object-shorthand.js",
    "npm:eslint@4.8.0/lib/rules/object-property-newline.js",
    "npm:eslint@4.8.0/lib/rules/object-curly-spacing.js",
    "npm:eslint@4.8.0/lib/rules/object-curly-newline.js",
    "npm:eslint@4.8.0/lib/rules/nonblock-statement-body-position.js",
    "npm:eslint@4.8.0/lib/rules/no-with.js",
    "npm:eslint@4.8.0/lib/rules/no-whitespace-before-property.js",
    "npm:eslint@4.8.0/lib/rules/no-warning-comments.js",
    "npm:eslint@4.8.0/lib/rules/no-void.js",
    "npm:eslint@4.8.0/lib/rules/no-var.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-return.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-rename.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-escape.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-constructor.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-concat.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-computed-key.js",
    "npm:eslint@4.8.0/lib/rules/no-useless-call.js",
    "npm:eslint@4.8.0/lib/rules/no-use-before-define.js",
    "npm:eslint@4.8.0/lib/rules/no-unused-vars.js",
    "npm:eslint@4.8.0/lib/rules/no-unused-labels.js",
    "npm:eslint@4.8.0/lib/rules/no-unused-expressions.js",
    "npm:eslint@4.8.0/lib/rules/no-unsafe-negation.js",
    "npm:eslint@4.8.0/lib/rules/no-unsafe-finally.js",
    "npm:eslint@4.8.0/lib/rules/no-unreachable.js",
    "npm:eslint@4.8.0/lib/rules/no-unneeded-ternary.js",
    "npm:eslint@4.8.0/lib/rules/no-unmodified-loop-condition.js",
    "npm:eslint@4.8.0/lib/rules/no-unexpected-multiline.js",
    "npm:eslint@4.8.0/lib/rules/no-underscore-dangle.js",
    "npm:eslint@4.8.0/lib/rules/no-undefined.js",
    "npm:eslint@4.8.0/lib/rules/no-undef.js",
    "npm:eslint@4.8.0/lib/rules/no-undef-init.js",
    "npm:eslint@4.8.0/lib/rules/no-trailing-spaces.js",
    "npm:eslint@4.8.0/lib/rules/no-throw-literal.js",
    "npm:eslint@4.8.0/lib/rules/no-this-before-super.js",
    "npm:eslint@4.8.0/lib/rules/no-ternary.js",
    "npm:eslint@4.8.0/lib/rules/no-template-curly-in-string.js",
    "npm:eslint@4.8.0/lib/rules/no-tabs.js",
    "npm:eslint@4.8.0/lib/rules/no-sync.js",
    "npm:eslint@4.8.0/lib/rules/no-sparse-arrays.js",
    "npm:eslint@4.8.0/lib/rules/no-spaced-func.js",
    "npm:eslint@4.8.0/lib/rules/no-shadow.js",
    "npm:eslint@4.8.0/lib/rules/no-shadow-restricted-names.js",
    "npm:eslint@4.8.0/lib/rules/no-sequences.js",
    "npm:eslint@4.8.0/lib/rules/no-self-compare.js",
    "npm:eslint@4.8.0/lib/rules/no-self-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-script-url.js",
    "npm:eslint@4.8.0/lib/rules/no-return-await.js",
    "npm:eslint@4.8.0/lib/rules/no-return-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-restricted-syntax.js",
    "npm:eslint@4.8.0/lib/rules/no-restricted-properties.js",
    "npm:eslint@4.8.0/lib/rules/no-restricted-modules.js",
    "npm:ignore@3.3.5/ignore.js",
    "npm:ignore@3.3.5.json",
    "npm:eslint@4.8.0/lib/rules/no-restricted-imports.js",
    "npm:eslint@4.8.0/lib/rules/no-restricted-globals.js",
    "npm:eslint@4.8.0/lib/rules/no-regex-spaces.js",
    "npm:eslint@4.8.0/lib/rules/no-redeclare.js",
    "npm:eslint@4.8.0/lib/rules/no-prototype-builtins.js",
    "npm:eslint@4.8.0/lib/rules/no-proto.js",
    "npm:eslint@4.8.0/lib/rules/no-process-exit.js",
    "npm:eslint@4.8.0/lib/rules/no-process-env.js",
    "npm:eslint@4.8.0/lib/rules/no-plusplus.js",
    "npm:eslint@4.8.0/lib/rules/no-path-concat.js",
    "npm:eslint@4.8.0/lib/rules/no-param-reassign.js",
    "npm:eslint@4.8.0/lib/rules/no-octal.js",
    "npm:eslint@4.8.0/lib/rules/no-octal-escape.js",
    "npm:eslint@4.8.0/lib/rules/no-obj-calls.js",
    "npm:eslint@4.8.0/lib/rules/no-new.js",
    "npm:eslint@4.8.0/lib/rules/no-new-wrappers.js",
    "npm:eslint@4.8.0/lib/rules/no-new-symbol.js",
    "npm:eslint@4.8.0/lib/rules/no-new-require.js",
    "npm:eslint@4.8.0/lib/rules/no-new-object.js",
    "npm:eslint@4.8.0/lib/rules/no-new-func.js",
    "npm:eslint@4.8.0/lib/rules/no-nested-ternary.js",
    "npm:eslint@4.8.0/lib/rules/no-negated-in-lhs.js",
    "npm:eslint@4.8.0/lib/rules/no-negated-condition.js",
    "npm:eslint@4.8.0/lib/rules/no-native-reassign.js",
    "npm:eslint@4.8.0/lib/rules/no-multiple-empty-lines.js",
    "npm:eslint@4.8.0/lib/rules/no-multi-str.js",
    "npm:eslint@4.8.0/lib/rules/no-multi-spaces.js",
    "npm:eslint@4.8.0/lib/rules/no-multi-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-mixed-spaces-and-tabs.js",
    "npm:eslint@4.8.0/lib/rules/no-mixed-requires.js",
    "npm:eslint@4.8.0/lib/rules/no-mixed-operators.js",
    "npm:eslint@4.8.0/lib/rules/no-magic-numbers.js",
    "npm:eslint@4.8.0/lib/rules/no-loop-func.js",
    "npm:eslint@4.8.0/lib/rules/no-lonely-if.js",
    "npm:eslint@4.8.0/lib/rules/no-lone-blocks.js",
    "npm:eslint@4.8.0/lib/rules/no-labels.js",
    "npm:eslint@4.8.0/lib/rules/no-label-var.js",
    "npm:eslint@4.8.0/lib/rules/no-iterator.js",
    "npm:eslint@4.8.0/lib/rules/no-irregular-whitespace.js",
    "npm:eslint@4.8.0/lib/rules/no-invalid-this.js",
    "npm:eslint@4.8.0/lib/rules/no-invalid-regexp.js",
    "npm:eslint@4.8.0/lib/rules/no-inner-declarations.js",
    "npm:eslint@4.8.0/lib/rules/no-inline-comments.js",
    "npm:eslint@4.8.0/lib/rules/no-implied-eval.js",
    "npm:eslint@4.8.0/lib/rules/no-implicit-globals.js",
    "npm:eslint@4.8.0/lib/rules/no-implicit-coercion.js",
    "npm:eslint@4.8.0/lib/rules/no-global-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-func-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-floating-decimal.js",
    "npm:eslint@4.8.0/lib/rules/no-fallthrough.js",
    "npm:eslint@4.8.0/lib/rules/no-extra-semi.js",
    "npm:eslint@4.8.0/lib/rules/no-extra-parens.js",
    "npm:eslint@4.8.0/lib/rules/no-extra-label.js",
    "npm:eslint@4.8.0/lib/rules/no-extra-boolean-cast.js",
    "npm:eslint@4.8.0/lib/rules/no-extra-bind.js",
    "npm:eslint@4.8.0/lib/rules/no-extend-native.js",
    "npm:eslint@4.8.0/lib/rules/no-ex-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-eval.js",
    "npm:eslint@4.8.0/lib/rules/no-eq-null.js",
    "npm:eslint@4.8.0/lib/rules/no-empty.js",
    "npm:eslint@4.8.0/lib/rules/no-empty-pattern.js",
    "npm:eslint@4.8.0/lib/rules/no-empty-function.js",
    "npm:eslint@4.8.0/lib/rules/no-empty-character-class.js",
    "npm:eslint@4.8.0/lib/rules/no-else-return.js",
    "npm:eslint@4.8.0/lib/rules/no-duplicate-imports.js",
    "npm:eslint@4.8.0/lib/rules/no-duplicate-case.js",
    "npm:eslint@4.8.0/lib/rules/no-dupe-keys.js",
    "npm:eslint@4.8.0/lib/rules/no-dupe-class-members.js",
    "npm:eslint@4.8.0/lib/rules/no-dupe-args.js",
    "npm:eslint@4.8.0/lib/rules/no-div-regex.js",
    "npm:eslint@4.8.0/lib/rules/no-delete-var.js",
    "npm:eslint@4.8.0/lib/rules/no-debugger.js",
    "npm:eslint@4.8.0/lib/rules/no-control-regex.js",
    "npm:eslint@4.8.0/lib/rules/no-continue.js",
    "npm:eslint@4.8.0/lib/rules/no-constant-condition.js",
    "npm:eslint@4.8.0/lib/rules/no-const-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-console.js",
    "npm:eslint@4.8.0/lib/rules/no-confusing-arrow.js",
    "npm:eslint@4.8.0/lib/rules/no-cond-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-compare-neg-zero.js",
    "npm:eslint@4.8.0/lib/rules/no-class-assign.js",
    "npm:eslint@4.8.0/lib/rules/no-catch-shadow.js",
    "npm:eslint@4.8.0/lib/rules/no-case-declarations.js",
    "npm:eslint@4.8.0/lib/rules/no-caller.js",
    "npm:eslint@4.8.0/lib/rules/no-buffer-constructor.js",
    "npm:eslint@4.8.0/lib/rules/no-bitwise.js",
    "npm:eslint@4.8.0/lib/rules/no-await-in-loop.js",
    "npm:eslint@4.8.0/lib/rules/no-array-constructor.js",
    "npm:eslint@4.8.0/lib/rules/no-alert.js",
    "npm:eslint@4.8.0/lib/rules/newline-per-chained-call.js",
    "npm:eslint@4.8.0/lib/rules/newline-before-return.js",
    "npm:eslint@4.8.0/lib/rules/newline-after-var.js",
    "npm:eslint@4.8.0/lib/rules/new-parens.js",
    "npm:eslint@4.8.0/lib/rules/new-cap.js",
    "npm:eslint@4.8.0/lib/rules/multiline-ternary.js",
    "npm:eslint@4.8.0/lib/rules/max-statements.js",
    "npm:eslint@4.8.0/lib/rules/max-statements-per-line.js",
    "npm:eslint@4.8.0/lib/rules/max-params.js",
    "npm:eslint@4.8.0/lib/rules/max-nested-callbacks.js",
    "npm:eslint@4.8.0/lib/rules/max-lines.js",
    "npm:eslint@4.8.0/lib/rules/max-len.js",
    "npm:eslint@4.8.0/lib/rules/max-depth.js",
    "npm:eslint@4.8.0/lib/rules/lines-around-directive.js",
    "npm:eslint@4.8.0/lib/rules/lines-around-comment.js",
    "npm:eslint@4.8.0/lib/rules/linebreak-style.js",
    "npm:eslint@4.8.0/lib/rules/line-comment-position.js",
    "npm:eslint@4.8.0/lib/rules/keyword-spacing.js",
    "npm:eslint@4.8.0/lib/rules/key-spacing.js",
    "npm:eslint@4.8.0/lib/rules/jsx-quotes.js",
    "npm:eslint@4.8.0/lib/rules/init-declarations.js",
    "npm:eslint@4.8.0/lib/rules/indent.js",
    "npm:functional-red-black-tree@1.0.1/rbtree.js",
    "npm:functional-red-black-tree@1.0.1.json",
    "npm:eslint@4.8.0/lib/rules/indent-legacy.js",
    "npm:eslint@4.8.0/lib/rules/id-match.js",
    "npm:eslint@4.8.0/lib/rules/id-length.js",
    "npm:eslint@4.8.0/lib/rules/id-blacklist.js",
    "npm:eslint@4.8.0/lib/rules/handle-callback-err.js",
    "npm:eslint@4.8.0/lib/rules/guard-for-in.js",
    "npm:eslint@4.8.0/lib/rules/global-require.js",
    "npm:eslint@4.8.0/lib/rules/getter-return.js",
    "npm:eslint@4.8.0/lib/rules/generator-star-spacing.js",
    "npm:eslint@4.8.0/lib/rules/function-paren-newline.js",
    "npm:eslint@4.8.0/lib/rules/func-style.js",
    "npm:eslint@4.8.0/lib/rules/func-names.js",
    "npm:eslint@4.8.0/lib/rules/func-name-matching.js",
    "npm:eslint@4.8.0/lib/rules/func-call-spacing.js",
    "npm:eslint@4.8.0/lib/rules/for-direction.js",
    "npm:eslint@4.8.0/lib/rules/eqeqeq.js",
    "npm:eslint@4.8.0/lib/rules/eol-last.js",
    "npm:eslint@4.8.0/lib/rules/dot-notation.js",
    "npm:eslint@4.8.0/lib/rules/dot-location.js",
    "npm:eslint@4.8.0/lib/rules/default-case.js",
    "npm:eslint@4.8.0/lib/rules/curly.js",
    "npm:eslint@4.8.0/lib/rules/constructor-super.js",
    "npm:eslint@4.8.0/lib/rules/consistent-this.js",
    "npm:eslint@4.8.0/lib/rules/consistent-return.js",
    "npm:eslint@4.8.0/lib/rules/computed-property-spacing.js",
    "npm:eslint@4.8.0/lib/rules/complexity.js",
    "npm:eslint@4.8.0/lib/rules/comma-style.js",
    "npm:eslint@4.8.0/lib/rules/comma-spacing.js",
    "npm:eslint@4.8.0/lib/rules/comma-dangle.js",
    "npm:eslint@4.8.0/lib/rules/class-methods-use-this.js",
    "npm:eslint@4.8.0/lib/rules/capitalized-comments.js",
    "npm:eslint@4.8.0/lib/util/patterns/letters.js",
    "npm:eslint@4.8.0/lib/rules/camelcase.js",
    "npm:eslint@4.8.0/lib/rules/callback-return.js",
    "npm:eslint@4.8.0/lib/rules/brace-style.js",
    "npm:eslint@4.8.0/lib/rules/block-spacing.js",
    "npm:eslint@4.8.0/lib/rules/block-scoped-var.js",
    "npm:eslint@4.8.0/lib/rules/arrow-spacing.js",
    "npm:eslint@4.8.0/lib/rules/arrow-parens.js",
    "npm:eslint@4.8.0/lib/rules/arrow-body-style.js",
    "npm:eslint@4.8.0/lib/rules/array-element-newline.js",
    "npm:eslint@4.8.0/lib/rules/array-callback-return.js",
    "npm:eslint@4.8.0/lib/rules/array-bracket-spacing.js",
    "npm:eslint@4.8.0/lib/rules/array-bracket-newline.js",
    "npm:eslint@4.8.0/lib/rules/accessor-pairs.js",
    "npm:eslint@4.8.0/conf/replacements.json",
    "npm:eslint@4.8.0/lib/load-rules.js",
    "npm:eslint@4.8.0/lib/rules_filenames.js",
    "npm:jspm-nodelibs-path@0.2.1/path.js",
    "npm:jspm-nodelibs-path@0.2.1.json",
    "npm:jspm-nodelibs-fs@0.2.0/fs.js",
    "npm:jspm-nodelibs-fs@0.2.0.json",
    "npm:eslint@4.8.0/lib/report-translator.js",
    "npm:eslint@4.8.0/lib/util/rule-fixer.js",
    "npm:eslint@4.8.0/lib/util/node-event-generator.js",
    "npm:esquery@1.0.0/esquery.js",
    "npm:esquery@1.0.0.json",
    "npm:esquery@1.0.0/parser.js",
    "npm:eslint@4.8.0/lib/util/safe-emitter.js",
    "npm:eslint@4.8.0/lib/util/apply-disable-directives.js",
    "npm:eslint@4.8.0/lib/config/config-validator.js",
    "npm:eslint@4.8.0/conf/config-schema.js",
    "npm:eslint@4.8.0/lib/util/ajv.js",
    "npm:ajv@5.2.3/lib/refs/json-schema-draft-04.json",
    "npm:ajv@5.2.3.json",
    "npm:ajv@5.2.3/lib/ajv.js",
    "npm:ajv@5.2.3/lib/refs/json-schema-draft-06.json",
    "npm:ajv@5.2.3/lib/refs/$data.json",
    "npm:ajv@5.2.3/lib/compile/error_classes.js",
    "npm:ajv@5.2.3/lib/compile/resolve.js",
    "npm:json-schema-traverse@0.3.1/index.js",
    "npm:json-schema-traverse@0.3.1.json",
    "npm:ajv@5.2.3/lib/compile/schema_obj.js",
    "npm:ajv@5.2.3/lib/compile/util.js",
    "npm:ajv@5.2.3/lib/compile/ucs2length.js",
    "npm:fast-deep-equal@1.0.0/index.js",
    "npm:fast-deep-equal@1.0.0.json",
    "npm:url@0.11.0/url.js",
    "npm:url@0.11.0.json",
    "npm:querystring@0.2.0/index.js",
    "npm:querystring@0.2.0.json",
    "npm:querystring@0.2.0/encode.js",
    "npm:querystring@0.2.0/decode.js",
    "npm:url@0.11.0/util.js",
    "npm:punycode@1.3.2/punycode.js",
    "npm:punycode@1.3.2.json",
    "npm:jspm-nodelibs-url@0.2.0.json",
    "npm:ajv@5.2.3/lib/keyword.js",
    "npm:ajv@5.2.3/lib/dotjs/custom.js",
    "npm:ajv@5.2.3/lib/compile/async.js",
    "npm:co@4.6.0/index.js",
    "npm:co@4.6.0.json",
    "npm:ajv@5.2.3/lib/patternGroups.js",
    "npm:ajv@5.2.3/lib/$data.js",
    "npm:ajv@5.2.3/lib/compile/rules.js",
    "npm:ajv@5.2.3/lib/compile/_rules.js",
    "npm:ajv@5.2.3/lib/dotjs/validate.js",
    "npm:ajv@5.2.3/lib/dotjs/uniqueItems.js",
    "npm:ajv@5.2.3/lib/dotjs/required.js",
    "npm:ajv@5.2.3/lib/dotjs/propertyNames.js",
    "npm:ajv@5.2.3/lib/dotjs/properties.js",
    "npm:ajv@5.2.3/lib/dotjs/pattern.js",
    "npm:ajv@5.2.3/lib/dotjs/oneOf.js",
    "npm:ajv@5.2.3/lib/dotjs/not.js",
    "npm:ajv@5.2.3/lib/dotjs/multipleOf.js",
    "npm:ajv@5.2.3/lib/dotjs/_limitProperties.js",
    "npm:ajv@5.2.3/lib/dotjs/_limitLength.js",
    "npm:ajv@5.2.3/lib/dotjs/_limitItems.js",
    "npm:ajv@5.2.3/lib/dotjs/_limit.js",
    "npm:ajv@5.2.3/lib/dotjs/items.js",
    "npm:ajv@5.2.3/lib/dotjs/format.js",
    "npm:ajv@5.2.3/lib/dotjs/enum.js",
    "npm:ajv@5.2.3/lib/dotjs/dependencies.js",
    "npm:ajv@5.2.3/lib/dotjs/contains.js",
    "npm:ajv@5.2.3/lib/dotjs/const.js",
    "npm:ajv@5.2.3/lib/dotjs/anyOf.js",
    "npm:ajv@5.2.3/lib/dotjs/allOf.js",
    "npm:ajv@5.2.3/lib/dotjs/ref.js",
    "npm:ajv@5.2.3/lib/compile/formats.js",
    "npm:json-stable-stringify@1.0.1/index.js",
    "npm:json-stable-stringify@1.0.1.json",
    "npm:jsonify@0.0.0/index.js",
    "npm:jsonify@0.0.0.json",
    "npm:jsonify@0.0.0/lib/stringify.js",
    "npm:jsonify@0.0.0/lib/parse.js",
    "npm:ajv@5.2.3/lib/cache.js",
    "npm:ajv@5.2.3/lib/compile/index.js",
    "npm:eslint@4.8.0/lib/config/config-ops.js",
    "npm:minimatch@3.0.4/minimatch.js",
    "npm:minimatch@3.0.4.json",
    "npm:brace-expansion@1.1.8/index.js",
    "npm:brace-expansion@1.1.8.json",
    "npm:balanced-match@1.0.0/index.js",
    "npm:balanced-match@1.0.0.json",
    "npm:concat-map@0.0.1/index.js",
    "npm:concat-map@0.0.1.json",
    "npm:eslint@4.8.0/lib/code-path-analysis/code-path-analyzer.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/debug-helpers.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/id-generator.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/code-path-segment.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/code-path.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/code-path-state.js",
    "npm:eslint@4.8.0/lib/code-path-analysis/fork-context.js",
    "npm:eslint@4.8.0/conf/default-config-options.js",
    "npm:eslint@4.8.0/conf/blank-script.json",
    "npm:levn@0.3.0/lib/index.js",
    "npm:levn@0.3.0.json",
    "npm:type-check@0.3.2/lib/index.js",
    "npm:type-check@0.3.2.json",
    "npm:type-check@0.3.2/lib/check.js",
    "npm:prelude-ls@1.1.2/lib/index.js",
    "npm:prelude-ls@1.1.2.json",
    "npm:prelude-ls@1.1.2/lib/Num.js",
    "npm:prelude-ls@1.1.2/lib/Str.js",
    "npm:prelude-ls@1.1.2/lib/Obj.js",
    "npm:prelude-ls@1.1.2/lib/List.js",
    "npm:prelude-ls@1.1.2/lib/Func.js",
    "npm:type-check@0.3.2/lib/parse-type.js",
    "npm:levn@0.3.0/lib/cast.js",
    "npm:levn@0.3.0/lib/parse-string.js",
    "npm:eslint-scope@3.7.1/lib/index.js",
    "npm:eslint-scope@3.7.1.json",
    "npm:eslint-scope@3.7.1/package.json",
    "npm:eslint-scope@3.7.1/lib/scope.js",
    "npm:eslint-scope@3.7.1/lib/definition.js",
    "npm:eslint-scope@3.7.1/lib/variable.js",
    "npm:eslint-scope@3.7.1/lib/reference.js",
    "npm:eslint-scope@3.7.1/lib/referencer.js",
    "npm:eslint-scope@3.7.1/lib/pattern-visitor.js",
    "npm:esrecurse@4.2.0/esrecurse.js",
    "npm:esrecurse@4.2.0.json",
    "npm:esrecurse@4.2.0/package.json",
    "npm:object-assign@4.1.1/index.js",
    "npm:object-assign@4.1.1.json",
    "npm:eslint-scope@3.7.1/lib/scope-manager.js",
    "npm:brace@0.10.0/theme/monokai.js",
    "npm:brace@0.10.0.json",
    "npm:brace@0.10.0/mode/jsx.js",
    "npm:brace@0.10.0/mode/javascript.js",
    "npm:brace@0.10.0/worker/javascript.js",
    "npm:brace@0.10.0/mode/html.js",
    "npm:brace@0.10.0/worker/html.js",
    "npm:brace@0.10.0/worker/css.js",
    "npm:brace@0.10.0/index.js",
    "npm:w3c-blob@0.0.1/browser.js",
    "npm:w3c-blob@0.0.1.json",
    "npm:brace@0.10.0/ext/language_tools.js",
    "npm:babel-standalone@6.26.0/babel.js",
    "npm:babel-standalone@6.26.0.json",
    "npm:babel-preset-react@6.24.1/lib/index.js",
    "npm:babel-preset-react@6.24.1.json",
    "npm:babel-plugin-transform-react-display-name@6.25.0/lib/index.js",
    "npm:babel-plugin-transform-react-display-name@6.25.0.json",
    "npm:babel-plugin-syntax-jsx@6.18.0/lib/index.js",
    "npm:babel-plugin-syntax-jsx@6.18.0.json",
    "npm:babel-plugin-transform-react-jsx@6.24.1/lib/index.js",
    "npm:babel-plugin-transform-react-jsx@6.24.1.json",
    "npm:babel-helper-builder-react-jsx@6.26.0/lib/index.js",
    "npm:babel-helper-builder-react-jsx@6.26.0.json",
    "npm:babel-types@6.26.0/lib/index.js",
    "npm:babel-types@6.26.0.json",
    "npm:babel-types@6.26.0/lib/react.js",
    "npm:babel-types@6.26.0/lib/definitions/index.js",
    "npm:babel-runtime@6.26.0/helpers/typeof.js",
    "npm:babel-runtime@6.26.0.json",
    "npm:babel-runtime@6.26.0/core-js/symbol.js",
    "npm:core-js@2.5.7/library/fn/symbol/index.js",
    "npm:core-js@2.5.7.json",
    "npm:core-js@2.5.7/library/modules/_core.js",
    "npm:core-js@2.5.7/library/modules/es7.symbol.observable.js",
    "npm:core-js@2.5.7/library/modules/_wks-define.js",
    "npm:core-js@2.5.7/library/modules/_object-dp.js",
    "npm:core-js@2.5.7/library/modules/_descriptors.js",
    "npm:core-js@2.5.7/library/modules/_fails.js",
    "npm:core-js@2.5.7/library/modules/_to-primitive.js",
    "npm:core-js@2.5.7/library/modules/_is-object.js",
    "npm:core-js@2.5.7/library/modules/_ie8-dom-define.js",
    "npm:core-js@2.5.7/library/modules/_dom-create.js",
    "npm:core-js@2.5.7/library/modules/_global.js",
    "npm:core-js@2.5.7/library/modules/_an-object.js",
    "npm:core-js@2.5.7/library/modules/_wks-ext.js",
    "npm:core-js@2.5.7/library/modules/_wks.js",
    "npm:core-js@2.5.7/library/modules/_uid.js",
    "npm:core-js@2.5.7/library/modules/_shared.js",
    "npm:core-js@2.5.7/library/modules/_library.js",
    "npm:core-js@2.5.7/library/modules/es7.symbol.async-iterator.js",
    "npm:core-js@2.5.7/library/modules/es6.object.to-string.js",
    "npm:core-js@2.5.7/library/modules/es6.symbol.js",
    "npm:core-js@2.5.7/library/modules/_hide.js",
    "npm:core-js@2.5.7/library/modules/_property-desc.js",
    "npm:core-js@2.5.7/library/modules/_object-gops.js",
    "npm:core-js@2.5.7/library/modules/_object-pie.js",
    "npm:core-js@2.5.7/library/modules/_object-gopn.js",
    "npm:core-js@2.5.7/library/modules/_enum-bug-keys.js",
    "npm:core-js@2.5.7/library/modules/_object-keys-internal.js",
    "npm:core-js@2.5.7/library/modules/_shared-key.js",
    "npm:core-js@2.5.7/library/modules/_array-includes.js",
    "npm:core-js@2.5.7/library/modules/_to-absolute-index.js",
    "npm:core-js@2.5.7/library/modules/_to-integer.js",
    "npm:core-js@2.5.7/library/modules/_to-length.js",
    "npm:core-js@2.5.7/library/modules/_to-iobject.js",
    "npm:core-js@2.5.7/library/modules/_defined.js",
    "npm:core-js@2.5.7/library/modules/_iobject.js",
    "npm:core-js@2.5.7/library/modules/_cof.js",
    "npm:core-js@2.5.7/library/modules/_has.js",
    "npm:core-js@2.5.7/library/modules/_object-keys.js",
    "npm:core-js@2.5.7/library/modules/_object-gopd.js",
    "npm:core-js@2.5.7/library/modules/_object-gopn-ext.js",
    "npm:core-js@2.5.7/library/modules/_object-create.js",
    "npm:core-js@2.5.7/library/modules/_html.js",
    "npm:core-js@2.5.7/library/modules/_object-dps.js",
    "npm:core-js@2.5.7/library/modules/_is-array.js",
    "npm:core-js@2.5.7/library/modules/_enum-keys.js",
    "npm:core-js@2.5.7/library/modules/_set-to-string-tag.js",
    "npm:core-js@2.5.7/library/modules/_meta.js",
    "npm:core-js@2.5.7/library/modules/_redefine.js",
    "npm:core-js@2.5.7/library/modules/_export.js",
    "npm:core-js@2.5.7/library/modules/_ctx.js",
    "npm:core-js@2.5.7/library/modules/_a-function.js",
    "npm:babel-runtime@6.26.0/core-js/symbol/iterator.js",
    "npm:core-js@2.5.7/library/fn/symbol/iterator.js",
    "npm:core-js@2.5.7/library/modules/web.dom.iterable.js",
    "npm:core-js@2.5.7/library/modules/_iterators.js",
    "npm:core-js@2.5.7/library/modules/es6.array.iterator.js",
    "npm:core-js@2.5.7/library/modules/_iter-define.js",
    "npm:core-js@2.5.7/library/modules/_object-gpo.js",
    "npm:core-js@2.5.7/library/modules/_to-object.js",
    "npm:core-js@2.5.7/library/modules/_iter-create.js",
    "npm:core-js@2.5.7/library/modules/_iter-step.js",
    "npm:core-js@2.5.7/library/modules/_add-to-unscopables.js",
    "npm:core-js@2.5.7/library/modules/es6.string.iterator.js",
    "npm:core-js@2.5.7/library/modules/_string-at.js",
    "npm:babel-runtime@6.26.0/core-js/json/stringify.js",
    "npm:core-js@2.5.7/library/fn/json/stringify.js",
    "npm:babel-runtime@6.26.0/core-js/get-iterator.js",
    "npm:core-js@2.5.7/library/fn/get-iterator.js",
    "npm:core-js@2.5.7/library/modules/core.get-iterator.js",
    "npm:core-js@2.5.7/library/modules/core.get-iterator-method.js",
    "npm:core-js@2.5.7/library/modules/_classof.js",
    "npm:babel-types@6.26.0/lib/definitions/init.js",
    "npm:babel-types@6.26.0/lib/definitions/experimental.js",
    "npm:babel-types@6.26.0/lib/definitions/misc.js",
    "npm:babel-types@6.26.0/lib/definitions/jsx.js",
    "npm:babel-types@6.26.0/lib/definitions/flow.js",
    "npm:babel-types@6.26.0/lib/definitions/es2015.js",
    "npm:babel-types@6.26.0/lib/definitions/core.js",
    "npm:babel-types@6.26.0/lib/constants.js",
    "npm:babel-runtime@6.26.0/core-js/symbol/for.js",
    "npm:core-js@2.5.7/library/fn/symbol/for.js",
    "npm:lodash@4.17.10/uniq.js",
    "npm:lodash@4.17.10/_baseUniq.js",
    "npm:lodash@4.17.10/_setToArray.js",
    "npm:lodash@4.17.10/_createSet.js",
    "npm:lodash@4.17.10/noop.js",
    "npm:lodash@4.17.10/_Set.js",
    "npm:lodash@4.17.10/_root.js",
    "npm:lodash@4.17.10/_freeGlobal.js",
    "npm:lodash@4.17.10/_getNative.js",
    "npm:lodash@4.17.10/_getValue.js",
    "npm:lodash@4.17.10/_baseIsNative.js",
    "npm:lodash@4.17.10/_toSource.js",
    "npm:lodash@4.17.10/isObject.js",
    "npm:lodash@4.17.10/_isMasked.js",
    "npm:lodash@4.17.10/_coreJsData.js",
    "npm:lodash@4.17.10/isFunction.js",
    "npm:lodash@4.17.10/_baseGetTag.js",
    "npm:lodash@4.17.10/_objectToString.js",
    "npm:lodash@4.17.10/_getRawTag.js",
    "npm:lodash@4.17.10/_Symbol.js",
    "npm:lodash@4.17.10/_cacheHas.js",
    "npm:lodash@4.17.10/_arrayIncludesWith.js",
    "npm:lodash@4.17.10/_arrayIncludes.js",
    "npm:lodash@4.17.10/_baseIndexOf.js",
    "npm:lodash@4.17.10/_strictIndexOf.js",
    "npm:lodash@4.17.10/_baseIsNaN.js",
    "npm:lodash@4.17.10/_baseFindIndex.js",
    "npm:lodash@4.17.10/_SetCache.js",
    "npm:lodash@4.17.10/_setCacheHas.js",
    "npm:lodash@4.17.10/_setCacheAdd.js",
    "npm:lodash@4.17.10/_MapCache.js",
    "npm:lodash@4.17.10/_mapCacheSet.js",
    "npm:lodash@4.17.10/_getMapData.js",
    "npm:lodash@4.17.10/_isKeyable.js",
    "npm:lodash@4.17.10/_mapCacheHas.js",
    "npm:lodash@4.17.10/_mapCacheGet.js",
    "npm:lodash@4.17.10/_mapCacheDelete.js",
    "npm:lodash@4.17.10/_mapCacheClear.js",
    "npm:lodash@4.17.10/_Map.js",
    "npm:lodash@4.17.10/_ListCache.js",
    "npm:lodash@4.17.10/_listCacheSet.js",
    "npm:lodash@4.17.10/_assocIndexOf.js",
    "npm:lodash@4.17.10/eq.js",
    "npm:lodash@4.17.10/_listCacheHas.js",
    "npm:lodash@4.17.10/_listCacheGet.js",
    "npm:lodash@4.17.10/_listCacheDelete.js",
    "npm:lodash@4.17.10/_listCacheClear.js",
    "npm:lodash@4.17.10/_Hash.js",
    "npm:lodash@4.17.10/_hashSet.js",
    "npm:lodash@4.17.10/_nativeCreate.js",
    "npm:lodash@4.17.10/_hashHas.js",
    "npm:lodash@4.17.10/_hashGet.js",
    "npm:lodash@4.17.10/_hashDelete.js",
    "npm:lodash@4.17.10/_hashClear.js",
    "npm:lodash@4.17.10/clone.js",
    "npm:lodash@4.17.10/_baseClone.js",
    "npm:lodash@4.17.10/keys.js",
    "npm:lodash@4.17.10/isArrayLike.js",
    "npm:lodash@4.17.10/isLength.js",
    "npm:lodash@4.17.10/_baseKeys.js",
    "npm:lodash@4.17.10/_nativeKeys.js",
    "npm:lodash@4.17.10/_overArg.js",
    "npm:lodash@4.17.10/_isPrototype.js",
    "npm:lodash@4.17.10/_arrayLikeKeys.js",
    "npm:lodash@4.17.10/isTypedArray.js",
    "npm:lodash@4.17.10/_nodeUtil.js",
    "npm:lodash@4.17.10/_baseUnary.js",
    "npm:lodash@4.17.10/_baseIsTypedArray.js",
    "npm:lodash@4.17.10/isObjectLike.js",
    "npm:lodash@4.17.10/_isIndex.js",
    "npm:lodash@4.17.10/isBuffer.js",
    "npm:lodash@4.17.10/stubFalse.js",
    "npm:lodash@4.17.10/isArray.js",
    "npm:lodash@4.17.10/isArguments.js",
    "npm:lodash@4.17.10/_baseIsArguments.js",
    "npm:lodash@4.17.10/_baseTimes.js",
    "npm:lodash@4.17.10/isSet.js",
    "npm:lodash@4.17.10/_baseIsSet.js",
    "npm:lodash@4.17.10/_getTag.js",
    "npm:lodash@4.17.10/_WeakMap.js",
    "npm:lodash@4.17.10/_Promise.js",
    "npm:lodash@4.17.10/_DataView.js",
    "npm:lodash@4.17.10/isMap.js",
    "npm:lodash@4.17.10/_baseIsMap.js",
    "npm:lodash@4.17.10/_initCloneObject.js",
    "npm:lodash@4.17.10/_getPrototype.js",
    "npm:lodash@4.17.10/_baseCreate.js",
    "npm:lodash@4.17.10/_initCloneByTag.js",
    "npm:lodash@4.17.10/_cloneTypedArray.js",
    "npm:lodash@4.17.10/_cloneArrayBuffer.js",
    "npm:lodash@4.17.10/_Uint8Array.js",
    "npm:lodash@4.17.10/_cloneSymbol.js",
    "npm:lodash@4.17.10/_cloneRegExp.js",
    "npm:lodash@4.17.10/_cloneDataView.js",
    "npm:lodash@4.17.10/_initCloneArray.js",
    "npm:lodash@4.17.10/_getAllKeysIn.js",
    "npm:lodash@4.17.10/keysIn.js",
    "npm:lodash@4.17.10/_baseKeysIn.js",
    "npm:lodash@4.17.10/_nativeKeysIn.js",
    "npm:lodash@4.17.10/_getSymbolsIn.js",
    "npm:lodash@4.17.10/stubArray.js",
    "npm:lodash@4.17.10/_getSymbols.js",
    "npm:lodash@4.17.10/_arrayFilter.js",
    "npm:lodash@4.17.10/_arrayPush.js",
    "npm:lodash@4.17.10/_baseGetAllKeys.js",
    "npm:lodash@4.17.10/_getAllKeys.js",
    "npm:lodash@4.17.10/_copySymbolsIn.js",
    "npm:lodash@4.17.10/_copyObject.js",
    "npm:lodash@4.17.10/_baseAssignValue.js",
    "npm:lodash@4.17.10/_defineProperty.js",
    "npm:lodash@4.17.10/_assignValue.js",
    "npm:lodash@4.17.10/_copySymbols.js",
    "npm:lodash@4.17.10/_copyArray.js",
    "npm:lodash@4.17.10/_cloneBuffer.js",
    "npm:lodash@4.17.10/_baseAssignIn.js",
    "npm:lodash@4.17.10/_baseAssign.js",
    "npm:lodash@4.17.10/_arrayEach.js",
    "npm:lodash@4.17.10/_Stack.js",
    "npm:lodash@4.17.10/_stackSet.js",
    "npm:lodash@4.17.10/_stackHas.js",
    "npm:lodash@4.17.10/_stackGet.js",
    "npm:lodash@4.17.10/_stackDelete.js",
    "npm:lodash@4.17.10/_stackClear.js",
    "npm:to-fast-properties@1.0.3/index.js",
    "npm:to-fast-properties@1.0.3.json",
    "npm:babel-types@6.26.0/lib/flow.js",
    "npm:babel-types@6.26.0/lib/converters.js",
    "npm:lodash@4.17.10/isRegExp.js",
    "npm:lodash@4.17.10/_baseIsRegExp.js",
    "npm:lodash@4.17.10/isPlainObject.js",
    "npm:babel-runtime@6.26.0/core-js/number/max-safe-integer.js",
    "npm:core-js@2.5.7/library/fn/number/max-safe-integer.js",
    "npm:core-js@2.5.7/library/modules/es6.number.max-safe-integer.js",
    "npm:babel-types@6.26.0/lib/validators.js",
    "npm:babel-types@6.26.0/lib/retrievers.js",
    "npm:babel-runtime@6.26.0/core-js/object/create.js",
    "npm:core-js@2.5.7/library/fn/object/create.js",
    "npm:core-js@2.5.7/library/modules/es6.object.create.js",
    "npm:babel-runtime@6.26.0/core-js/object/keys.js",
    "npm:core-js@2.5.7/library/fn/object/keys.js",
    "npm:core-js@2.5.7/library/modules/es6.object.keys.js",
    "npm:core-js@2.5.7/library/modules/_object-sap.js",
    "npm:babel-runtime@6.26.0/core-js/object/get-own-property-symbols.js",
    "npm:core-js@2.5.7/library/fn/object/get-own-property-symbols.js",
    "npm:babel-preset-flow@6.23.0/lib/index.js",
    "npm:babel-preset-flow@6.23.0.json",
    "npm:babel-plugin-transform-flow-strip-types@6.22.0/lib/index.js",
    "npm:babel-plugin-transform-flow-strip-types@6.22.0.json",
    "npm:babel-plugin-syntax-flow@6.18.0/lib/index.js",
    "npm:babel-plugin-syntax-flow@6.18.0.json"
  ]
}
});


/***/ }),

/***/ 0:
/*!*****************************************!*\
  !*** multi ./src/backend/background.ls ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/marcomora/Documents/Github/unstuck_extension/src/backend/background.ls */"./src/backend/background.ls");


/***/ })

/******/ });